This is gnat_rm.info, produced by makeinfo version 6.5 from
gnat_rm.texi.

     GNAT Reference Manual , Jan 03, 2022

     AdaCore

     Copyright © 2008-2022, Free Software Foundation

INFO-DIR-SECTION GNU Ada Tools
START-INFO-DIR-ENTRY
* gnat_rm: (gnat_rm.info). gnat_rm
END-INFO-DIR-ENTRY


   Generated by Sphinx 4.3.1.


File: gnat_rm.info,  Node: Top,  Next: About This Guide,  Up: (dir)

GNAT Reference Manual
*********************

     GNAT Reference Manual , Jan 03, 2022

     AdaCore

     Copyright © 2008-2022, Free Software Foundation

`GNAT, The GNU Ada Development Environment'

GCC version 12.5.0
AdaCore

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being “GNAT Reference
Manual”, and with no Back-Cover Texts.  A copy of the license is
included in the section entitled *note GNU Free Documentation License:
1.

* Menu:

* About This Guide::
* Implementation Defined Pragmas::
* Implementation Defined Aspects::
* Implementation Defined Attributes::
* Standard and Implementation Defined Restrictions::
* Implementation Advice::
* Implementation Defined Characteristics::
* Intrinsic Subprograms::
* Representation Clauses and Pragmas::
* Standard Library Routines::
* The Implementation of Standard I/O::
* The GNAT Library::
* Interfacing to Other Languages::
* Specialized Needs Annexes::
* Implementation of Specific Ada Features::
* Implementation of Ada 2012 Features::
* Security Hardening Features::
* Obsolescent Features::
* Compatibility and Porting Guide::
* GNU Free Documentation License::
* Index::

 — The Detailed Node Listing —

About This Guide

* What This Reference Manual Contains::
* Conventions::
* Related Information::

Implementation Defined Pragmas

* Pragma Abort_Defer::
* Pragma Abstract_State::
* Pragma Ada_83::
* Pragma Ada_95::
* Pragma Ada_05::
* Pragma Ada_2005::
* Pragma Ada_12::
* Pragma Ada_2012::
* Pragma Aggregate_Individually_Assign::
* Pragma Allow_Integer_Address::
* Pragma Annotate::
* Pragma Assert::
* Pragma Assert_And_Cut::
* Pragma Assertion_Policy::
* Pragma Assume::
* Pragma Assume_No_Invalid_Values::
* Pragma Async_Readers::
* Pragma Async_Writers::
* Pragma Attribute_Definition::
* Pragma C_Pass_By_Copy::
* Pragma Check::
* Pragma Check_Float_Overflow::
* Pragma Check_Name::
* Pragma Check_Policy::
* Pragma Comment::
* Pragma Common_Object::
* Pragma Compile_Time_Error::
* Pragma Compile_Time_Warning::
* Pragma Complete_Representation::
* Pragma Complex_Representation::
* Pragma Component_Alignment::
* Pragma Constant_After_Elaboration::
* Pragma Contract_Cases::
* Pragma Convention_Identifier::
* Pragma CPP_Class::
* Pragma CPP_Constructor::
* Pragma CPP_Virtual::
* Pragma CPP_Vtable::
* Pragma CPU::
* Pragma Deadline_Floor::
* Pragma Default_Initial_Condition::
* Pragma Debug::
* Pragma Debug_Policy::
* Pragma Default_Scalar_Storage_Order::
* Pragma Default_Storage_Pool::
* Pragma Depends::
* Pragma Detect_Blocking::
* Pragma Disable_Atomic_Synchronization::
* Pragma Dispatching_Domain::
* Pragma Effective_Reads::
* Pragma Effective_Writes::
* Pragma Elaboration_Checks::
* Pragma Eliminate::
* Pragma Enable_Atomic_Synchronization::
* Pragma Export_Function::
* Pragma Export_Object::
* Pragma Export_Procedure::
* Pragma Export_Valued_Procedure::
* Pragma Extend_System::
* Pragma Extensions_Allowed::
* Pragma Extensions_Visible::
* Pragma External::
* Pragma External_Name_Casing::
* Pragma Fast_Math::
* Pragma Favor_Top_Level::
* Pragma Finalize_Storage_Only::
* Pragma Float_Representation::
* Pragma Ghost::
* Pragma Global::
* Pragma Ident::
* Pragma Ignore_Pragma::
* Pragma Implementation_Defined::
* Pragma Implemented::
* Pragma Implicit_Packing::
* Pragma Import_Function::
* Pragma Import_Object::
* Pragma Import_Procedure::
* Pragma Import_Valued_Procedure::
* Pragma Independent::
* Pragma Independent_Components::
* Pragma Initial_Condition::
* Pragma Initialize_Scalars::
* Pragma Initializes::
* Pragma Inline_Always::
* Pragma Inline_Generic::
* Pragma Interface::
* Pragma Interface_Name::
* Pragma Interrupt_Handler::
* Pragma Interrupt_State::
* Pragma Invariant::
* Pragma Keep_Names::
* Pragma License::
* Pragma Link_With::
* Pragma Linker_Alias::
* Pragma Linker_Constructor::
* Pragma Linker_Destructor::
* Pragma Linker_Section::
* Pragma Lock_Free::
* Pragma Loop_Invariant::
* Pragma Loop_Optimize::
* Pragma Loop_Variant::
* Pragma Machine_Attribute::
* Pragma Main::
* Pragma Main_Storage::
* Pragma Max_Queue_Length::
* Pragma No_Body::
* Pragma No_Caching::
* Pragma No_Component_Reordering::
* Pragma No_Elaboration_Code_All::
* Pragma No_Heap_Finalization::
* Pragma No_Inline::
* Pragma No_Return::
* Pragma No_Strict_Aliasing::
* Pragma No_Tagged_Streams::
* Pragma Normalize_Scalars::
* Pragma Obsolescent::
* Pragma Optimize_Alignment::
* Pragma Ordered::
* Pragma Overflow_Mode::
* Pragma Overriding_Renamings::
* Pragma Partition_Elaboration_Policy::
* Pragma Part_Of::
* Pragma Passive::
* Pragma Persistent_BSS::
* Pragma Post::
* Pragma Postcondition::
* Pragma Post_Class::
* Pragma Pre::
* Pragma Precondition::
* Pragma Predicate::
* Pragma Predicate_Failure::
* Pragma Preelaborable_Initialization::
* Pragma Prefix_Exception_Messages::
* Pragma Pre_Class::
* Pragma Priority_Specific_Dispatching::
* Pragma Profile::
* Pragma Profile_Warnings::
* Pragma Propagate_Exceptions::
* Pragma Provide_Shift_Operators::
* Pragma Psect_Object::
* Pragma Pure_Function::
* Pragma Rational::
* Pragma Ravenscar::
* Pragma Refined_Depends::
* Pragma Refined_Global::
* Pragma Refined_Post::
* Pragma Refined_State::
* Pragma Relative_Deadline::
* Pragma Remote_Access_Type::
* Pragma Rename_Pragma::
* Pragma Restricted_Run_Time::
* Pragma Restriction_Warnings::
* Pragma Reviewable::
* Pragma Secondary_Stack_Size::
* Pragma Share_Generic::
* Pragma Shared::
* Pragma Short_Circuit_And_Or::
* Pragma Short_Descriptors::
* Pragma Simple_Storage_Pool_Type::
* Pragma Source_File_Name::
* Pragma Source_File_Name_Project::
* Pragma Source_Reference::
* Pragma SPARK_Mode::
* Pragma Static_Elaboration_Desired::
* Pragma Stream_Convert::
* Pragma Style_Checks::
* Pragma Subtitle::
* Pragma Suppress::
* Pragma Suppress_All::
* Pragma Suppress_Debug_Info::
* Pragma Suppress_Exception_Locations::
* Pragma Suppress_Initialization::
* Pragma Task_Name::
* Pragma Task_Storage::
* Pragma Test_Case::
* Pragma Thread_Local_Storage::
* Pragma Time_Slice::
* Pragma Title::
* Pragma Type_Invariant::
* Pragma Type_Invariant_Class::
* Pragma Unchecked_Union::
* Pragma Unevaluated_Use_Of_Old::
* Pragma Unimplemented_Unit::
* Pragma Universal_Aliasing::
* Pragma Unmodified::
* Pragma Unreferenced::
* Pragma Unreferenced_Objects::
* Pragma Unreserve_All_Interrupts::
* Pragma Unsuppress::
* Pragma Use_VADS_Size::
* Pragma Unused::
* Pragma Validity_Checks::
* Pragma Volatile::
* Pragma Volatile_Full_Access::
* Pragma Volatile_Function::
* Pragma Warning_As_Error::
* Pragma Warnings::
* Pragma Weak_External::
* Pragma Wide_Character_Encoding::

Implementation Defined Aspects

* Aspect Abstract_State::
* Aspect Annotate::
* Aspect Async_Readers::
* Aspect Async_Writers::
* Aspect Constant_After_Elaboration::
* Aspect Contract_Cases::
* Aspect Depends::
* Aspect Default_Initial_Condition::
* Aspect Dimension::
* Aspect Dimension_System::
* Aspect Disable_Controlled::
* Aspect Effective_Reads::
* Aspect Effective_Writes::
* Aspect Extensions_Visible::
* Aspect Favor_Top_Level::
* Aspect Ghost::
* Aspect Global::
* Aspect Initial_Condition::
* Aspect Initializes::
* Aspect Inline_Always::
* Aspect Invariant::
* Aspect Invariant’Class::
* Aspect Iterable::
* Aspect Linker_Section::
* Aspect Lock_Free::
* Aspect Max_Queue_Length::
* Aspect No_Caching::
* Aspect No_Elaboration_Code_All::
* Aspect No_Inline::
* Aspect No_Tagged_Streams::
* Aspect No_Task_Parts::
* Aspect Object_Size::
* Aspect Obsolescent::
* Aspect Part_Of::
* Aspect Persistent_BSS::
* Aspect Predicate::
* Aspect Pure_Function::
* Aspect Refined_Depends::
* Aspect Refined_Global::
* Aspect Refined_Post::
* Aspect Refined_State::
* Aspect Relaxed_Initialization::
* Aspect Remote_Access_Type::
* Aspect Secondary_Stack_Size::
* Aspect Scalar_Storage_Order::
* Aspect Shared::
* Aspect Simple_Storage_Pool::
* Aspect Simple_Storage_Pool_Type::
* Aspect SPARK_Mode::
* Aspect Suppress_Debug_Info::
* Aspect Suppress_Initialization::
* Aspect Test_Case::
* Aspect Thread_Local_Storage::
* Aspect Universal_Aliasing::
* Aspect Unmodified::
* Aspect Unreferenced::
* Aspect Unreferenced_Objects::
* Aspect Value_Size::
* Aspect Volatile_Full_Access::
* Aspect Volatile_Function::
* Aspect Warnings::

Implementation Defined Attributes

* Attribute Abort_Signal::
* Attribute Address_Size::
* Attribute Asm_Input::
* Attribute Asm_Output::
* Attribute Atomic_Always_Lock_Free::
* Attribute Bit::
* Attribute Bit_Position::
* Attribute Code_Address::
* Attribute Compiler_Version::
* Attribute Constrained::
* Attribute Default_Bit_Order::
* Attribute Default_Scalar_Storage_Order::
* Attribute Deref::
* Attribute Descriptor_Size::
* Attribute Elaborated::
* Attribute Elab_Body::
* Attribute Elab_Spec::
* Attribute Elab_Subp_Body::
* Attribute Emax::
* Attribute Enabled::
* Attribute Enum_Rep::
* Attribute Enum_Val::
* Attribute Epsilon::
* Attribute Fast_Math::
* Attribute Finalization_Size::
* Attribute Fixed_Value::
* Attribute From_Any::
* Attribute Has_Access_Values::
* Attribute Has_Discriminants::
* Attribute Has_Tagged_Values::
* Attribute Img::
* Attribute Initialized::
* Attribute Integer_Value::
* Attribute Invalid_Value::
* Attribute Iterable::
* Attribute Large::
* Attribute Library_Level::
* Attribute Lock_Free::
* Attribute Loop_Entry::
* Attribute Machine_Size::
* Attribute Mantissa::
* Attribute Maximum_Alignment::
* Attribute Max_Integer_Size::
* Attribute Mechanism_Code::
* Attribute Null_Parameter::
* Attribute Object_Size::
* Attribute Old::
* Attribute Passed_By_Reference::
* Attribute Pool_Address::
* Attribute Range_Length::
* Attribute Restriction_Set::
* Attribute Result::
* Attribute Safe_Emax::
* Attribute Safe_Large::
* Attribute Safe_Small::
* Attribute Scalar_Storage_Order::
* Attribute Simple_Storage_Pool::
* Attribute Small::
* Attribute Small_Denominator::
* Attribute Small_Numerator::
* Attribute Storage_Unit::
* Attribute Stub_Type::
* Attribute System_Allocator_Alignment::
* Attribute Target_Name::
* Attribute To_Address::
* Attribute To_Any::
* Attribute Type_Class::
* Attribute Type_Key::
* Attribute TypeCode::
* Attribute Unconstrained_Array::
* Attribute Universal_Literal_String::
* Attribute Unrestricted_Access::
* Attribute Update::
* Attribute Valid_Image::
* Attribute Valid_Scalars::
* Attribute VADS_Size::
* Attribute Value_Size::
* Attribute Wchar_T_Size::
* Attribute Word_Size::

Standard and Implementation Defined Restrictions

* Partition-Wide Restrictions::
* Program Unit Level Restrictions::

Partition-Wide Restrictions

* Immediate_Reclamation::
* Max_Asynchronous_Select_Nesting::
* Max_Entry_Queue_Length::
* Max_Protected_Entries::
* Max_Select_Alternatives::
* Max_Storage_At_Blocking::
* Max_Task_Entries::
* Max_Tasks::
* No_Abort_Statements::
* No_Access_Parameter_Allocators::
* No_Access_Subprograms::
* No_Allocators::
* No_Anonymous_Allocators::
* No_Asynchronous_Control::
* No_Calendar::
* No_Coextensions::
* No_Default_Initialization::
* No_Delay::
* No_Dependence::
* No_Direct_Boolean_Operators::
* No_Dispatch::
* No_Dispatching_Calls::
* No_Dynamic_Attachment::
* No_Dynamic_Priorities::
* No_Entry_Calls_In_Elaboration_Code::
* No_Enumeration_Maps::
* No_Exception_Handlers::
* No_Exception_Propagation::
* No_Exception_Registration::
* No_Exceptions::
* No_Finalization::
* No_Fixed_Point::
* No_Floating_Point::
* No_Implicit_Conditionals::
* No_Implicit_Dynamic_Code::
* No_Implicit_Heap_Allocations::
* No_Implicit_Protected_Object_Allocations::
* No_Implicit_Task_Allocations::
* No_Initialize_Scalars::
* No_IO::
* No_Local_Allocators::
* No_Local_Protected_Objects::
* No_Local_Timing_Events::
* No_Long_Long_Integers::
* No_Multiple_Elaboration::
* No_Nested_Finalization::
* No_Protected_Type_Allocators::
* No_Protected_Types::
* No_Recursion::
* No_Reentrancy::
* No_Relative_Delay::
* No_Requeue_Statements::
* No_Secondary_Stack::
* No_Select_Statements::
* No_Specific_Termination_Handlers::
* No_Specification_of_Aspect::
* No_Standard_Allocators_After_Elaboration::
* No_Standard_Storage_Pools::
* No_Stream_Optimizations::
* No_Streams::
* No_Tagged_Type_Registration::
* No_Task_Allocators::
* No_Task_At_Interrupt_Priority::
* No_Task_Attributes_Package::
* No_Task_Hierarchy::
* No_Task_Termination::
* No_Tasking::
* No_Terminate_Alternatives::
* No_Unchecked_Access::
* No_Unchecked_Conversion::
* No_Unchecked_Deallocation::
* No_Use_Of_Entity::
* Pure_Barriers::
* Simple_Barriers::
* Static_Priorities::
* Static_Storage_Size::

Program Unit Level Restrictions

* No_Elaboration_Code::
* No_Dynamic_Accessibility_Checks::
* No_Dynamic_Sized_Objects::
* No_Entry_Queue::
* No_Implementation_Aspect_Specifications::
* No_Implementation_Attributes::
* No_Implementation_Identifiers::
* No_Implementation_Pragmas::
* No_Implementation_Restrictions::
* No_Implementation_Units::
* No_Implicit_Aliasing::
* No_Implicit_Loops::
* No_Obsolescent_Features::
* No_Wide_Characters::
* Static_Dispatch_Tables::
* SPARK_05::

Implementation Advice

* RM 1.1.3(20); Error Detection: RM 1 1 3 20 Error Detection.
* RM 1.1.3(31); Child Units: RM 1 1 3 31 Child Units.
* RM 1.1.5(12); Bounded Errors: RM 1 1 5 12 Bounded Errors.
* RM 2.8(16); Pragmas: RM 2 8 16 Pragmas.
* RM 2.8(17-19); Pragmas: RM 2 8 17-19 Pragmas.
* RM 3.5.2(5); Alternative Character Sets: RM 3 5 2 5 Alternative Character Sets.
* RM 3.5.4(28); Integer Types: RM 3 5 4 28 Integer Types.
* RM 3.5.4(29); Integer Types: RM 3 5 4 29 Integer Types.
* RM 3.5.5(8); Enumeration Values: RM 3 5 5 8 Enumeration Values.
* RM 3.5.7(17); Float Types: RM 3 5 7 17 Float Types.
* RM 3.6.2(11); Multidimensional Arrays: RM 3 6 2 11 Multidimensional Arrays.
* RM 9.6(30-31); Duration’Small: RM 9 6 30-31 Duration’Small.
* RM 10.2.1(12); Consistent Representation: RM 10 2 1 12 Consistent Representation.
* RM 11.4.1(19); Exception Information: RM 11 4 1 19 Exception Information.
* RM 11.5(28); Suppression of Checks: RM 11 5 28 Suppression of Checks.
* RM 13.1 (21-24); Representation Clauses: RM 13 1 21-24 Representation Clauses.
* RM 13.2(6-8); Packed Types: RM 13 2 6-8 Packed Types.
* RM 13.3(14-19); Address Clauses: RM 13 3 14-19 Address Clauses.
* RM 13.3(29-35); Alignment Clauses: RM 13 3 29-35 Alignment Clauses.
* RM 13.3(42-43); Size Clauses: RM 13 3 42-43 Size Clauses.
* RM 13.3(50-56); Size Clauses: RM 13 3 50-56 Size Clauses.
* RM 13.3(71-73); Component Size Clauses: RM 13 3 71-73 Component Size Clauses.
* RM 13.4(9-10); Enumeration Representation Clauses: RM 13 4 9-10 Enumeration Representation Clauses.
* RM 13.5.1(17-22); Record Representation Clauses: RM 13 5 1 17-22 Record Representation Clauses.
* RM 13.5.2(5); Storage Place Attributes: RM 13 5 2 5 Storage Place Attributes.
* RM 13.5.3(7-8); Bit Ordering: RM 13 5 3 7-8 Bit Ordering.
* RM 13.7(37); Address as Private: RM 13 7 37 Address as Private.
* RM 13.7.1(16); Address Operations: RM 13 7 1 16 Address Operations.
* RM 13.9(14-17); Unchecked Conversion: RM 13 9 14-17 Unchecked Conversion.
* RM 13.11(23-25); Implicit Heap Usage: RM 13 11 23-25 Implicit Heap Usage.
* RM 13.11.2(17); Unchecked Deallocation: RM 13 11 2 17 Unchecked Deallocation.
* RM 13.13.2(1.6); Stream Oriented Attributes: RM 13 13 2 1 6 Stream Oriented Attributes.
* RM A.1(52); Names of Predefined Numeric Types: RM A 1 52 Names of Predefined Numeric Types.
* RM A.3.2(49); Ada.Characters.Handling: RM A 3 2 49 Ada Characters Handling.
* RM A.4.4(106); Bounded-Length String Handling: RM A 4 4 106 Bounded-Length String Handling.
* RM A.5.2(46-47); Random Number Generation: RM A 5 2 46-47 Random Number Generation.
* RM A.10.7(23); Get_Immediate: RM A 10 7 23 Get_Immediate.
* RM A.18; Containers: RM A 18 Containers.
* RM B.1(39-41); Pragma Export: RM B 1 39-41 Pragma Export.
* RM B.2(12-13); Package Interfaces: RM B 2 12-13 Package Interfaces.
* RM B.3(63-71); Interfacing with C: RM B 3 63-71 Interfacing with C.
* RM B.4(95-98); Interfacing with COBOL: RM B 4 95-98 Interfacing with COBOL.
* RM B.5(22-26); Interfacing with Fortran: RM B 5 22-26 Interfacing with Fortran.
* RM C.1(3-5); Access to Machine Operations: RM C 1 3-5 Access to Machine Operations.
* RM C.1(10-16); Access to Machine Operations: RM C 1 10-16 Access to Machine Operations.
* RM C.3(28); Interrupt Support: RM C 3 28 Interrupt Support.
* RM C.3.1(20-21); Protected Procedure Handlers: RM C 3 1 20-21 Protected Procedure Handlers.
* RM C.3.2(25); Package Interrupts: RM C 3 2 25 Package Interrupts.
* RM C.4(14); Pre-elaboration Requirements: RM C 4 14 Pre-elaboration Requirements.
* RM C.5(8); Pragma Discard_Names: RM C 5 8 Pragma Discard_Names.
* RM C.7.2(30); The Package Task_Attributes: RM C 7 2 30 The Package Task_Attributes.
* RM D.3(17); Locking Policies: RM D 3 17 Locking Policies.
* RM D.4(16); Entry Queuing Policies: RM D 4 16 Entry Queuing Policies.
* RM D.6(9-10); Preemptive Abort: RM D 6 9-10 Preemptive Abort.
* RM D.7(21); Tasking Restrictions: RM D 7 21 Tasking Restrictions.
* RM D.8(47-49); Monotonic Time: RM D 8 47-49 Monotonic Time.
* RM E.5(28-29); Partition Communication Subsystem: RM E 5 28-29 Partition Communication Subsystem.
* RM F(7); COBOL Support: RM F 7 COBOL Support.
* RM F.1(2); Decimal Radix Support: RM F 1 2 Decimal Radix Support.
* RM G; Numerics: RM G Numerics.
* RM G.1.1(56-58); Complex Types: RM G 1 1 56-58 Complex Types.
* RM G.1.2(49); Complex Elementary Functions: RM G 1 2 49 Complex Elementary Functions.
* RM G.2.4(19); Accuracy Requirements: RM G 2 4 19 Accuracy Requirements.
* RM G.2.6(15); Complex Arithmetic Accuracy: RM G 2 6 15 Complex Arithmetic Accuracy.
* RM H.6(15/2); Pragma Partition_Elaboration_Policy: RM H 6 15/2 Pragma Partition_Elaboration_Policy.

Intrinsic Subprograms

* Intrinsic Operators::
* Compilation_ISO_Date::
* Compilation_Date::
* Compilation_Time::
* Enclosing_Entity::
* Exception_Information::
* Exception_Message::
* Exception_Name::
* File::
* Line::
* Shifts and Rotates::
* Source_Location::

Representation Clauses and Pragmas

* Alignment Clauses::
* Size Clauses::
* Storage_Size Clauses::
* Size of Variant Record Objects::
* Biased Representation::
* Value_Size and Object_Size Clauses::
* Component_Size Clauses::
* Bit_Order Clauses::
* Effect of Bit_Order on Byte Ordering::
* Pragma Pack for Arrays::
* Pragma Pack for Records::
* Record Representation Clauses::
* Handling of Records with Holes::
* Enumeration Clauses::
* Address Clauses::
* Use of Address Clauses for Memory-Mapped I/O::
* Effect of Convention on Representation::
* Conventions and Anonymous Access Types::
* Determining the Representations chosen by GNAT::

The Implementation of Standard I/O

* Standard I/O Packages::
* FORM Strings::
* Direct_IO::
* Sequential_IO::
* Text_IO::
* Wide_Text_IO::
* Wide_Wide_Text_IO::
* Stream_IO::
* Text Translation::
* Shared Files::
* Filenames encoding::
* File content encoding::
* Open Modes::
* Operations on C Streams::
* Interfacing to C Streams::

Text_IO

* Stream Pointer Positioning::
* Reading and Writing Non-Regular Files::
* Get_Immediate::
* Treating Text_IO Files as Streams::
* Text_IO Extensions::
* Text_IO Facilities for Unbounded Strings::

Wide_Text_IO

* Stream Pointer Positioning: Stream Pointer Positioning<2>.
* Reading and Writing Non-Regular Files: Reading and Writing Non-Regular Files<2>.

Wide_Wide_Text_IO

* Stream Pointer Positioning: Stream Pointer Positioning<3>.
* Reading and Writing Non-Regular Files: Reading and Writing Non-Regular Files<3>.

The GNAT Library

* Ada.Characters.Latin_9 (a-chlat9.ads): Ada Characters Latin_9 a-chlat9 ads.
* Ada.Characters.Wide_Latin_1 (a-cwila1.ads): Ada Characters Wide_Latin_1 a-cwila1 ads.
* Ada.Characters.Wide_Latin_9 (a-cwila1.ads): Ada Characters Wide_Latin_9 a-cwila1 ads.
* Ada.Characters.Wide_Wide_Latin_1 (a-chzla1.ads): Ada Characters Wide_Wide_Latin_1 a-chzla1 ads.
* Ada.Characters.Wide_Wide_Latin_9 (a-chzla9.ads): Ada Characters Wide_Wide_Latin_9 a-chzla9 ads.
* Ada.Containers.Formal_Doubly_Linked_Lists (a-cfdlli.ads): Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads.
* Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads): Ada Containers Formal_Hashed_Maps a-cfhama ads.
* Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads): Ada Containers Formal_Hashed_Sets a-cfhase ads.
* Ada.Containers.Formal_Ordered_Maps (a-cforma.ads): Ada Containers Formal_Ordered_Maps a-cforma ads.
* Ada.Containers.Formal_Ordered_Sets (a-cforse.ads): Ada Containers Formal_Ordered_Sets a-cforse ads.
* Ada.Containers.Formal_Vectors (a-cofove.ads): Ada Containers Formal_Vectors a-cofove ads.
* Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads): Ada Containers Formal_Indefinite_Vectors a-cfinve ads.
* Ada.Containers.Functional_Vectors (a-cofuve.ads): Ada Containers Functional_Vectors a-cofuve ads.
* Ada.Containers.Functional_Sets (a-cofuse.ads): Ada Containers Functional_Sets a-cofuse ads.
* Ada.Containers.Functional_Maps (a-cofuma.ads): Ada Containers Functional_Maps a-cofuma ads.
* Ada.Containers.Bounded_Holders (a-coboho.ads): Ada Containers Bounded_Holders a-coboho ads.
* Ada.Command_Line.Environment (a-colien.ads): Ada Command_Line Environment a-colien ads.
* Ada.Command_Line.Remove (a-colire.ads): Ada Command_Line Remove a-colire ads.
* Ada.Command_Line.Response_File (a-clrefi.ads): Ada Command_Line Response_File a-clrefi ads.
* Ada.Direct_IO.C_Streams (a-diocst.ads): Ada Direct_IO C_Streams a-diocst ads.
* Ada.Exceptions.Is_Null_Occurrence (a-einuoc.ads): Ada Exceptions Is_Null_Occurrence a-einuoc ads.
* Ada.Exceptions.Last_Chance_Handler (a-elchha.ads): Ada Exceptions Last_Chance_Handler a-elchha ads.
* Ada.Exceptions.Traceback (a-exctra.ads): Ada Exceptions Traceback a-exctra ads.
* Ada.Sequential_IO.C_Streams (a-siocst.ads): Ada Sequential_IO C_Streams a-siocst ads.
* Ada.Streams.Stream_IO.C_Streams (a-ssicst.ads): Ada Streams Stream_IO C_Streams a-ssicst ads.
* Ada.Strings.Unbounded.Text_IO (a-suteio.ads): Ada Strings Unbounded Text_IO a-suteio ads.
* Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads): Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
* Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads): Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
* Ada.Task_Initialization (a-tasini.ads): Ada Task_Initialization a-tasini ads.
* Ada.Text_IO.C_Streams (a-tiocst.ads): Ada Text_IO C_Streams a-tiocst ads.
* Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads): Ada Text_IO Reset_Standard_Files a-tirsfi ads.
* Ada.Wide_Characters.Unicode (a-wichun.ads): Ada Wide_Characters Unicode a-wichun ads.
* Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads): Ada Wide_Text_IO C_Streams a-wtcstr ads.
* Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads): Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads.
* Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads): Ada Wide_Wide_Characters Unicode a-zchuni ads.
* Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads): Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads.
* Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads): Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads.
* GNAT.Altivec (g-altive.ads): GNAT Altivec g-altive ads.
* GNAT.Altivec.Conversions (g-altcon.ads): GNAT Altivec Conversions g-altcon ads.
* GNAT.Altivec.Vector_Operations (g-alveop.ads): GNAT Altivec Vector_Operations g-alveop ads.
* GNAT.Altivec.Vector_Types (g-alvety.ads): GNAT Altivec Vector_Types g-alvety ads.
* GNAT.Altivec.Vector_Views (g-alvevi.ads): GNAT Altivec Vector_Views g-alvevi ads.
* GNAT.Array_Split (g-arrspl.ads): GNAT Array_Split g-arrspl ads.
* GNAT.AWK (g-awk.ads): GNAT AWK g-awk ads.
* GNAT.Bind_Environment (g-binenv.ads): GNAT Bind_Environment g-binenv ads.
* GNAT.Branch_Prediction (g-brapre.ads): GNAT Branch_Prediction g-brapre ads.
* GNAT.Bounded_Buffers (g-boubuf.ads): GNAT Bounded_Buffers g-boubuf ads.
* GNAT.Bounded_Mailboxes (g-boumai.ads): GNAT Bounded_Mailboxes g-boumai ads.
* GNAT.Bubble_Sort (g-bubsor.ads): GNAT Bubble_Sort g-bubsor ads.
* GNAT.Bubble_Sort_A (g-busora.ads): GNAT Bubble_Sort_A g-busora ads.
* GNAT.Bubble_Sort_G (g-busorg.ads): GNAT Bubble_Sort_G g-busorg ads.
* GNAT.Byte_Order_Mark (g-byorma.ads): GNAT Byte_Order_Mark g-byorma ads.
* GNAT.Byte_Swapping (g-bytswa.ads): GNAT Byte_Swapping g-bytswa ads.
* GNAT.Calendar (g-calend.ads): GNAT Calendar g-calend ads.
* GNAT.Calendar.Time_IO (g-catiio.ads): GNAT Calendar Time_IO g-catiio ads.
* GNAT.CRC32 (g-crc32.ads): GNAT CRC32 g-crc32 ads.
* GNAT.Case_Util (g-casuti.ads): GNAT Case_Util g-casuti ads.
* GNAT.CGI (g-cgi.ads): GNAT CGI g-cgi ads.
* GNAT.CGI.Cookie (g-cgicoo.ads): GNAT CGI Cookie g-cgicoo ads.
* GNAT.CGI.Debug (g-cgideb.ads): GNAT CGI Debug g-cgideb ads.
* GNAT.Command_Line (g-comlin.ads): GNAT Command_Line g-comlin ads.
* GNAT.Compiler_Version (g-comver.ads): GNAT Compiler_Version g-comver ads.
* GNAT.Ctrl_C (g-ctrl_c.ads): GNAT Ctrl_C g-ctrl_c ads.
* GNAT.Current_Exception (g-curexc.ads): GNAT Current_Exception g-curexc ads.
* GNAT.Debug_Pools (g-debpoo.ads): GNAT Debug_Pools g-debpoo ads.
* GNAT.Debug_Utilities (g-debuti.ads): GNAT Debug_Utilities g-debuti ads.
* GNAT.Decode_String (g-decstr.ads): GNAT Decode_String g-decstr ads.
* GNAT.Decode_UTF8_String (g-deutst.ads): GNAT Decode_UTF8_String g-deutst ads.
* GNAT.Directory_Operations (g-dirope.ads): GNAT Directory_Operations g-dirope ads.
* GNAT.Directory_Operations.Iteration (g-diopit.ads): GNAT Directory_Operations Iteration g-diopit ads.
* GNAT.Dynamic_HTables (g-dynhta.ads): GNAT Dynamic_HTables g-dynhta ads.
* GNAT.Dynamic_Tables (g-dyntab.ads): GNAT Dynamic_Tables g-dyntab ads.
* GNAT.Encode_String (g-encstr.ads): GNAT Encode_String g-encstr ads.
* GNAT.Encode_UTF8_String (g-enutst.ads): GNAT Encode_UTF8_String g-enutst ads.
* GNAT.Exception_Actions (g-excact.ads): GNAT Exception_Actions g-excact ads.
* GNAT.Exception_Traces (g-exctra.ads): GNAT Exception_Traces g-exctra ads.
* GNAT.Exceptions (g-except.ads): GNAT Exceptions g-except ads.
* GNAT.Expect (g-expect.ads): GNAT Expect g-expect ads.
* GNAT.Expect.TTY (g-exptty.ads): GNAT Expect TTY g-exptty ads.
* GNAT.Float_Control (g-flocon.ads): GNAT Float_Control g-flocon ads.
* GNAT.Formatted_String (g-forstr.ads): GNAT Formatted_String g-forstr ads.
* GNAT.Heap_Sort (g-heasor.ads): GNAT Heap_Sort g-heasor ads.
* GNAT.Heap_Sort_A (g-hesora.ads): GNAT Heap_Sort_A g-hesora ads.
* GNAT.Heap_Sort_G (g-hesorg.ads): GNAT Heap_Sort_G g-hesorg ads.
* GNAT.HTable (g-htable.ads): GNAT HTable g-htable ads.
* GNAT.IO (g-io.ads): GNAT IO g-io ads.
* GNAT.IO_Aux (g-io_aux.ads): GNAT IO_Aux g-io_aux ads.
* GNAT.Lock_Files (g-locfil.ads): GNAT Lock_Files g-locfil ads.
* GNAT.MBBS_Discrete_Random (g-mbdira.ads): GNAT MBBS_Discrete_Random g-mbdira ads.
* GNAT.MBBS_Float_Random (g-mbflra.ads): GNAT MBBS_Float_Random g-mbflra ads.
* GNAT.MD5 (g-md5.ads): GNAT MD5 g-md5 ads.
* GNAT.Memory_Dump (g-memdum.ads): GNAT Memory_Dump g-memdum ads.
* GNAT.Most_Recent_Exception (g-moreex.ads): GNAT Most_Recent_Exception g-moreex ads.
* GNAT.OS_Lib (g-os_lib.ads): GNAT OS_Lib g-os_lib ads.
* GNAT.Perfect_Hash_Generators (g-pehage.ads): GNAT Perfect_Hash_Generators g-pehage ads.
* GNAT.Random_Numbers (g-rannum.ads): GNAT Random_Numbers g-rannum ads.
* GNAT.Regexp (g-regexp.ads): GNAT Regexp g-regexp ads.
* GNAT.Registry (g-regist.ads): GNAT Registry g-regist ads.
* GNAT.Regpat (g-regpat.ads): GNAT Regpat g-regpat ads.
* GNAT.Rewrite_Data (g-rewdat.ads): GNAT Rewrite_Data g-rewdat ads.
* GNAT.Secondary_Stack_Info (g-sestin.ads): GNAT Secondary_Stack_Info g-sestin ads.
* GNAT.Semaphores (g-semaph.ads): GNAT Semaphores g-semaph ads.
* GNAT.Serial_Communications (g-sercom.ads): GNAT Serial_Communications g-sercom ads.
* GNAT.SHA1 (g-sha1.ads): GNAT SHA1 g-sha1 ads.
* GNAT.SHA224 (g-sha224.ads): GNAT SHA224 g-sha224 ads.
* GNAT.SHA256 (g-sha256.ads): GNAT SHA256 g-sha256 ads.
* GNAT.SHA384 (g-sha384.ads): GNAT SHA384 g-sha384 ads.
* GNAT.SHA512 (g-sha512.ads): GNAT SHA512 g-sha512 ads.
* GNAT.Signals (g-signal.ads): GNAT Signals g-signal ads.
* GNAT.Sockets (g-socket.ads): GNAT Sockets g-socket ads.
* GNAT.Source_Info (g-souinf.ads): GNAT Source_Info g-souinf ads.
* GNAT.Spelling_Checker (g-speche.ads): GNAT Spelling_Checker g-speche ads.
* GNAT.Spelling_Checker_Generic (g-spchge.ads): GNAT Spelling_Checker_Generic g-spchge ads.
* GNAT.Spitbol.Patterns (g-spipat.ads): GNAT Spitbol Patterns g-spipat ads.
* GNAT.Spitbol (g-spitbo.ads): GNAT Spitbol g-spitbo ads.
* GNAT.Spitbol.Table_Boolean (g-sptabo.ads): GNAT Spitbol Table_Boolean g-sptabo ads.
* GNAT.Spitbol.Table_Integer (g-sptain.ads): GNAT Spitbol Table_Integer g-sptain ads.
* GNAT.Spitbol.Table_VString (g-sptavs.ads): GNAT Spitbol Table_VString g-sptavs ads.
* GNAT.SSE (g-sse.ads): GNAT SSE g-sse ads.
* GNAT.SSE.Vector_Types (g-ssvety.ads): GNAT SSE Vector_Types g-ssvety ads.
* GNAT.String_Hash (g-strhas.ads): GNAT String_Hash g-strhas ads.
* GNAT.Strings (g-string.ads): GNAT Strings g-string ads.
* GNAT.String_Split (g-strspl.ads): GNAT String_Split g-strspl ads.
* GNAT.Table (g-table.ads): GNAT Table g-table ads.
* GNAT.Task_Lock (g-tasloc.ads): GNAT Task_Lock g-tasloc ads.
* GNAT.Time_Stamp (g-timsta.ads): GNAT Time_Stamp g-timsta ads.
* GNAT.Threads (g-thread.ads): GNAT Threads g-thread ads.
* GNAT.Traceback (g-traceb.ads): GNAT Traceback g-traceb ads.
* GNAT.Traceback.Symbolic (g-trasym.ads): GNAT Traceback Symbolic g-trasym ads.
* GNAT.UTF_32 (g-table.ads): GNAT UTF_32 g-table ads.
* GNAT.Wide_Spelling_Checker (g-u3spch.ads): GNAT Wide_Spelling_Checker g-u3spch ads.
* GNAT.Wide_Spelling_Checker (g-wispch.ads): GNAT Wide_Spelling_Checker g-wispch ads.
* GNAT.Wide_String_Split (g-wistsp.ads): GNAT Wide_String_Split g-wistsp ads.
* GNAT.Wide_Wide_Spelling_Checker (g-zspche.ads): GNAT Wide_Wide_Spelling_Checker g-zspche ads.
* GNAT.Wide_Wide_String_Split (g-zistsp.ads): GNAT Wide_Wide_String_Split g-zistsp ads.
* Interfaces.C.Extensions (i-cexten.ads): Interfaces C Extensions i-cexten ads.
* Interfaces.C.Streams (i-cstrea.ads): Interfaces C Streams i-cstrea ads.
* Interfaces.Packed_Decimal (i-pacdec.ads): Interfaces Packed_Decimal i-pacdec ads.
* Interfaces.VxWorks (i-vxwork.ads): Interfaces VxWorks i-vxwork ads.
* Interfaces.VxWorks.Int_Connection (i-vxinco.ads): Interfaces VxWorks Int_Connection i-vxinco ads.
* Interfaces.VxWorks.IO (i-vxwoio.ads): Interfaces VxWorks IO i-vxwoio ads.
* System.Address_Image (s-addima.ads): System Address_Image s-addima ads.
* System.Assertions (s-assert.ads): System Assertions s-assert ads.
* System.Atomic_Counters (s-atocou.ads): System Atomic_Counters s-atocou ads.
* System.Memory (s-memory.ads): System Memory s-memory ads.
* System.Multiprocessors (s-multip.ads): System Multiprocessors s-multip ads.
* System.Multiprocessors.Dispatching_Domains (s-mudido.ads): System Multiprocessors Dispatching_Domains s-mudido ads.
* System.Partition_Interface (s-parint.ads): System Partition_Interface s-parint ads.
* System.Pool_Global (s-pooglo.ads): System Pool_Global s-pooglo ads.
* System.Pool_Local (s-pooloc.ads): System Pool_Local s-pooloc ads.
* System.Restrictions (s-restri.ads): System Restrictions s-restri ads.
* System.Rident (s-rident.ads): System Rident s-rident ads.
* System.Strings.Stream_Ops (s-ststop.ads): System Strings Stream_Ops s-ststop ads.
* System.Unsigned_Types (s-unstyp.ads): System Unsigned_Types s-unstyp ads.
* System.Wch_Cnv (s-wchcnv.ads): System Wch_Cnv s-wchcnv ads.
* System.Wch_Con (s-wchcon.ads): System Wch_Con s-wchcon ads.

Interfacing to Other Languages

* Interfacing to C::
* Interfacing to C++::
* Interfacing to COBOL::
* Interfacing to Fortran::
* Interfacing to non-GNAT Ada code::

Implementation of Specific Ada Features

* Machine Code Insertions::
* GNAT Implementation of Tasking::
* GNAT Implementation of Shared Passive Packages::
* Code Generation for Array Aggregates::
* The Size of Discriminated Records with Default Discriminants::
* Image Values For Nonscalar Types::
* Strict Conformance to the Ada Reference Manual::

GNAT Implementation of Tasking

* Mapping Ada Tasks onto the Underlying Kernel Threads::
* Ensuring Compliance with the Real-Time Annex::
* Support for Locking Policies::

Code Generation for Array Aggregates

* Static constant aggregates with static bounds::
* Constant aggregates with unconstrained nominal types::
* Aggregates with static bounds::
* Aggregates with nonstatic bounds::
* Aggregates in assignment statements::

Security Hardening Features

* Register Scrubbing::
* Stack Scrubbing::
* Hardened Conditionals::

Obsolescent Features

* pragma No_Run_Time::
* pragma Ravenscar::
* pragma Restricted_Run_Time::
* pragma Task_Info::
* package System.Task_Info (s-tasinf.ads): package System Task_Info s-tasinf ads.

Compatibility and Porting Guide

* Writing Portable Fixed-Point Declarations::
* Compatibility with Ada 83::
* Compatibility between Ada 95 and Ada 2005::
* Implementation-dependent characteristics::
* Compatibility with Other Ada Systems::
* Representation Clauses::
* Compatibility with HP Ada 83::

Compatibility with Ada 83

* Legal Ada 83 programs that are illegal in Ada 95::
* More deterministic semantics::
* Changed semantics::
* Other language compatibility issues::

Implementation-dependent characteristics

* Implementation-defined pragmas::
* Implementation-defined attributes::
* Libraries::
* Elaboration order::
* Target-specific aspects::



File: gnat_rm.info,  Node: About This Guide,  Next: Implementation Defined Pragmas,  Prev: Top,  Up: Top

1 About This Guide
******************

This manual contains useful information in writing programs using the
GNAT compiler.  It includes information on implementation dependent
characteristics of GNAT, including all the information required by Annex
M of the Ada language standard.

GNAT implements Ada 95, Ada 2005 and Ada 2012, and it may also be
invoked in Ada 83 compatibility mode.  By default, GNAT assumes Ada
2012, but you can override with a compiler switch to explicitly specify
the language version.  (Please refer to the `GNAT User’s Guide' for
details on these switches.)  Throughout this manual, references to ‘Ada’
without a year suffix apply to all the Ada versions of the language.

Ada is designed to be highly portable.  In general, a program will have
the same effect even when compiled by different compilers on different
platforms.  However, since Ada is designed to be used in a wide variety
of applications, it also contains a number of system dependent features
to be used in interfacing to the external world.

Note: Any program that makes use of implementation-dependent features
may be non-portable.  You should follow good programming practice and
isolate and clearly document any sections of your program that make use
of these features in a non-portable manner.

* Menu:

* What This Reference Manual Contains::
* Conventions::
* Related Information::


File: gnat_rm.info,  Node: What This Reference Manual Contains,  Next: Conventions,  Up: About This Guide

1.1 What This Reference Manual Contains
=======================================

This reference manual contains the following chapters:

   * *note Implementation Defined Pragmas: 7, lists GNAT
     implementation-dependent pragmas, which can be used to extend and
     enhance the functionality of the compiler.

   * *note Implementation Defined Attributes: 8, lists GNAT
     implementation-dependent attributes, which can be used to extend
     and enhance the functionality of the compiler.

   * *note Standard and Implementation Defined Restrictions: 9, lists
     GNAT implementation-dependent restrictions, which can be used to
     extend and enhance the functionality of the compiler.

   * *note Implementation Advice: a, provides information on generally
     desirable behavior which are not requirements that all compilers
     must follow since it cannot be provided on all systems, or which
     may be undesirable on some systems.

   * *note Implementation Defined Characteristics: b, provides a guide
     to minimizing implementation dependent features.

   * *note Intrinsic Subprograms: c, describes the intrinsic subprograms
     implemented by GNAT, and how they can be imported into user
     application programs.

   * *note Representation Clauses and Pragmas: d, describes in detail
     the way that GNAT represents data, and in particular the exact set
     of representation clauses and pragmas that is accepted.

   * *note Standard Library Routines: e, provides a listing of packages
     and a brief description of the functionality that is provided by
     Ada’s extensive set of standard library routines as implemented by
     GNAT.

   * *note The Implementation of Standard I/O: f, details how the GNAT
     implementation of the input-output facilities.

   * *note The GNAT Library: 10, is a catalog of packages that
     complement the Ada predefined library.

   * *note Interfacing to Other Languages: 11, describes how programs
     written in Ada using GNAT can be interfaced to other programming
     languages.

   * *note Specialized Needs Annexes: 12, describes the GNAT
     implementation of all of the specialized needs annexes.

   * *note Implementation of Specific Ada Features: 13, discusses issues
     related to GNAT’s implementation of machine code insertions,
     tasking, and several other features.

   * *note Implementation of Ada 2012 Features: 14, describes the status
     of the GNAT implementation of the Ada 2012 language standard.

   * *note Security Hardening Features: 15. documents GNAT extensions
     aimed at security hardening.

   * *note Obsolescent Features: 16. documents implementation dependent
     features, including pragmas and attributes, which are considered
     obsolescent, since there are other preferred ways of achieving the
     same results.  These obsolescent forms are retained for backwards
     compatibility.

   * *note Compatibility and Porting Guide: 17. presents some guidelines
     for developing portable Ada code, describes the compatibility
     issues that may arise between GNAT and other Ada compilation
     systems (including those for Ada 83), and shows how GNAT can
     expedite porting applications developed in other Ada environments.

   * *note GNU Free Documentation License: 1. contains the license for
     this document.

This reference manual assumes a basic familiarity with the Ada 95
language, as described in the ‘International Standard
ANSI/ISO/IEC-8652:1995’.  It does not require knowledge of the new
features introduced by Ada 2005 or Ada 2012.  All three reference
manuals are included in the GNAT documentation package.


File: gnat_rm.info,  Node: Conventions,  Next: Related Information,  Prev: What This Reference Manual Contains,  Up: About This Guide

1.2 Conventions
===============

Following are examples of the typographical and graphic conventions used
in this guide:

   * ‘Functions’, ‘utility program names’, ‘standard names’, and
     ‘classes’.

   * ‘Option flags’

   * ‘File names’

   * ‘Variables’

   * `Emphasis'

   * [optional information or parameters]

   * Examples are described by text

          and then shown this way.

   * Commands that are entered by the user are shown as preceded by a
     prompt string comprising the ‘$’ character followed by a space.


File: gnat_rm.info,  Node: Related Information,  Prev: Conventions,  Up: About This Guide

1.3 Related Information
=======================

See the following documents for further information on GNAT:

   * ‘GNAT User’s Guide for Native Platforms’, which provides
     information on how to use the GNAT development environment.

   * ‘Ada 95 Reference Manual’, the Ada 95 programming language
     standard.

   * ‘Ada 95 Annotated Reference Manual’, which is an annotated version
     of the Ada 95 standard.  The annotations describe detailed aspects
     of the design decision, and in particular contain useful sections
     on Ada 83 compatibility.

   * ‘Ada 2005 Reference Manual’, the Ada 2005 programming language
     standard.

   * ‘Ada 2005 Annotated Reference Manual’, which is an annotated
     version of the Ada 2005 standard.  The annotations describe
     detailed aspects of the design decision.

   * ‘Ada 2012 Reference Manual’, the Ada 2012 programming language
     standard.

   * ‘DEC Ada, Technical Overview and Comparison on DIGITAL Platforms’,
     which contains specific information on compatibility between GNAT
     and DEC Ada 83 systems.

   * ‘DEC Ada, Language Reference Manual’, part number AA-PYZAB-TK,
     which describes in detail the pragmas and attributes provided by
     the DEC Ada 83 compiler system.


File: gnat_rm.info,  Node: Implementation Defined Pragmas,  Next: Implementation Defined Aspects,  Prev: About This Guide,  Up: Top

2 Implementation Defined Pragmas
********************************

Ada defines a set of pragmas that can be used to supply additional
information to the compiler.  These language defined pragmas are
implemented in GNAT and work as described in the Ada Reference Manual.

In addition, Ada allows implementations to define additional pragmas
whose meaning is defined by the implementation.  GNAT provides a number
of these implementation-defined pragmas, which can be used to extend and
enhance the functionality of the compiler.  This section of the GNAT
Reference Manual describes these additional pragmas.

Note that any program using these pragmas might not be portable to other
compilers (although GNAT implements this set of pragmas on all
platforms).  Therefore if portability to other compilers is an important
consideration, the use of these pragmas should be minimized.

* Menu:

* Pragma Abort_Defer::
* Pragma Abstract_State::
* Pragma Ada_83::
* Pragma Ada_95::
* Pragma Ada_05::
* Pragma Ada_2005::
* Pragma Ada_12::
* Pragma Ada_2012::
* Pragma Aggregate_Individually_Assign::
* Pragma Allow_Integer_Address::
* Pragma Annotate::
* Pragma Assert::
* Pragma Assert_And_Cut::
* Pragma Assertion_Policy::
* Pragma Assume::
* Pragma Assume_No_Invalid_Values::
* Pragma Async_Readers::
* Pragma Async_Writers::
* Pragma Attribute_Definition::
* Pragma C_Pass_By_Copy::
* Pragma Check::
* Pragma Check_Float_Overflow::
* Pragma Check_Name::
* Pragma Check_Policy::
* Pragma Comment::
* Pragma Common_Object::
* Pragma Compile_Time_Error::
* Pragma Compile_Time_Warning::
* Pragma Complete_Representation::
* Pragma Complex_Representation::
* Pragma Component_Alignment::
* Pragma Constant_After_Elaboration::
* Pragma Contract_Cases::
* Pragma Convention_Identifier::
* Pragma CPP_Class::
* Pragma CPP_Constructor::
* Pragma CPP_Virtual::
* Pragma CPP_Vtable::
* Pragma CPU::
* Pragma Deadline_Floor::
* Pragma Default_Initial_Condition::
* Pragma Debug::
* Pragma Debug_Policy::
* Pragma Default_Scalar_Storage_Order::
* Pragma Default_Storage_Pool::
* Pragma Depends::
* Pragma Detect_Blocking::
* Pragma Disable_Atomic_Synchronization::
* Pragma Dispatching_Domain::
* Pragma Effective_Reads::
* Pragma Effective_Writes::
* Pragma Elaboration_Checks::
* Pragma Eliminate::
* Pragma Enable_Atomic_Synchronization::
* Pragma Export_Function::
* Pragma Export_Object::
* Pragma Export_Procedure::
* Pragma Export_Valued_Procedure::
* Pragma Extend_System::
* Pragma Extensions_Allowed::
* Pragma Extensions_Visible::
* Pragma External::
* Pragma External_Name_Casing::
* Pragma Fast_Math::
* Pragma Favor_Top_Level::
* Pragma Finalize_Storage_Only::
* Pragma Float_Representation::
* Pragma Ghost::
* Pragma Global::
* Pragma Ident::
* Pragma Ignore_Pragma::
* Pragma Implementation_Defined::
* Pragma Implemented::
* Pragma Implicit_Packing::
* Pragma Import_Function::
* Pragma Import_Object::
* Pragma Import_Procedure::
* Pragma Import_Valued_Procedure::
* Pragma Independent::
* Pragma Independent_Components::
* Pragma Initial_Condition::
* Pragma Initialize_Scalars::
* Pragma Initializes::
* Pragma Inline_Always::
* Pragma Inline_Generic::
* Pragma Interface::
* Pragma Interface_Name::
* Pragma Interrupt_Handler::
* Pragma Interrupt_State::
* Pragma Invariant::
* Pragma Keep_Names::
* Pragma License::
* Pragma Link_With::
* Pragma Linker_Alias::
* Pragma Linker_Constructor::
* Pragma Linker_Destructor::
* Pragma Linker_Section::
* Pragma Lock_Free::
* Pragma Loop_Invariant::
* Pragma Loop_Optimize::
* Pragma Loop_Variant::
* Pragma Machine_Attribute::
* Pragma Main::
* Pragma Main_Storage::
* Pragma Max_Queue_Length::
* Pragma No_Body::
* Pragma No_Caching::
* Pragma No_Component_Reordering::
* Pragma No_Elaboration_Code_All::
* Pragma No_Heap_Finalization::
* Pragma No_Inline::
* Pragma No_Return::
* Pragma No_Strict_Aliasing::
* Pragma No_Tagged_Streams::
* Pragma Normalize_Scalars::
* Pragma Obsolescent::
* Pragma Optimize_Alignment::
* Pragma Ordered::
* Pragma Overflow_Mode::
* Pragma Overriding_Renamings::
* Pragma Partition_Elaboration_Policy::
* Pragma Part_Of::
* Pragma Passive::
* Pragma Persistent_BSS::
* Pragma Post::
* Pragma Postcondition::
* Pragma Post_Class::
* Pragma Pre::
* Pragma Precondition::
* Pragma Predicate::
* Pragma Predicate_Failure::
* Pragma Preelaborable_Initialization::
* Pragma Prefix_Exception_Messages::
* Pragma Pre_Class::
* Pragma Priority_Specific_Dispatching::
* Pragma Profile::
* Pragma Profile_Warnings::
* Pragma Propagate_Exceptions::
* Pragma Provide_Shift_Operators::
* Pragma Psect_Object::
* Pragma Pure_Function::
* Pragma Rational::
* Pragma Ravenscar::
* Pragma Refined_Depends::
* Pragma Refined_Global::
* Pragma Refined_Post::
* Pragma Refined_State::
* Pragma Relative_Deadline::
* Pragma Remote_Access_Type::
* Pragma Rename_Pragma::
* Pragma Restricted_Run_Time::
* Pragma Restriction_Warnings::
* Pragma Reviewable::
* Pragma Secondary_Stack_Size::
* Pragma Share_Generic::
* Pragma Shared::
* Pragma Short_Circuit_And_Or::
* Pragma Short_Descriptors::
* Pragma Simple_Storage_Pool_Type::
* Pragma Source_File_Name::
* Pragma Source_File_Name_Project::
* Pragma Source_Reference::
* Pragma SPARK_Mode::
* Pragma Static_Elaboration_Desired::
* Pragma Stream_Convert::
* Pragma Style_Checks::
* Pragma Subtitle::
* Pragma Suppress::
* Pragma Suppress_All::
* Pragma Suppress_Debug_Info::
* Pragma Suppress_Exception_Locations::
* Pragma Suppress_Initialization::
* Pragma Task_Name::
* Pragma Task_Storage::
* Pragma Test_Case::
* Pragma Thread_Local_Storage::
* Pragma Time_Slice::
* Pragma Title::
* Pragma Type_Invariant::
* Pragma Type_Invariant_Class::
* Pragma Unchecked_Union::
* Pragma Unevaluated_Use_Of_Old::
* Pragma Unimplemented_Unit::
* Pragma Universal_Aliasing::
* Pragma Unmodified::
* Pragma Unreferenced::
* Pragma Unreferenced_Objects::
* Pragma Unreserve_All_Interrupts::
* Pragma Unsuppress::
* Pragma Use_VADS_Size::
* Pragma Unused::
* Pragma Validity_Checks::
* Pragma Volatile::
* Pragma Volatile_Full_Access::
* Pragma Volatile_Function::
* Pragma Warning_As_Error::
* Pragma Warnings::
* Pragma Weak_External::
* Pragma Wide_Character_Encoding::


File: gnat_rm.info,  Node: Pragma Abort_Defer,  Next: Pragma Abstract_State,  Up: Implementation Defined Pragmas

2.1 Pragma Abort_Defer
======================

Syntax:

     pragma Abort_Defer;

This pragma must appear at the start of the statement sequence of a
handled sequence of statements (right after the ‘begin’).  It has the
effect of deferring aborts for the sequence of statements (but not for
the declarations or handlers, if any, associated with this statement
sequence).  This can also be useful for adding a polling point in Ada
code, where asynchronous abort of tasks is checked when leaving the
statement sequence, and is lighter than, for example, using ‘delay
0.0;’, since with zero-cost exception handling, propagating exceptions
(implicitly used to implement task abort) cannot be done reliably in an
asynchronous way.

An example of usage would be:

     --  Add a polling point to check for task aborts

     begin
        pragma Abort_Defer;
     end;


File: gnat_rm.info,  Node: Pragma Abstract_State,  Next: Pragma Ada_83,  Prev: Pragma Abort_Defer,  Up: Implementation Defined Pragmas

2.2 Pragma Abstract_State
=========================

Syntax:

     pragma Abstract_State (ABSTRACT_STATE_LIST);

     ABSTRACT_STATE_LIST ::=
          null
       |  STATE_NAME_WITH_OPTIONS
       | (STATE_NAME_WITH_OPTIONS {, STATE_NAME_WITH_OPTIONS} )

     STATE_NAME_WITH_OPTIONS ::=
          STATE_NAME
       | (STATE_NAME with OPTION_LIST)

     OPTION_LIST ::= OPTION {, OPTION}

     OPTION ::=
         SIMPLE_OPTION
       | NAME_VALUE_OPTION

     SIMPLE_OPTION ::= Ghost | Synchronous

     NAME_VALUE_OPTION ::=
         Part_Of => ABSTRACT_STATE
       | External [=> EXTERNAL_PROPERTY_LIST]

     EXTERNAL_PROPERTY_LIST ::=
          EXTERNAL_PROPERTY
       | (EXTERNAL_PROPERTY {, EXTERNAL_PROPERTY} )

     EXTERNAL_PROPERTY ::=
         Async_Readers    [=> boolean_EXPRESSION]
       | Async_Writers    [=> boolean_EXPRESSION]
       | Effective_Reads  [=> boolean_EXPRESSION]
       | Effective_Writes [=> boolean_EXPRESSION]
         others            => boolean_EXPRESSION

     STATE_NAME ::= defining_identifier

     ABSTRACT_STATE ::= name

For the semantics of this pragma, see the entry for aspect
‘Abstract_State’ in the SPARK 2014 Reference Manual, section 7.1.4.


File: gnat_rm.info,  Node: Pragma Ada_83,  Next: Pragma Ada_95,  Prev: Pragma Abstract_State,  Up: Implementation Defined Pragmas

2.3 Pragma Ada_83
=================

Syntax:

     pragma Ada_83;

A configuration pragma that establishes Ada 83 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  In Ada 83 mode, GNAT attempts to be as compatible with the
syntax and semantics of Ada 83, as defined in the original Ada 83
Reference Manual as possible.  In particular, the keywords added by Ada
95 and Ada 2005 are not recognized, optional package bodies are allowed,
and generics may name types with unknown discriminants without using the
‘(<>)’ notation.  In addition, some but not all of the additional
restrictions of Ada 83 are enforced.

Ada 83 mode is intended for two purposes.  Firstly, it allows existing
Ada 83 code to be compiled and adapted to GNAT with less effort.
Secondly, it aids in keeping code backwards compatible with Ada 83.
However, there is no guarantee that code that is processed correctly by
GNAT in Ada 83 mode will in fact compile and execute with an Ada 83
compiler, since GNAT does not enforce all the additional checks required
by Ada 83.


File: gnat_rm.info,  Node: Pragma Ada_95,  Next: Pragma Ada_05,  Prev: Pragma Ada_83,  Up: Implementation Defined Pragmas

2.4 Pragma Ada_95
=================

Syntax:

     pragma Ada_95;

A configuration pragma that establishes Ada 95 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This mode is set automatically for the ‘Ada’ and ‘System’
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 95 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.


File: gnat_rm.info,  Node: Pragma Ada_05,  Next: Pragma Ada_2005,  Prev: Pragma Ada_95,  Up: Implementation Defined Pragmas

2.5 Pragma Ada_05
=================

Syntax:

     pragma Ada_05;
     pragma Ada_05 (local_NAME);

A configuration pragma that establishes Ada 2005 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This pragma is useful when writing a reusable component that
itself uses Ada 2005 features, but which is intended to be usable from
either Ada 83 or Ada 95 programs.

The one argument form (which is not a configuration pragma) is used for
managing the transition from Ada 95 to Ada 2005 in the run-time library.
If an entity is marked as Ada_2005 only, then referencing the entity in
Ada_83 or Ada_95 mode will generate a warning.  In addition, in Ada_83
or Ada_95 mode, a preference rule is established which does not choose
such an entity unless it is unambiguously specified.  This avoids extra
subprograms marked this way from generating ambiguities in otherwise
legal pre-Ada_2005 programs.  The one argument form is intended for
exclusive use in the GNAT run-time library.


File: gnat_rm.info,  Node: Pragma Ada_2005,  Next: Pragma Ada_12,  Prev: Pragma Ada_05,  Up: Implementation Defined Pragmas

2.6 Pragma Ada_2005
===================

Syntax:

     pragma Ada_2005;

This configuration pragma is a synonym for pragma Ada_05 and has the
same syntax and effect.


File: gnat_rm.info,  Node: Pragma Ada_12,  Next: Pragma Ada_2012,  Prev: Pragma Ada_2005,  Up: Implementation Defined Pragmas

2.7 Pragma Ada_12
=================

Syntax:

     pragma Ada_12;
     pragma Ada_12 (local_NAME);

A configuration pragma that establishes Ada 2012 mode for the unit to
which it applies, regardless of the mode set by the command line
switches.  This mode is set automatically for the ‘Ada’ and ‘System’
packages and their children, so you need not specify it in these
contexts.  This pragma is useful when writing a reusable component that
itself uses Ada 2012 features, but which is intended to be usable from
Ada 83, Ada 95, or Ada 2005 programs.

The one argument form, which is not a configuration pragma, is used for
managing the transition from Ada 2005 to Ada 2012 in the run-time
library.  If an entity is marked as Ada_2012 only, then referencing the
entity in any pre-Ada_2012 mode will generate a warning.  In addition,
in any pre-Ada_2012 mode, a preference rule is established which does
not choose such an entity unless it is unambiguously specified.  This
avoids extra subprograms marked this way from generating ambiguities in
otherwise legal pre-Ada_2012 programs.  The one argument form is
intended for exclusive use in the GNAT run-time library.


File: gnat_rm.info,  Node: Pragma Ada_2012,  Next: Pragma Aggregate_Individually_Assign,  Prev: Pragma Ada_12,  Up: Implementation Defined Pragmas

2.8 Pragma Ada_2012
===================

Syntax:

     pragma Ada_2012;

This configuration pragma is a synonym for pragma Ada_12 and has the
same syntax and effect.


File: gnat_rm.info,  Node: Pragma Aggregate_Individually_Assign,  Next: Pragma Allow_Integer_Address,  Prev: Pragma Ada_2012,  Up: Implementation Defined Pragmas

2.9 Pragma Aggregate_Individually_Assign
========================================

Syntax:

     pragma Aggregate_Individually_Assign;

Where possible, GNAT will store the binary representation of a record
aggregate in memory for space and performance reasons.  This
configuration pragma changes this behavior so that record aggregates are
instead always converted into individual assignment statements.


File: gnat_rm.info,  Node: Pragma Allow_Integer_Address,  Next: Pragma Annotate,  Prev: Pragma Aggregate_Individually_Assign,  Up: Implementation Defined Pragmas

2.10 Pragma Allow_Integer_Address
=================================

Syntax:

     pragma Allow_Integer_Address;

In almost all versions of GNAT, ‘System.Address’ is a private type in
accordance with the implementation advice in the RM. This means that
integer values, in particular integer literals, are not allowed as
address values.  If the configuration pragma ‘Allow_Integer_Address’ is
given, then integer expressions may be used anywhere a value of type
‘System.Address’ is required.  The effect is to introduce an implicit
unchecked conversion from the integer value to type ‘System.Address’.
The reverse case of using an address where an integer type is required
is handled analogously.  The following example compiles without errors:

     pragma Allow_Integer_Address;
     with System; use System;
     package AddrAsInt is
        X : Integer;
        Y : Integer;
        for X'Address use 16#1240#;
        for Y use at 16#3230#;
        m : Address := 16#4000#;
        n : constant Address := 4000;
        p : constant Address := Address (X + Y);
        v : Integer := y'Address;
        w : constant Integer := Integer (Y'Address);
        type R is new integer;
        RR : R := 1000;
        Z : Integer;
        for Z'Address use RR;
     end AddrAsInt;

Note that pragma ‘Allow_Integer_Address’ is ignored if ‘System.Address’
is not a private type.  In implementations of ‘GNAT’ where
System.Address is a visible integer type, this pragma serves no purpose
but is ignored rather than rejected to allow common sets of sources to
be used in the two situations.


File: gnat_rm.info,  Node: Pragma Annotate,  Next: Pragma Assert,  Prev: Pragma Allow_Integer_Address,  Up: Implementation Defined Pragmas

2.11 Pragma Annotate
====================

Syntax:

     pragma Annotate (IDENTIFIER [, IDENTIFIER {, ARG}] [, entity => local_NAME]);

     ARG ::= NAME | EXPRESSION

This pragma is used to annotate programs.  IDENTIFIER identifies the
type of annotation.  GNAT verifies that it is an identifier, but does
not otherwise analyze it.  The second optional identifier is also left
unanalyzed, and by convention is used to control the action of the tool
to which the annotation is addressed.  The remaining ARG arguments can
be either string literals or more generally expressions.  String
literals (and concatenations of string literals) are assumed to be
either of type ‘Standard.String’ or else ‘Wide_String’ or
‘Wide_Wide_String’ depending on the character literals they contain.
All other kinds of arguments are analyzed as expressions, and must be
unambiguous.  The last argument if present must have the identifier
‘Entity’ and GNAT verifies that a local name is given.

The analyzed pragma is retained in the tree, but not otherwise processed
by any part of the GNAT compiler, except to generate corresponding note
lines in the generated ALI file.  For the format of these note lines,
see the compiler source file lib-writ.ads.  This pragma is intended for
use by external tools, including ASIS. The use of pragma Annotate does
not affect the compilation process in any way.  This pragma may be used
as a configuration pragma.


File: gnat_rm.info,  Node: Pragma Assert,  Next: Pragma Assert_And_Cut,  Prev: Pragma Annotate,  Up: Implementation Defined Pragmas

2.12 Pragma Assert
==================

Syntax:

     pragma Assert (
       boolean_EXPRESSION
       [, string_EXPRESSION]);

The effect of this pragma depends on whether the corresponding command
line switch is set to activate assertions.  The pragma expands into code
equivalent to the following:

     if assertions-enabled then
        if not boolean_EXPRESSION then
           System.Assertions.Raise_Assert_Failure
             (string_EXPRESSION);
        end if;
     end if;

The string argument, if given, is the message that will be associated
with the exception occurrence if the exception is raised.  If no second
argument is given, the default message is ‘file’:‘nnn’, where ‘file’ is
the name of the source file containing the assert, and ‘nnn’ is the line
number of the assert.

Note that, as with the ‘if’ statement to which it is equivalent, the
type of the expression is either ‘Standard.Boolean’, or any type derived
from this standard type.

Assert checks can be either checked or ignored.  By default they are
ignored.  They will be checked if either the command line switch
`-gnata' is used, or if an ‘Assertion_Policy’ or ‘Check_Policy’ pragma
is used to enable ‘Assert_Checks’.

If assertions are ignored, then there is no run-time effect (and in
particular, any side effects from the expression will not occur at run
time).  (The expression is still analyzed at compile time, and may cause
types to be frozen if they are mentioned here for the first time).

If assertions are checked, then the given expression is tested, and if
it is ‘False’ then ‘System.Assertions.Raise_Assert_Failure’ is called
which results in the raising of ‘Assert_Failure’ with the given message.

You should generally avoid side effects in the expression arguments of
this pragma, because these side effects will turn on and off with the
setting of the assertions mode, resulting in assertions that have an
effect on the program.  However, the expressions are analyzed for
semantic correctness whether or not assertions are enabled, so turning
assertions on and off cannot affect the legality of a program.

Note that the implementation defined policy ‘DISABLE’, given in a pragma
‘Assertion_Policy’, can be used to suppress this semantic analysis.

Note: this is a standard language-defined pragma in versions of Ada from
2005 on.  In GNAT, it is implemented in all versions of Ada, and the
DISABLE policy is an implementation-defined addition.


File: gnat_rm.info,  Node: Pragma Assert_And_Cut,  Next: Pragma Assertion_Policy,  Prev: Pragma Assert,  Up: Implementation Defined Pragmas

2.13 Pragma Assert_And_Cut
==========================

Syntax:

     pragma Assert_And_Cut (
       boolean_EXPRESSION
       [, string_EXPRESSION]);

The effect of this pragma is identical to that of pragma ‘Assert’,
except that in an ‘Assertion_Policy’ pragma, the identifier
‘Assert_And_Cut’ is used to control whether it is ignored or checked (or
disabled).

The intention is that this be used within a subprogram when the given
test expresion sums up all the work done so far in the subprogram, so
that the rest of the subprogram can be verified (informally or formally)
using only the entry preconditions, and the expression in this pragma.
This allows dividing up a subprogram into sections for the purposes of
testing or formal verification.  The pragma also serves as useful
documentation.


File: gnat_rm.info,  Node: Pragma Assertion_Policy,  Next: Pragma Assume,  Prev: Pragma Assert_And_Cut,  Up: Implementation Defined Pragmas

2.14 Pragma Assertion_Policy
============================

Syntax:

     pragma Assertion_Policy (CHECK | DISABLE | IGNORE | SUPPRESSIBLE);

     pragma Assertion_Policy (
         ASSERTION_KIND => POLICY_IDENTIFIER
      {, ASSERTION_KIND => POLICY_IDENTIFIER});

     ASSERTION_KIND ::= RM_ASSERTION_KIND | ID_ASSERTION_KIND

     RM_ASSERTION_KIND ::= Assert                    |
                           Static_Predicate          |
                           Dynamic_Predicate         |
                           Pre                       |
                           Pre'Class                 |
                           Post                      |
                           Post'Class                |
                           Type_Invariant            |
                           Type_Invariant'Class      |
                           Default_Initial_Condition

     ID_ASSERTION_KIND ::= Assertions           |
                           Assert_And_Cut       |
                           Assume               |
                           Contract_Cases       |
                           Debug                |
                           Ghost                |
                           Initial_Condition    |
                           Invariant            |
                           Invariant'Class      |
                           Loop_Invariant       |
                           Loop_Variant         |
                           Postcondition        |
                           Precondition         |
                           Predicate            |
                           Refined_Post         |
                           Statement_Assertions |
                           Subprogram_Variant

     POLICY_IDENTIFIER ::= Check | Disable | Ignore | Suppressible

This is a standard Ada 2012 pragma that is available as an
implementation-defined pragma in earlier versions of Ada.  The assertion
kinds ‘RM_ASSERTION_KIND’ are those defined in the Ada standard.  The
assertion kinds ‘ID_ASSERTION_KIND’ are implementation defined additions
recognized by the GNAT compiler.

The pragma applies in both cases to pragmas and aspects with matching
names, e.g.  ‘Pre’ applies to the Pre aspect, and ‘Precondition’ applies
to both the ‘Precondition’ pragma and the aspect ‘Precondition’.  Note
that the identifiers for pragmas Pre_Class and Post_Class are Pre’Class
and Post’Class (not Pre_Class and Post_Class), since these pragmas are
intended to be identical to the corresponding aspects).

If the policy is ‘CHECK’, then assertions are enabled, i.e.  the
corresponding pragma or aspect is activated.  If the policy is ‘IGNORE’,
then assertions are ignored, i.e.  the corresponding pragma or aspect is
deactivated.  This pragma overrides the effect of the `-gnata' switch on
the command line.  If the policy is ‘SUPPRESSIBLE’, then assertions are
enabled by default, however, if the `-gnatp' switch is specified all
assertions are ignored.

The implementation defined policy ‘DISABLE’ is like ‘IGNORE’ except that
it completely disables semantic checking of the corresponding pragma or
aspect.  This is useful when the pragma or aspect argument references
subprograms in a with’ed package which is replaced by a dummy package
for the final build.

The implementation defined assertion kind ‘Assertions’ applies to all
assertion kinds.  The form with no assertion kind given implies this
choice, so it applies to all assertion kinds (RM defined, and
implementation defined).

The implementation defined assertion kind ‘Statement_Assertions’ applies
to ‘Assert’, ‘Assert_And_Cut’, ‘Assume’, ‘Loop_Invariant’, and
‘Loop_Variant’.


File: gnat_rm.info,  Node: Pragma Assume,  Next: Pragma Assume_No_Invalid_Values,  Prev: Pragma Assertion_Policy,  Up: Implementation Defined Pragmas

2.15 Pragma Assume
==================

Syntax:

     pragma Assume (
       boolean_EXPRESSION
       [, string_EXPRESSION]);

The effect of this pragma is identical to that of pragma ‘Assert’,
except that in an ‘Assertion_Policy’ pragma, the identifier ‘Assume’ is
used to control whether it is ignored or checked (or disabled).

The intention is that this be used for assumptions about the external
environment.  So you cannot expect to verify formally or informally that
the condition is met, this must be established by examining things
outside the program itself.  For example, we may have code that depends
on the size of ‘Long_Long_Integer’ being at least 64.  So we could
write:

     pragma Assume (Long_Long_Integer'Size >= 64);

This assumption cannot be proved from the program itself, but it acts as
a useful run-time check that the assumption is met, and documents the
need to ensure that it is met by reference to information outside the
program.


File: gnat_rm.info,  Node: Pragma Assume_No_Invalid_Values,  Next: Pragma Async_Readers,  Prev: Pragma Assume,  Up: Implementation Defined Pragmas

2.16 Pragma Assume_No_Invalid_Values
====================================

Syntax:

     pragma Assume_No_Invalid_Values (On | Off);

This is a configuration pragma that controls the assumptions made by the
compiler about the occurrence of invalid representations (invalid
values) in the code.

The default behavior (corresponding to an Off argument for this pragma),
is to assume that values may in general be invalid unless the compiler
can prove they are valid.  Consider the following example:

     V1 : Integer range 1 .. 10;
     V2 : Integer range 11 .. 20;
     ...
     for J in V2 .. V1 loop
        ...
     end loop;

if V1 and V2 have valid values, then the loop is known at compile time
not to execute since the lower bound must be greater than the upper
bound.  However in default mode, no such assumption is made, and the
loop may execute.  If ‘Assume_No_Invalid_Values (On)’ is given, the
compiler will assume that any occurrence of a variable other than in an
explicit ‘'Valid’ test always has a valid value, and the loop above will
be optimized away.

The use of ‘Assume_No_Invalid_Values (On)’ is appropriate if you know
your code is free of uninitialized variables and other possible sources
of invalid representations, and may result in more efficient code.  A
program that accesses an invalid representation with this pragma in
effect is erroneous, so no guarantees can be made about its behavior.

It is peculiar though permissible to use this pragma in conjunction with
validity checking (-gnatVa).  In such cases, accessing invalid values
will generally give an exception, though formally the program is
erroneous so there are no guarantees that this will always be the case,
and it is recommended that these two options not be used together.


File: gnat_rm.info,  Node: Pragma Async_Readers,  Next: Pragma Async_Writers,  Prev: Pragma Assume_No_Invalid_Values,  Up: Implementation Defined Pragmas

2.17 Pragma Async_Readers
=========================

Syntax:

     pragma Async_Readers [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Async_Readers’ in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma Async_Writers,  Next: Pragma Attribute_Definition,  Prev: Pragma Async_Readers,  Up: Implementation Defined Pragmas

2.18 Pragma Async_Writers
=========================

Syntax:

     pragma Async_Writers [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Async_Writers’ in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma Attribute_Definition,  Next: Pragma C_Pass_By_Copy,  Prev: Pragma Async_Writers,  Up: Implementation Defined Pragmas

2.19 Pragma Attribute_Definition
================================

Syntax:

     pragma Attribute_Definition
       ([Attribute  =>] ATTRIBUTE_DESIGNATOR,
        [Entity     =>] LOCAL_NAME,
        [Expression =>] EXPRESSION | NAME);

If ‘Attribute’ is a known attribute name, this pragma is equivalent to
the attribute definition clause:

     for Entity'Attribute use Expression;

If ‘Attribute’ is not a recognized attribute name, the pragma is
ignored, and a warning is emitted.  This allows source code to be
written that takes advantage of some new attribute, while remaining
compilable with earlier compilers.


File: gnat_rm.info,  Node: Pragma C_Pass_By_Copy,  Next: Pragma Check,  Prev: Pragma Attribute_Definition,  Up: Implementation Defined Pragmas

2.20 Pragma C_Pass_By_Copy
==========================

Syntax:

     pragma C_Pass_By_Copy
       ([Max_Size =>] static_integer_EXPRESSION);

Normally the default mechanism for passing C convention records to C
convention subprograms is to pass them by reference, as suggested by RM
B.3(69).  Use the configuration pragma ‘C_Pass_By_Copy’ to change this
default, by requiring that record formal parameters be passed by copy if
all of the following conditions are met:

   * The size of the record type does not exceed the value specified for
     ‘Max_Size’.

   * The record type has ‘Convention C’.

   * The formal parameter has this record type, and the subprogram has a
     foreign (non-Ada) convention.

If these conditions are met the argument is passed by copy; i.e., in a
manner consistent with what C expects if the corresponding formal in the
C prototype is a struct (rather than a pointer to a struct).

You can also pass records by copy by specifying the convention
‘C_Pass_By_Copy’ for the record type, or by using the extended ‘Import’
and ‘Export’ pragmas, which allow specification of passing mechanisms on
a parameter by parameter basis.


File: gnat_rm.info,  Node: Pragma Check,  Next: Pragma Check_Float_Overflow,  Prev: Pragma C_Pass_By_Copy,  Up: Implementation Defined Pragmas

2.21 Pragma Check
=================

Syntax:

     pragma Check (
          [Name    =>] CHECK_KIND,
          [Check   =>] Boolean_EXPRESSION
       [, [Message =>] string_EXPRESSION] );

     CHECK_KIND ::= IDENTIFIER           |
                    Pre'Class            |
                    Post'Class           |
                    Type_Invariant'Class |
                    Invariant'Class

This pragma is similar to the predefined pragma ‘Assert’ except that an
extra identifier argument is present.  In conjunction with pragma
‘Check_Policy’, this can be used to define groups of assertions that can
be independently controlled.  The identifier ‘Assertion’ is special, it
refers to the normal set of pragma ‘Assert’ statements.

Checks introduced by this pragma are normally deactivated by default.
They can be activated either by the command line option `-gnata', which
turns on all checks, or individually controlled using pragma
‘Check_Policy’.

The identifiers ‘Assertions’ and ‘Statement_Assertions’ are not
permitted as check kinds, since this would cause confusion with the use
of these identifiers in ‘Assertion_Policy’ and ‘Check_Policy’ pragmas,
where they are used to refer to sets of assertions.


File: gnat_rm.info,  Node: Pragma Check_Float_Overflow,  Next: Pragma Check_Name,  Prev: Pragma Check,  Up: Implementation Defined Pragmas

2.22 Pragma Check_Float_Overflow
================================

Syntax:

     pragma Check_Float_Overflow;

In Ada, the predefined floating-point types (‘Short_Float’, ‘Float’,
‘Long_Float’, ‘Long_Long_Float’) are defined to be `unconstrained'.
This means that even though each has a well-defined base range, an
operation that delivers a result outside this base range is not required
to raise an exception.  This implementation permission accommodates the
notion of infinities in IEEE floating-point, and corresponds to the
efficient execution mode on most machines.  GNAT will not raise overflow
exceptions on these machines; instead it will generate infinities and
NaN’s as defined in the IEEE standard.

Generating infinities, although efficient, is not always desirable.
Often the preferable approach is to check for overflow, even at the
(perhaps considerable) expense of run-time performance.  This can be
accomplished by defining your own constrained floating-point subtypes –
i.e., by supplying explicit range constraints – and indeed such a
subtype can have the same base range as its base type.  For example:

     subtype My_Float is Float range Float'Range;

Here ‘My_Float’ has the same range as ‘Float’ but is constrained, so
operations on ‘My_Float’ values will be checked for overflow against
this range.

This style will achieve the desired goal, but it is often more
convenient to be able to simply use the standard predefined
floating-point types as long as overflow checking could be guaranteed.
The ‘Check_Float_Overflow’ configuration pragma achieves this effect.
If a unit is compiled subject to this configuration pragma, then all
operations on predefined floating-point types including operations on
base types of these floating-point types will be treated as though those
types were constrained, and overflow checks will be generated.  The
‘Constraint_Error’ exception is raised if the result is out of range.

This mode can also be set by use of the compiler switch `-gnateF'.


File: gnat_rm.info,  Node: Pragma Check_Name,  Next: Pragma Check_Policy,  Prev: Pragma Check_Float_Overflow,  Up: Implementation Defined Pragmas

2.23 Pragma Check_Name
======================

Syntax:

     pragma Check_Name (check_name_IDENTIFIER);

This is a configuration pragma that defines a new implementation defined
check name (unless IDENTIFIER matches one of the predefined check names,
in which case the pragma has no effect).  Check names are global to a
partition, so if two or more configuration pragmas are present in a
partition mentioning the same name, only one new check name is
introduced.

An implementation defined check name introduced with this pragma may be
used in only three contexts: ‘pragma Suppress’, ‘pragma Unsuppress’, and
as the prefix of a ‘Check_Name'Enabled’ attribute reference.  For any of
these three cases, the check name must be visible.  A check name is
visible if it is in the configuration pragmas applying to the current
unit, or if it appears at the start of any unit that is part of the
dependency set of the current unit (e.g., units that are mentioned in
‘with’ clauses).

Check names introduced by this pragma are subject to control by compiler
switches (in particular -gnatp) in the usual manner.


File: gnat_rm.info,  Node: Pragma Check_Policy,  Next: Pragma Comment,  Prev: Pragma Check_Name,  Up: Implementation Defined Pragmas

2.24 Pragma Check_Policy
========================

Syntax:

     pragma Check_Policy
      ([Name   =>] CHECK_KIND,
       [Policy =>] POLICY_IDENTIFIER);

     pragma Check_Policy (
         CHECK_KIND => POLICY_IDENTIFIER
      {, CHECK_KIND => POLICY_IDENTIFIER});

     ASSERTION_KIND ::= RM_ASSERTION_KIND | ID_ASSERTION_KIND

     CHECK_KIND ::= IDENTIFIER           |
                    Pre'Class            |
                    Post'Class           |
                    Type_Invariant'Class |
                    Invariant'Class

     The identifiers Name and Policy are not allowed as CHECK_KIND values. This
     avoids confusion between the two possible syntax forms for this pragma.

     POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE

This pragma is used to set the checking policy for assertions (specified
by aspects or pragmas), the ‘Debug’ pragma, or additional checks to be
checked using the ‘Check’ pragma.  It may appear either as a
configuration pragma, or within a declarative part of package.  In the
latter case, it applies from the point where it appears to the end of
the declarative region (like pragma ‘Suppress’).

The ‘Check_Policy’ pragma is similar to the predefined
‘Assertion_Policy’ pragma, and if the check kind corresponds to one of
the assertion kinds that are allowed by ‘Assertion_Policy’, then the
effect is identical.

If the first argument is Debug, then the policy applies to Debug
pragmas, disabling their effect if the policy is ‘OFF’, ‘DISABLE’, or
‘IGNORE’, and allowing them to execute with normal semantics if the
policy is ‘ON’ or ‘CHECK’.  In addition if the policy is ‘DISABLE’, then
the procedure call in ‘Debug’ pragmas will be totally ignored and not
analyzed semantically.

Finally the first argument may be some other identifier than the above
possibilities, in which case it controls a set of named assertions that
can be checked using pragma ‘Check’.  For example, if the pragma:

     pragma Check_Policy (Critical_Error, OFF);

is given, then subsequent ‘Check’ pragmas whose first argument is also
‘Critical_Error’ will be disabled.

The check policy is ‘OFF’ to turn off corresponding checks, and ‘ON’ to
turn on corresponding checks.  The default for a set of checks for which
no ‘Check_Policy’ is given is ‘OFF’ unless the compiler switch `-gnata'
is given, which turns on all checks by default.

The check policy settings ‘CHECK’ and ‘IGNORE’ are recognized as
synonyms for ‘ON’ and ‘OFF’.  These synonyms are provided for
compatibility with the standard ‘Assertion_Policy’ pragma.  The check
policy setting ‘DISABLE’ causes the second argument of a corresponding
‘Check’ pragma to be completely ignored and not analyzed.


File: gnat_rm.info,  Node: Pragma Comment,  Next: Pragma Common_Object,  Prev: Pragma Check_Policy,  Up: Implementation Defined Pragmas

2.25 Pragma Comment
===================

Syntax:

     pragma Comment (static_string_EXPRESSION);

This is almost identical in effect to pragma ‘Ident’.  It allows the
placement of a comment into the object file and hence into the
executable file if the operating system permits such usage.  The
difference is that ‘Comment’, unlike ‘Ident’, has no limitations on
placement of the pragma (it can be placed anywhere in the main source
unit), and if more than one pragma is used, all comments are retained.


File: gnat_rm.info,  Node: Pragma Common_Object,  Next: Pragma Compile_Time_Error,  Prev: Pragma Comment,  Up: Implementation Defined Pragmas

2.26 Pragma Common_Object
=========================

Syntax:

     pragma Common_Object (
          [Internal =>] LOCAL_NAME
       [, [External =>] EXTERNAL_SYMBOL]
       [, [Size     =>] EXTERNAL_SYMBOL] );

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

This pragma enables the shared use of variables stored in overlaid
linker areas corresponding to the use of ‘COMMON’ in Fortran.  The
single object ‘LOCAL_NAME’ is assigned to the area designated by the
‘External’ argument.  You may define a record to correspond to a series
of fields.  The ‘Size’ argument is syntax checked in GNAT, but otherwise
ignored.

‘Common_Object’ is not supported on all platforms.  If no support is
available, then the code generator will issue a message indicating that
the necessary attribute for implementation of this pragma is not
available.


File: gnat_rm.info,  Node: Pragma Compile_Time_Error,  Next: Pragma Compile_Time_Warning,  Prev: Pragma Common_Object,  Up: Implementation Defined Pragmas

2.27 Pragma Compile_Time_Error
==============================

Syntax:

     pragma Compile_Time_Error
              (boolean_EXPRESSION, static_string_EXPRESSION);

This pragma can be used to generate additional compile time error
messages.  It is particularly useful in generics, where errors can be
issued for specific problematic instantiations.  The first parameter is
a boolean expression.  The pragma ensures that the value of an
expression is known at compile time, and has the value False.  The set
of expressions whose values are known at compile time includes all
static boolean expressions, and also other values which the compiler can
determine at compile time (e.g., the size of a record type set by an
explicit size representation clause, or the value of a variable which
was initialized to a constant and is known not to have been modified).
If these conditions are not met, an error message is generated using the
value given as the second argument.  This string value may contain
embedded ASCII.LF characters to break the message into multiple lines.


File: gnat_rm.info,  Node: Pragma Compile_Time_Warning,  Next: Pragma Complete_Representation,  Prev: Pragma Compile_Time_Error,  Up: Implementation Defined Pragmas

2.28 Pragma Compile_Time_Warning
================================

Syntax:

     pragma Compile_Time_Warning
              (boolean_EXPRESSION, static_string_EXPRESSION);

Same as pragma Compile_Time_Error, except a warning is issued instead of
an error message.  If switch `-gnatw_C' is used, a warning is only
issued if the value of the expression is known to be True at compile
time, not when the value of the expression is not known at compile time.
Note that if this pragma is used in a package that is with’ed by a
client, the client will get the warning even though it is issued by a
with’ed package (normally warnings in with’ed units are suppressed, but
this is a special exception to that rule).

One typical use is within a generic where compile time known
characteristics of formal parameters are tested, and warnings given
appropriately.  Another use with a first parameter of True is to warn a
client about use of a package, for example that it is not fully
implemented.

In previous versions of the compiler, combining `-gnatwe' with
Compile_Time_Warning resulted in a fatal error.  Now the compiler always
emits a warning.  You can use *note Pragma Compile_Time_Error: 3a. to
force the generation of an error.


File: gnat_rm.info,  Node: Pragma Complete_Representation,  Next: Pragma Complex_Representation,  Prev: Pragma Compile_Time_Warning,  Up: Implementation Defined Pragmas

2.29 Pragma Complete_Representation
===================================

Syntax:

     pragma Complete_Representation;

This pragma must appear immediately within a record representation
clause.  Typical placements are before the first component clause or
after the last component clause.  The effect is to give an error message
if any component is missing a component clause.  This pragma may be used
to ensure that a record representation clause is complete, and that this
invariant is maintained if fields are added to the record in the future.


File: gnat_rm.info,  Node: Pragma Complex_Representation,  Next: Pragma Component_Alignment,  Prev: Pragma Complete_Representation,  Up: Implementation Defined Pragmas

2.30 Pragma Complex_Representation
==================================

Syntax:

     pragma Complex_Representation
             ([Entity =>] LOCAL_NAME);

The ‘Entity’ argument must be the name of a record type which has two
fields of the same floating-point type.  The effect of this pragma is to
force gcc to use the special internal complex representation form for
this record, which may be more efficient.  Note that this may result in
the code for this type not conforming to standard ABI (application
binary interface) requirements for the handling of record types.  For
example, in some environments, there is a requirement for passing
records by pointer, and the use of this pragma may result in passing
this type in floating-point registers.


File: gnat_rm.info,  Node: Pragma Component_Alignment,  Next: Pragma Constant_After_Elaboration,  Prev: Pragma Complex_Representation,  Up: Implementation Defined Pragmas

2.31 Pragma Component_Alignment
===============================

Syntax:

     pragma Component_Alignment (
          [Form =>] ALIGNMENT_CHOICE
       [, [Name =>] type_LOCAL_NAME]);

     ALIGNMENT_CHOICE ::=
       Component_Size
     | Component_Size_4
     | Storage_Unit
     | Default

Specifies the alignment of components in array or record types.  The
meaning of the ‘Form’ argument is as follows:

`Component_Size'

     Aligns scalar components and subcomponents of the array or record
     type on boundaries appropriate to their inherent size (naturally
     aligned).  For example, 1-byte components are aligned on byte
     boundaries, 2-byte integer components are aligned on 2-byte
     boundaries, 4-byte integer components are aligned on 4-byte
     boundaries and so on.  These alignment rules correspond to the
     normal rules for C compilers on all machines except the VAX.

`Component_Size_4'

     Naturally aligns components with a size of four or fewer bytes.
     Components that are larger than 4 bytes are placed on the next
     4-byte boundary.

`Storage_Unit'

     Specifies that array or record components are byte aligned, i.e.,
     aligned on boundaries determined by the value of the constant
     ‘System.Storage_Unit’.

`Default'

     Specifies that array or record components are aligned on default
     boundaries, appropriate to the underlying hardware or operating
     system or both.  The ‘Default’ choice is the same as
     ‘Component_Size’ (natural alignment).

If the ‘Name’ parameter is present, ‘type_LOCAL_NAME’ must refer to a
local record or array type, and the specified alignment choice applies
to the specified type.  The use of ‘Component_Alignment’ together with a
pragma ‘Pack’ causes the ‘Component_Alignment’ pragma to be ignored.
The use of ‘Component_Alignment’ together with a record representation
clause is only effective for fields not specified by the representation
clause.

If the ‘Name’ parameter is absent, the pragma can be used as either a
configuration pragma, in which case it applies to one or more units in
accordance with the normal rules for configuration pragmas, or it can be
used within a declarative part, in which case it applies to types that
are declared within this declarative part, or within any nested scope
within this declarative part.  In either case it specifies the alignment
to be applied to any record or array type which has otherwise standard
representation.

If the alignment for a record or array type is not specified (using
pragma ‘Pack’, pragma ‘Component_Alignment’, or a record rep clause),
the GNAT uses the default alignment as described previously.


File: gnat_rm.info,  Node: Pragma Constant_After_Elaboration,  Next: Pragma Contract_Cases,  Prev: Pragma Component_Alignment,  Up: Implementation Defined Pragmas

2.32 Pragma Constant_After_Elaboration
======================================

Syntax:

     pragma Constant_After_Elaboration [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Constant_After_Elaboration’ in the SPARK 2014 Reference Manual, section
3.3.1.


File: gnat_rm.info,  Node: Pragma Contract_Cases,  Next: Pragma Convention_Identifier,  Prev: Pragma Constant_After_Elaboration,  Up: Implementation Defined Pragmas

2.33 Pragma Contract_Cases
==========================

Syntax:

     pragma Contract_Cases ((CONTRACT_CASE {, CONTRACT_CASE));

     CONTRACT_CASE ::= CASE_GUARD => CONSEQUENCE

     CASE_GUARD ::= boolean_EXPRESSION | others

     CONSEQUENCE ::= boolean_EXPRESSION

The ‘Contract_Cases’ pragma allows defining fine-grain specifications
that can complement or replace the contract given by a precondition and
a postcondition.  Additionally, the ‘Contract_Cases’ pragma can be used
by testing and formal verification tools.  The compiler checks its
validity and, depending on the assertion policy at the point of
declaration of the pragma, it may insert a check in the executable.  For
code generation, the contract cases

     pragma Contract_Cases (
       Cond1 => Pred1,
       Cond2 => Pred2);

are equivalent to

     C1 : constant Boolean := Cond1;  --  evaluated at subprogram entry
     C2 : constant Boolean := Cond2;  --  evaluated at subprogram entry
     pragma Precondition ((C1 and not C2) or (C2 and not C1));
     pragma Postcondition (if C1 then Pred1);
     pragma Postcondition (if C2 then Pred2);

The precondition ensures that one and only one of the case guards is
satisfied on entry to the subprogram.  The postcondition ensures that
for the case guard that was True on entry, the corresponding consequence
is True on exit.  Other consequence expressions are not evaluated.

A precondition ‘P’ and postcondition ‘Q’ can also be expressed as
contract cases:

     pragma Contract_Cases (P => Q);

The placement and visibility rules for ‘Contract_Cases’ pragmas are
identical to those described for preconditions and postconditions.

The compiler checks that boolean expressions given in case guards and
consequences are valid, where the rules for case guards are the same as
the rule for an expression in ‘Precondition’ and the rules for
consequences are the same as the rule for an expression in
‘Postcondition’.  In particular, attributes ‘'Old’ and ‘'Result’ can
only be used within consequence expressions.  The case guard for the
last contract case may be ‘others’, to denote any case not captured by
the previous cases.  The following is an example of use within a package
spec:

     package Math_Functions is
        ...
        function Sqrt (Arg : Float) return Float;
        pragma Contract_Cases (((Arg in 0.0 .. 99.0) => Sqrt'Result < 10.0,
                                Arg >= 100.0         => Sqrt'Result >= 10.0,
                                others               => Sqrt'Result = 0.0));
        ...
     end Math_Functions;

The meaning of contract cases is that only one case should apply at each
call, as determined by the corresponding case guard evaluating to True,
and that the consequence for this case should hold when the subprogram
returns.


File: gnat_rm.info,  Node: Pragma Convention_Identifier,  Next: Pragma CPP_Class,  Prev: Pragma Contract_Cases,  Up: Implementation Defined Pragmas

2.34 Pragma Convention_Identifier
=================================

Syntax:

     pragma Convention_Identifier (
              [Name =>]       IDENTIFIER,
              [Convention =>] convention_IDENTIFIER);

This pragma provides a mechanism for supplying synonyms for existing
convention identifiers.  The ‘Name’ identifier can subsequently be used
as a synonym for the given convention in other pragmas (including for
example pragma ‘Import’ or another ‘Convention_Identifier’ pragma).  As
an example of the use of this, suppose you had legacy code which used
Fortran77 as the identifier for Fortran.  Then the pragma:

     pragma Convention_Identifier (Fortran77, Fortran);

would allow the use of the convention identifier ‘Fortran77’ in
subsequent code, avoiding the need to modify the sources.  As another
example, you could use this to parameterize convention requirements
according to systems.  Suppose you needed to use ‘Stdcall’ on windows
systems, and ‘C’ on some other system, then you could define a
convention identifier ‘Library’ and use a single ‘Convention_Identifier’
pragma to specify which convention would be used system-wide.


File: gnat_rm.info,  Node: Pragma CPP_Class,  Next: Pragma CPP_Constructor,  Prev: Pragma Convention_Identifier,  Up: Implementation Defined Pragmas

2.35 Pragma CPP_Class
=====================

Syntax:

     pragma CPP_Class ([Entity =>] LOCAL_NAME);

The argument denotes an entity in the current declarative region that is
declared as a record type.  It indicates that the type corresponds to an
externally declared C++ class type, and is to be laid out the same way
that C++ would lay out the type.  If the C++ class has virtual
primitives then the record must be declared as a tagged record type.

Types for which ‘CPP_Class’ is specified do not have assignment or
equality operators defined (such operations can be imported or declared
as subprograms as required).  Initialization is allowed only by
constructor functions (see pragma ‘CPP_Constructor’).  Such types are
implicitly limited if not explicitly declared as limited or derived from
a limited type, and an error is issued in that case.

See *note Interfacing to C++: 46. for related information.

Note: Pragma ‘CPP_Class’ is currently obsolete.  It is supported for
backward compatibility but its functionality is available using pragma
‘Import’ with ‘Convention’ = ‘CPP’.


File: gnat_rm.info,  Node: Pragma CPP_Constructor,  Next: Pragma CPP_Virtual,  Prev: Pragma CPP_Class,  Up: Implementation Defined Pragmas

2.36 Pragma CPP_Constructor
===========================

Syntax:

     pragma CPP_Constructor ([Entity =>] LOCAL_NAME
       [, [External_Name =>] static_string_EXPRESSION ]
       [, [Link_Name     =>] static_string_EXPRESSION ]);

This pragma identifies an imported function (imported in the usual way
with pragma ‘Import’) as corresponding to a C++ constructor.  If
‘External_Name’ and ‘Link_Name’ are not specified then the ‘Entity’
argument is a name that must have been previously mentioned in a pragma
‘Import’ with ‘Convention’ = ‘CPP’.  Such name must be of one of the
following forms:

   * `function' ‘Fname’ `return' T‘

   * `function' ‘Fname’ `return' T’Class

   * `function' ‘Fname’ (…) `return' T‘

   * `function' ‘Fname’ (…) `return' T’Class

where ‘T’ is a limited record type imported from C++ with pragma
‘Import’ and ‘Convention’ = ‘CPP’.

The first two forms import the default constructor, used when an object
of type ‘T’ is created on the Ada side with no explicit constructor.
The latter two forms cover all the non-default constructors of the type.
See the GNAT User’s Guide for details.

If no constructors are imported, it is impossible to create any objects
on the Ada side and the type is implicitly declared abstract.

Pragma ‘CPP_Constructor’ is intended primarily for automatic generation
using an automatic binding generator tool (such as the ‘-fdump-ada-spec’
GCC switch).  See *note Interfacing to C++: 46. for more related
information.

Note: The use of functions returning class-wide types for constructors
is currently obsolete.  They are supported for backward compatibility.
The use of functions returning the type T leave the Ada sources more
clear because the imported C++ constructors always return an object of
type T; that is, they never return an object whose type is a descendant
of type T.


File: gnat_rm.info,  Node: Pragma CPP_Virtual,  Next: Pragma CPP_Vtable,  Prev: Pragma CPP_Constructor,  Up: Implementation Defined Pragmas

2.37 Pragma CPP_Virtual
=======================

This pragma is now obsolete and, other than generating a warning if
warnings on obsolescent features are enabled, is completely ignored.  It
is retained for compatibility purposes.  It used to be required to
ensure compoatibility with C++, but is no longer required for that
purpose because GNAT generates the same object layout as the G++
compiler by default.

See *note Interfacing to C++: 46. for related information.


File: gnat_rm.info,  Node: Pragma CPP_Vtable,  Next: Pragma CPU,  Prev: Pragma CPP_Virtual,  Up: Implementation Defined Pragmas

2.38 Pragma CPP_Vtable
======================

This pragma is now obsolete and, other than generating a warning if
warnings on obsolescent features are enabled, is completely ignored.  It
used to be required to ensure compatibility with C++, but is no longer
required for that purpose because GNAT generates the same object layout
as the G++ compiler by default.

See *note Interfacing to C++: 46. for related information.


File: gnat_rm.info,  Node: Pragma CPU,  Next: Pragma Deadline_Floor,  Prev: Pragma CPP_Vtable,  Up: Implementation Defined Pragmas

2.39 Pragma CPU
===============

Syntax:

     pragma CPU (EXPRESSION);

This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Deadline_Floor,  Next: Pragma Default_Initial_Condition,  Prev: Pragma CPU,  Up: Implementation Defined Pragmas

2.40 Pragma Deadline_Floor
==========================

Syntax:

     pragma Deadline_Floor (time_span_EXPRESSION);

This pragma applies only to protected types and specifies the floor
deadline inherited by a task when the task enters a protected object.
It is effective only when the EDF scheduling policy is used.


File: gnat_rm.info,  Node: Pragma Default_Initial_Condition,  Next: Pragma Debug,  Prev: Pragma Deadline_Floor,  Up: Implementation Defined Pragmas

2.41 Pragma Default_Initial_Condition
=====================================

Syntax:

     pragma Default_Initial_Condition [ (null | boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Default_Initial_Condition’ in the SPARK 2014 Reference Manual, section
7.3.3.


File: gnat_rm.info,  Node: Pragma Debug,  Next: Pragma Debug_Policy,  Prev: Pragma Default_Initial_Condition,  Up: Implementation Defined Pragmas

2.42 Pragma Debug
=================

Syntax:

     pragma Debug ([CONDITION, ]PROCEDURE_CALL_WITHOUT_SEMICOLON);

     PROCEDURE_CALL_WITHOUT_SEMICOLON ::=
       PROCEDURE_NAME
     | PROCEDURE_PREFIX ACTUAL_PARAMETER_PART

The procedure call argument has the syntactic form of an expression,
meeting the syntactic requirements for pragmas.

If debug pragmas are not enabled or if the condition is present and
evaluates to False, this pragma has no effect.  If debug pragmas are
enabled, the semantics of the pragma is exactly equivalent to the
procedure call statement corresponding to the argument with a
terminating semicolon.  Pragmas are permitted in sequences of
declarations, so you can use pragma ‘Debug’ to intersperse calls to
debug procedures in the middle of declarations.  Debug pragmas can be
enabled either by use of the command line switch `-gnata' or by use of
the pragma ‘Check_Policy’ with a first argument of ‘Debug’.


File: gnat_rm.info,  Node: Pragma Debug_Policy,  Next: Pragma Default_Scalar_Storage_Order,  Prev: Pragma Debug,  Up: Implementation Defined Pragmas

2.43 Pragma Debug_Policy
========================

Syntax:

     pragma Debug_Policy (CHECK | DISABLE | IGNORE | ON | OFF);

This pragma is equivalent to a corresponding ‘Check_Policy’ pragma with
a first argument of ‘Debug’.  It is retained for historical
compatibility reasons.


File: gnat_rm.info,  Node: Pragma Default_Scalar_Storage_Order,  Next: Pragma Default_Storage_Pool,  Prev: Pragma Debug_Policy,  Up: Implementation Defined Pragmas

2.44 Pragma Default_Scalar_Storage_Order
========================================

Syntax:

     pragma Default_Scalar_Storage_Order (High_Order_First | Low_Order_First);

Normally if no explicit ‘Scalar_Storage_Order’ is given for a record
type or array type, then the scalar storage order defaults to the
ordinary default for the target.  But this default may be overridden
using this pragma.  The pragma may appear as a configuration pragma, or
locally within a package spec or declarative part.  In the latter case,
it applies to all subsequent types declared within that package spec or
declarative part.

The following example shows the use of this pragma:

     pragma Default_Scalar_Storage_Order (High_Order_First);
     with System; use System;
     package DSSO1 is
        type H1 is record
           a : Integer;
        end record;

        type L2 is record
           a : Integer;
        end record;
        for L2'Scalar_Storage_Order use Low_Order_First;

        type L2a is new L2;

        package Inner is
           type H3 is record
              a : Integer;
           end record;

           pragma Default_Scalar_Storage_Order (Low_Order_First);

           type L4 is record
              a : Integer;
           end record;
        end Inner;

        type H4a is new Inner.L4;

        type H5 is record
           a : Integer;
        end record;
     end DSSO1;

In this example record types with names starting with `L' have
‘Low_Order_First’ scalar storage order, and record types with names
starting with `H' have ‘High_Order_First’.  Note that in the case of
‘H4a’, the order is not inherited from the parent type.  Only an
explicitly set ‘Scalar_Storage_Order’ gets inherited on type derivation.

If this pragma is used as a configuration pragma which appears within a
configuration pragma file (as opposed to appearing explicitly at the
start of a single unit), then the binder will require that all units in
a partition be compiled in a similar manner, other than run-time units,
which are not affected by this pragma.  Note that the use of this form
is discouraged because it may significantly degrade the run-time
performance of the software, instead the default scalar storage order
ought to be changed only on a local basis.


File: gnat_rm.info,  Node: Pragma Default_Storage_Pool,  Next: Pragma Depends,  Prev: Pragma Default_Scalar_Storage_Order,  Up: Implementation Defined Pragmas

2.45 Pragma Default_Storage_Pool
================================

Syntax:

     pragma Default_Storage_Pool (storage_pool_NAME | null);

This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Depends,  Next: Pragma Detect_Blocking,  Prev: Pragma Default_Storage_Pool,  Up: Implementation Defined Pragmas

2.46 Pragma Depends
===================

Syntax:

     pragma Depends (DEPENDENCY_RELATION);

     DEPENDENCY_RELATION ::=
          null
       | (DEPENDENCY_CLAUSE {, DEPENDENCY_CLAUSE})

     DEPENDENCY_CLAUSE ::=
         OUTPUT_LIST =>[+] INPUT_LIST
       | NULL_DEPENDENCY_CLAUSE

     NULL_DEPENDENCY_CLAUSE ::= null => INPUT_LIST

     OUTPUT_LIST ::= OUTPUT | (OUTPUT {, OUTPUT})

     INPUT_LIST ::= null | INPUT | (INPUT {, INPUT})

     OUTPUT ::= NAME | FUNCTION_RESULT
     INPUT  ::= NAME

     where FUNCTION_RESULT is a function Result attribute_reference

For the semantics of this pragma, see the entry for aspect ‘Depends’ in
the SPARK 2014 Reference Manual, section 6.1.5.


File: gnat_rm.info,  Node: Pragma Detect_Blocking,  Next: Pragma Disable_Atomic_Synchronization,  Prev: Pragma Depends,  Up: Implementation Defined Pragmas

2.47 Pragma Detect_Blocking
===========================

Syntax:

     pragma Detect_Blocking;

This is a standard pragma in Ada 2005, that is available in all earlier
versions of Ada as an implementation-defined pragma.

This is a configuration pragma that forces the detection of potentially
blocking operations within a protected operation, and to raise
Program_Error if that happens.


File: gnat_rm.info,  Node: Pragma Disable_Atomic_Synchronization,  Next: Pragma Dispatching_Domain,  Prev: Pragma Detect_Blocking,  Up: Implementation Defined Pragmas

2.48 Pragma Disable_Atomic_Synchronization
==========================================

Syntax:

     pragma Disable_Atomic_Synchronization [(Entity)];

Ada requires that accesses (reads or writes) of an atomic variable be
regarded as synchronization points in the case of multiple tasks.
Particularly in the case of multi-processors this may require special
handling, e.g.  the generation of memory barriers.  This capability may
be turned off using this pragma in cases where it is known not to be
required.

The placement and scope rules for this pragma are the same as those for
‘pragma Suppress’.  In particular it can be used as a configuration
pragma, or in a declaration sequence where it applies till the end of
the scope.  If an ‘Entity’ argument is present, the action applies only
to that entity.


File: gnat_rm.info,  Node: Pragma Dispatching_Domain,  Next: Pragma Effective_Reads,  Prev: Pragma Disable_Atomic_Synchronization,  Up: Implementation Defined Pragmas

2.49 Pragma Dispatching_Domain
==============================

Syntax:

     pragma Dispatching_Domain (EXPRESSION);

This pragma is standard in Ada 2012, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Effective_Reads,  Next: Pragma Effective_Writes,  Prev: Pragma Dispatching_Domain,  Up: Implementation Defined Pragmas

2.50 Pragma Effective_Reads
===========================

Syntax:

     pragma Effective_Reads [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Effective_Reads’ in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma Effective_Writes,  Next: Pragma Elaboration_Checks,  Prev: Pragma Effective_Reads,  Up: Implementation Defined Pragmas

2.51 Pragma Effective_Writes
============================

Syntax:

     pragma Effective_Writes [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Effective_Writes’ in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma Elaboration_Checks,  Next: Pragma Eliminate,  Prev: Pragma Effective_Writes,  Up: Implementation Defined Pragmas

2.52 Pragma Elaboration_Checks
==============================

Syntax:

     pragma Elaboration_Checks (Dynamic | Static);

This is a configuration pragma which specifies the elaboration model to
be used during compilation.  For more information on the elaboration
models of GNAT, consult the chapter on elaboration order handling in the
`GNAT User’s Guide'.

The pragma may appear in the following contexts:

   * Configuration pragmas file

   * Prior to the context clauses of a compilation unit’s initial
     declaration

Any other placement of the pragma will result in a warning and the
effects of the offending pragma will be ignored.

If the pragma argument is ‘Dynamic’, then the dynamic elaboration model
is in effect.  If the pragma argument is ‘Static’, then the static
elaboration model is in effect.


File: gnat_rm.info,  Node: Pragma Eliminate,  Next: Pragma Enable_Atomic_Synchronization,  Prev: Pragma Elaboration_Checks,  Up: Implementation Defined Pragmas

2.53 Pragma Eliminate
=====================

Syntax:

     pragma Eliminate (
                 [  Unit_Name       => ] IDENTIFIER | SELECTED_COMPONENT ,
                 [  Entity          => ] IDENTIFIER |
                                         SELECTED_COMPONENT |
                                         STRING_LITERAL
                 [, Source_Location =>   SOURCE_TRACE ] );

             SOURCE_TRACE    ::= STRING_LITERAL

This pragma indicates that the given entity is not used in the program
to be compiled and built, thus allowing the compiler to eliminate the
code or data associated with the named entity.  Any reference to an
eliminated entity causes a compile-time or link-time error.

The pragma has the following semantics, where ‘U’ is the unit specified
by the ‘Unit_Name’ argument and ‘E’ is the entity specified by the
‘Entity’ argument:

   * ‘E’ must be a subprogram that is explicitly declared either:

     o Within ‘U’, or

     o Within a generic package that is instantiated in ‘U’, or

     o As an instance of generic subprogram instantiated in ‘U’.

     Otherwise the pragma is ignored.

   * If ‘E’ is overloaded within ‘U’ then, in the absence of a
     ‘Source_Location’ argument, all overloadings are eliminated.

   * If ‘E’ is overloaded within ‘U’ and only some overloadings are to
     be eliminated, then each overloading to be eliminated must be
     specified in a corresponding pragma ‘Eliminate’ with a
     ‘Source_Location’ argument identifying the line where the
     declaration appears, as described below.

   * If ‘E’ is declared as the result of a generic instantiation, then a
     ‘Source_Location’ argument is needed, as described below

Pragma ‘Eliminate’ allows a program to be compiled in a
system-independent manner, so that unused entities are eliminated but
without needing to modify the source text.  Normally the required set of
‘Eliminate’ pragmas is constructed automatically using the ‘gnatelim’
tool.

Any source file change that removes, splits, or adds lines may make the
set of ‘Eliminate’ pragmas invalid because their ‘Source_Location’
argument values may get out of date.

Pragma ‘Eliminate’ may be used where the referenced entity is a
dispatching operation.  In this case all the subprograms to which the
given operation can dispatch are considered to be unused (are never
called as a result of a direct or a dispatching call).

The string literal given for the source location specifies the line
number of the declaration of the entity, using the following syntax for
‘SOURCE_TRACE’:

     SOURCE_TRACE     ::= SOURCE_REFERENCE [ LBRACKET SOURCE_TRACE RBRACKET ]

     LBRACKET         ::= '['
     RBRACKET         ::= ']'

     SOURCE_REFERENCE ::= FILE_NAME : LINE_NUMBER

     LINE_NUMBER      ::= DIGIT {DIGIT}

Spaces around the colon in a ‘SOURCE_REFERENCE’ are optional.

The source trace that is given as the ‘Source_Location’ must obey the
following rules (or else the pragma is ignored), where ‘U’ is the unit
‘U’ specified by the ‘Unit_Name’ argument and ‘E’ is the subprogram
specified by the ‘Entity’ argument:

   * ‘FILE_NAME’ is the short name (with no directory information) of
     the Ada source file for ‘U’, using the required syntax for the
     underlying file system (e.g.  case is significant if the underlying
     operating system is case sensitive).  If ‘U’ is a package and ‘E’
     is a subprogram declared in the package specification and its full
     declaration appears in the package body, then the relevant source
     file is the one for the package specification; analogously if ‘U’
     is a generic package.

   * If ‘E’ is not declared in a generic instantiation (this includes
     generic subprogram instances), the source trace includes only one
     source line reference.  ‘LINE_NUMBER’ gives the line number of the
     occurrence of the declaration of ‘E’ within the source file (as a
     decimal literal without an exponent or point).

   * If ‘E’ is declared by a generic instantiation, its source trace
     (from left to right) starts with the source location of the
     declaration of ‘E’ in the generic unit and ends with the source
     location of the instantiation, given in square brackets.  This
     approach is applied recursively with nested instantiations: the
     rightmost (nested most deeply in square brackets) element of the
     source trace is the location of the outermost instantiation, and
     the leftmost element (that is, outside of any square brackets) is
     the location of the declaration of ‘E’ in the generic unit.

Examples:

          pragma Eliminate (Pkg0, Proc);
          -- Eliminate (all overloadings of) Proc in Pkg0

          pragma Eliminate (Pkg1, Proc,
                            Source_Location => "pkg1.ads:8");
          -- Eliminate overloading of Proc at line 8 in pkg1.ads

          -- Assume the following file contents:
          --   gen_pkg.ads
          --   1: generic
          --   2:   type T is private;
          --   3: package Gen_Pkg is
          --   4:   procedure Proc(N : T);
          --  ...   ...
          --  ... end Gen_Pkg;
          --
          --    q.adb
          --   1: with Gen_Pkg;
          --   2: procedure Q is
          --   3:   package Inst_Pkg is new Gen_Pkg(Integer);
          --  ...   -- No calls on Inst_Pkg.Proc
          --  ... end Q;

          -- The following pragma eliminates Inst_Pkg.Proc from Q
          pragma Eliminate (Q, Proc,
                            Source_Location => "gen_pkg.ads:4[q.adb:3]");


File: gnat_rm.info,  Node: Pragma Enable_Atomic_Synchronization,  Next: Pragma Export_Function,  Prev: Pragma Eliminate,  Up: Implementation Defined Pragmas

2.54 Pragma Enable_Atomic_Synchronization
=========================================

Syntax:

     pragma Enable_Atomic_Synchronization [(Entity)];

Ada requires that accesses (reads or writes) of an atomic variable be
regarded as synchronization points in the case of multiple tasks.
Particularly in the case of multi-processors this may require special
handling, e.g.  the generation of memory barriers.  This synchronization
is performed by default, but can be turned off using ‘pragma
Disable_Atomic_Synchronization’.  The ‘Enable_Atomic_Synchronization’
pragma can be used to turn it back on.

The placement and scope rules for this pragma are the same as those for
‘pragma Unsuppress’.  In particular it can be used as a configuration
pragma, or in a declaration sequence where it applies till the end of
the scope.  If an ‘Entity’ argument is present, the action applies only
to that entity.


File: gnat_rm.info,  Node: Pragma Export_Function,  Next: Pragma Export_Object,  Prev: Pragma Enable_Atomic_Synchronization,  Up: Implementation Defined Pragmas

2.55 Pragma Export_Function
===========================

Syntax:

     pragma Export_Function (
          [Internal         =>] LOCAL_NAME
       [, [External         =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types  =>] PARAMETER_TYPES]
       [, [Result_Type      =>] result_SUBTYPE_MARK]
       [, [Mechanism        =>] MECHANISM]
       [, [Result_Mechanism =>] MECHANISM_NAME]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION
     | ""

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::= Value | Reference

Use this pragma to make a function externally callable and optionally
provide information on mechanisms to be used for passing parameter and
result values.  We recommend, for the purposes of improving portability,
this pragma always be used in conjunction with a separate pragma
‘Export’, which must precede the pragma ‘Export_Function’.  GNAT does
not require a separate pragma ‘Export’, but if none is present,
‘Convention Ada’ is assumed, which is usually not what is wanted, so it
is usually appropriate to use this pragma in conjunction with a ‘Export’
or ‘Convention’ pragma that specifies the desired foreign convention.
Pragma ‘Export_Function’ (and ‘Export’, if present) must appear in the
same declarative region as the function to which they apply.

The ‘internal_name’ must uniquely designate the function to which the
pragma applies.  If more than one function name exists of this name in
the declarative part you must use the ‘Parameter_Types’ and
‘Result_Type’ parameters to achieve the required unique designation.
The ‘subtype_mark’s in these parameters must exactly match the subtypes
in the corresponding function specification, using positional notation
to match parameters with subtype marks.  The form with an ‘'Access’
attribute can be used to match an anonymous access parameter.

Special treatment is given if the EXTERNAL is an explicit null string or
a static string expressions that evaluates to the null string.  In this
case, no external name is generated.  This form still allows the
specification of parameter mechanisms.


File: gnat_rm.info,  Node: Pragma Export_Object,  Next: Pragma Export_Procedure,  Prev: Pragma Export_Function,  Up: Implementation Defined Pragmas

2.56 Pragma Export_Object
=========================

Syntax:

     pragma Export_Object
           [Internal =>] LOCAL_NAME
        [, [External =>] EXTERNAL_SYMBOL]
        [, [Size     =>] EXTERNAL_SYMBOL]

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

This pragma designates an object as exported, and apart from the
extended rules for external symbols, is identical in effect to the use
of the normal ‘Export’ pragma applied to an object.  You may use a
separate Export pragma (and you probably should from the point of view
of portability), but it is not required.  ‘Size’ is syntax checked, but
otherwise ignored by GNAT.


File: gnat_rm.info,  Node: Pragma Export_Procedure,  Next: Pragma Export_Valued_Procedure,  Prev: Pragma Export_Object,  Up: Implementation Defined Pragmas

2.57 Pragma Export_Procedure
============================

Syntax:

     pragma Export_Procedure (
          [Internal        =>] LOCAL_NAME
       [, [External        =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types =>] PARAMETER_TYPES]
       [, [Mechanism       =>] MECHANISM]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION
     | ""

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::= Value | Reference

This pragma is identical to ‘Export_Function’ except that it applies to
a procedure rather than a function and the parameters ‘Result_Type’ and
‘Result_Mechanism’ are not permitted.  GNAT does not require a separate
pragma ‘Export’, but if none is present, ‘Convention Ada’ is assumed,
which is usually not what is wanted, so it is usually appropriate to use
this pragma in conjunction with a ‘Export’ or ‘Convention’ pragma that
specifies the desired foreign convention.

Special treatment is given if the EXTERNAL is an explicit null string or
a static string expressions that evaluates to the null string.  In this
case, no external name is generated.  This form still allows the
specification of parameter mechanisms.


File: gnat_rm.info,  Node: Pragma Export_Valued_Procedure,  Next: Pragma Extend_System,  Prev: Pragma Export_Procedure,  Up: Implementation Defined Pragmas

2.58 Pragma Export_Valued_Procedure
===================================

Syntax:

     pragma Export_Valued_Procedure (
          [Internal        =>] LOCAL_NAME
       [, [External        =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types =>] PARAMETER_TYPES]
       [, [Mechanism       =>] MECHANISM]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION
     | ""

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::= Value | Reference

This pragma is identical to ‘Export_Procedure’ except that the first
parameter of ‘LOCAL_NAME’, which must be present, must be of mode ‘out’,
and externally the subprogram is treated as a function with this
parameter as the result of the function.  GNAT provides for this
capability to allow the use of ‘out’ and ‘in out’ parameters in
interfacing to external functions (which are not permitted in Ada
functions).  GNAT does not require a separate pragma ‘Export’, but if
none is present, ‘Convention Ada’ is assumed, which is almost certainly
not what is wanted since the whole point of this pragma is to interface
with foreign language functions, so it is usually appropriate to use
this pragma in conjunction with a ‘Export’ or ‘Convention’ pragma that
specifies the desired foreign convention.

Special treatment is given if the EXTERNAL is an explicit null string or
a static string expressions that evaluates to the null string.  In this
case, no external name is generated.  This form still allows the
specification of parameter mechanisms.


File: gnat_rm.info,  Node: Pragma Extend_System,  Next: Pragma Extensions_Allowed,  Prev: Pragma Export_Valued_Procedure,  Up: Implementation Defined Pragmas

2.59 Pragma Extend_System
=========================

Syntax:

     pragma Extend_System ([Name =>] IDENTIFIER);

This pragma is used to provide backwards compatibility with other
implementations that extend the facilities of package ‘System’.  In
GNAT, ‘System’ contains only the definitions that are present in the Ada
RM. However, other implementations, notably the DEC Ada 83
implementation, provide many extensions to package ‘System’.

For each such implementation accommodated by this pragma, GNAT provides
a package ‘Aux_`xxx'’, e.g., ‘Aux_DEC’ for the DEC Ada 83
implementation, which provides the required additional definitions.  You
can use this package in two ways.  You can ‘with’ it in the normal way
and access entities either by selection or using a ‘use’ clause.  In
this case no special processing is required.

However, if existing code contains references such as ‘System.`xxx'’
where `xxx' is an entity in the extended definitions provided in package
‘System’, you may use this pragma to extend visibility in ‘System’ in a
non-standard way that provides greater compatibility with the existing
code.  Pragma ‘Extend_System’ is a configuration pragma whose single
argument is the name of the package containing the extended definition
(e.g., ‘Aux_DEC’ for the DEC Ada case).  A unit compiled under control
of this pragma will be processed using special visibility processing
that looks in package ‘System.Aux_`xxx'’ where ‘Aux_`xxx'’ is the pragma
argument for any entity referenced in package ‘System’, but not found in
package ‘System’.

You can use this pragma either to access a predefined ‘System’ extension
supplied with the compiler, for example ‘Aux_DEC’ or you can construct
your own extension unit following the above definition.  Note that such
a package is a child of ‘System’ and thus is considered part of the
implementation.  To compile it you will have to use the `-gnatg' switch
for compiling System units, as explained in the GNAT User’s Guide.


File: gnat_rm.info,  Node: Pragma Extensions_Allowed,  Next: Pragma Extensions_Visible,  Prev: Pragma Extend_System,  Up: Implementation Defined Pragmas

2.60 Pragma Extensions_Allowed
==============================

Syntax:

     pragma Extensions_Allowed (On | Off);

This configuration pragma enables or disables the implementation
extension mode (the use of Off as a parameter cancels the effect of the
`-gnatX' command switch).

In extension mode, the latest version of the Ada language is implemented
(currently Ada 2022), and in addition a number of GNAT specific
extensions are recognized as follows:

   * Constrained attribute for generic objects

     The ‘Constrained’ attribute is permitted for objects of generic
     types.  The result indicates if the corresponding actual is
     constrained.

   * ‘Static’ aspect on intrinsic functions

     The Ada 202x ‘Static’ aspect can be specified on Intrinsic imported
     functions and the compiler will evaluate some of these intrinsic
     statically, in particular the ‘Shift_Left’ and ‘Shift_Right’
     intrinsics.

   * ‘'Reduce’ attribute

     This attribute part of the Ada 202x language definition is provided
     for now under -gnatX to confirm and potentially refine its usage
     and syntax.

   * ‘[]’ aggregates

     This new aggregate syntax for arrays and containers is provided
     under -gnatX to experiment and confirm this new language syntax.

   * Additional ‘when’ constructs

     In addition to the ‘exit when CONDITION’ control structure, several
     additional constructs are allowed following this format.  Including
     ‘return when CONDITION’, ‘goto when CONDITION’, and ‘raise [with
     EXCEPTION_MESSAGE] when CONDITION.’

     Some examples:

          return Result when Variable > 10;

          raise Program_Error with "Element is null" when Element = null;

          goto End_Of_Subprogram when Variable = -1;

   * Casing on composite values (aka pattern matching)

     The selector for a case statement may be of a composite type,
     subject to some restrictions (described below).  Aggregate syntax
     is used for choices of such a case statement; however, in cases
     where a “normal” aggregate would require a discrete value, a
     discrete subtype may be used instead; box notation can also be used
     to match all values.

     Consider this example:

          type Rec is record
             F1, F2 : Integer;
          end record;

          procedure Caser_1 (X : Rec) is
          begin
             case X is
                when (F1 => Positive, F2 => Positive) =>
                   Do_This;
                when (F1 => Natural, F2 => <>) | (F1 => <>, F2 => Natural) =>
                   Do_That;
                when others =>
                    Do_The_Other_Thing;
             end case;
          end Caser_1;

     If Caser_1 is called and both components of X are positive, then
     Do_This will be called; otherwise, if either component is
     nonnegative then Do_That will be called; otherwise,
     Do_The_Other_Thing will be called.

     If the set of values that match the choice(s) of an earlier
     alternative overlaps the corresponding set of a later alternative,
     then the first set shall be a proper subset of the second (and the
     later alternative will not be executed if the earlier alternative
     “matches”).  All possible values of the composite type shall be
     covered.  The composite type of the selector shall be an array or
     record type that is neither limited class-wide.

     If a subcomponent’s subtype does not meet certain restrictions,
     then the only value that can be specified for that subcomponent in
     a case choice expression is a “box” component association (which
     matches all possible values for the subcomponent).  This
     restriction applies if

        - the component subtype is not a record, array, or discrete
          type; or

        - the component subtype is subject to a non-static constraint or
          has a predicate; or

        - the component type is an enumeration type that is subject to
          an enumeration representation clause; or

        - the component type is a multidimensional array type or an
          array type with a nonstatic index subtype.

     Support for casing on arrays (and on records that contain arrays)
     is currently subject to some restrictions.  Non-positional array
     aggregates are not supported as (or within) case choices.  Likewise
     for array type and subtype names.  The current implementation
     exceeds compile-time capacity limits in some annoyingly common
     scenarios; the message generated in such cases is usually “Capacity
     exceeded in compiling case statement with composite selector type”.

     In addition, pattern bindings are supported.  This is a mechanism
     for binding a name to a component of a matching value for use
     within an alternative of a case statement.  For a component
     association that occurs within a case choice, the expression may be
     followed by “is <identifier>”.  In the special case of a “box”
     component association, the identifier may instead be provided
     within the box.  Either of these indicates that the given identifer
     denotes (a constant view of) the matching subcomponent of the case
     selector.  Binding is not yet supported for arrays or subcomponents
     thereof.

     Consider this example (which uses type Rec from the previous
     example):

          procedure Caser_2 (X : Rec) is
          begin
             case X is
                when (F1 => Positive is Abc, F2 => Positive) =>
                   Do_This (Abc)
                when (F1 => Natural is N1, F2 => <N2>) |
                     (F1 => <N2>, F2 => Natural is N1) =>
                   Do_That (Param_1 => N1, Param_2 => N2);
                when others =>
                   Do_The_Other_Thing;
             end case;
          end Caser_2;

     This example is the same as the previous one with respect to
     determining whether Do_This, Do_That, or Do_The_Other_Thing will be
     called.  But for this version, Do_This takes a parameter and
     Do_That takes two parameters.  If Do_This is called, the actual
     parameter in the call will be X.F1.

     If Do_That is called, the situation is more complex because there
     are two choices for that alternative.  If Do_That is called because
     the first choice matched (i.e., because X.F1 is nonnegative and
     either X.F1 or X.F2 is zero or negative), then the actual
     parameters of the call will be (in order) X.F1 and X.F2.  If
     Do_That is called because the second choice matched (and the first
     one did not), then the actual parameters will be reversed.

     Within the choice list for single alternative, each choice must
     define the same set of bindings and the component subtypes for for
     a given identifer must all statically match.  Currently, the case
     of a binding for a nondiscrete component is not implemented.

   * Fixed lower bounds for array types and subtypes

     Unconstrained array types and subtypes can be specified with a
     lower bound that is fixed to a certain value, by writing an index
     range that uses the syntax “<lower-bound-expression> ..  <>”.  This
     guarantees that all objects of the type or subtype will have the
     specified lower bound.

     For example, a matrix type with fixed lower bounds of zero for each
     dimension can be declared by the following:

          type Matrix is
            array (Natural range 0 .. <>, Natural range 0 .. <>) of Integer;

     Objects of type Matrix declared with an index constraint must have
     index ranges starting at zero:

          M1 : Matrix (0 .. 9, 0 .. 19);
          M2 : Matrix (2 .. 11, 3 .. 22);  -- Warning about bounds; will raise CE

     Similarly, a subtype of String can be declared that specifies the
     lower bound of objects of that subtype to be 1:

               subtype String_1 is String (1 .. <>);

     If a string slice is passed to a formal of subtype String_1 in a
     call to a subprogram S, the slice’s bounds will “slide” so that the
     lower bound is 1.  Within S, the lower bound of the formal is known
     to be 1, so, unlike a normal unconstrained String formal, there is
     no need to worry about accounting for other possible lower-bound
     values.  Sliding of bounds also occurs in other contexts, such as
     for object declarations with an unconstrained subtype with fixed
     lower bound, as well as in subtype conversions.

     Use of this feature increases safety by simplifying code, and can
     also improve the efficiency of indexing operations, since the
     compiler statically knows the lower bound of unconstrained array
     formals when the formal’s subtype has index ranges with static
     fixed lower bounds.

   * Prefixed-view notation for calls to primitive subprograms of
     untagged types

     Since Ada 2005, calls to primitive subprograms of a tagged type
     that have a “prefixed view” (see RM 4.1.3(9.2)) have been allowed
     to be written using the form of a selected_component, with the
     first actual parameter given as the prefix and the name of the
     subprogram as a selector.  This prefixed-view notation for calls is
     extended so as to also allow such syntax for calls to primitive
     subprograms of untagged types.  The primitives of an untagged type
     T that have a prefixed view are those where the first formal
     parameter of the subprogram either is of type T or is an anonymous
     access parameter whose designated type is T. For a type that has a
     component that happens to have the same simple name as one of the
     type’s primitive subprograms, where the component is visible at the
     point of a selected_component using that name, preference is given
     to the component in a selected_component (as is currently the case
     for tagged types with such component names).

   * Expression defaults for generic formal functions

     The declaration of a generic formal function is allowed to specify
     an expression as a default, using the syntax of an expression
     function.

     Here is an example of this feature:

          generic
             type T is private;
             with function Copy (Item : T) return T is (Item); -- Defaults to Item
          package Stacks is

             type Stack is limited private;

             procedure Push (S : in out Stack; X : T); -- Calls Copy on X

             function Pop (S : in out Stack) return T; -- Calls Copy to return item

          private
             -- ...
          end Stacks;


File: gnat_rm.info,  Node: Pragma Extensions_Visible,  Next: Pragma External,  Prev: Pragma Extensions_Allowed,  Up: Implementation Defined Pragmas

2.61 Pragma Extensions_Visible
==============================

Syntax:

     pragma Extensions_Visible [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Extensions_Visible’ in the SPARK 2014 Reference Manual, section 6.1.7.


File: gnat_rm.info,  Node: Pragma External,  Next: Pragma External_Name_Casing,  Prev: Pragma Extensions_Visible,  Up: Implementation Defined Pragmas

2.62 Pragma External
====================

Syntax:

     pragma External (
       [   Convention    =>] convention_IDENTIFIER,
       [   Entity        =>] LOCAL_NAME
       [, [External_Name =>] static_string_EXPRESSION ]
       [, [Link_Name     =>] static_string_EXPRESSION ]);

This pragma is identical in syntax and semantics to pragma ‘Export’ as
defined in the Ada Reference Manual.  It is provided for compatibility
with some Ada 83 compilers that used this pragma for exactly the same
purposes as pragma ‘Export’ before the latter was standardized.


File: gnat_rm.info,  Node: Pragma External_Name_Casing,  Next: Pragma Fast_Math,  Prev: Pragma External,  Up: Implementation Defined Pragmas

2.63 Pragma External_Name_Casing
================================

Syntax:

     pragma External_Name_Casing (
       Uppercase | Lowercase
       [, Uppercase | Lowercase | As_Is]);

This pragma provides control over the casing of external names
associated with Import and Export pragmas.  There are two cases to
consider:

   * Implicit external names

     Implicit external names are derived from identifiers.  The most
     common case arises when a standard Ada Import or Export pragma is
     used with only two arguments, as in:

          pragma Import (C, C_Routine);

     Since Ada is a case-insensitive language, the spelling of the
     identifier in the Ada source program does not provide any
     information on the desired casing of the external name, and so a
     convention is needed.  In GNAT the default treatment is that such
     names are converted to all lower case letters.  This corresponds to
     the normal C style in many environments.  The first argument of
     pragma ‘External_Name_Casing’ can be used to control this
     treatment.  If ‘Uppercase’ is specified, then the name will be
     forced to all uppercase letters.  If ‘Lowercase’ is specified, then
     the normal default of all lower case letters will be used.

     This same implicit treatment is also used in the case of extended
     DEC Ada 83 compatible Import and Export pragmas where an external
     name is explicitly specified using an identifier rather than a
     string.

   * Explicit external names

     Explicit external names are given as string literals.  The most
     common case arises when a standard Ada Import or Export pragma is
     used with three arguments, as in:

          pragma Import (C, C_Routine, "C_routine");

     In this case, the string literal normally provides the exact casing
     required for the external name.  The second argument of pragma
     ‘External_Name_Casing’ may be used to modify this behavior.  If
     ‘Uppercase’ is specified, then the name will be forced to all
     uppercase letters.  If ‘Lowercase’ is specified, then the name will
     be forced to all lowercase letters.  A specification of ‘As_Is’
     provides the normal default behavior in which the casing is taken
     from the string provided.

This pragma may appear anywhere that a pragma is valid.  In particular,
it can be used as a configuration pragma in the ‘gnat.adc’ file, in
which case it applies to all subsequent compilations, or it can be used
as a program unit pragma, in which case it only applies to the current
unit, or it can be used more locally to control individual Import/Export
pragmas.

It was primarily intended for use with OpenVMS systems, where many
compilers convert all symbols to upper case by default.  For interfacing
to such compilers (e.g., the DEC C compiler), it may be convenient to
use the pragma:

     pragma External_Name_Casing (Uppercase, Uppercase);

to enforce the upper casing of all external symbols.


File: gnat_rm.info,  Node: Pragma Fast_Math,  Next: Pragma Favor_Top_Level,  Prev: Pragma External_Name_Casing,  Up: Implementation Defined Pragmas

2.64 Pragma Fast_Math
=====================

Syntax:

     pragma Fast_Math;

This is a configuration pragma which activates a mode in which speed is
considered more important for floating-point operations than absolutely
accurate adherence to the requirements of the standard.  Currently the
following operations are affected:

`Complex Multiplication'

     The normal simple formula for complex multiplication can result in
     intermediate overflows for numbers near the end of the range.  The
     Ada standard requires that this situation be detected and corrected
     by scaling, but in Fast_Math mode such cases will simply result in
     overflow.  Note that to take advantage of this you must instantiate
     your own version of ‘Ada.Numerics.Generic_Complex_Types’ under
     control of the pragma, rather than use the preinstantiated
     versions.


File: gnat_rm.info,  Node: Pragma Favor_Top_Level,  Next: Pragma Finalize_Storage_Only,  Prev: Pragma Fast_Math,  Up: Implementation Defined Pragmas

2.65 Pragma Favor_Top_Level
===========================

Syntax:

     pragma Favor_Top_Level (type_NAME);

The argument of pragma ‘Favor_Top_Level’ must be a named
access-to-subprogram type.  This pragma is an efficiency hint to the
compiler, regarding the use of ‘'Access’ or ‘'Unrestricted_Access’ on
nested (non-library-level) subprograms.  The pragma means that nested
subprograms are not used with this type, or are rare, so that the
generated code should be efficient in the top-level case.  When this
pragma is used, dynamically generated trampolines may be used on some
targets for nested subprograms.  See restriction
‘No_Implicit_Dynamic_Code’.


File: gnat_rm.info,  Node: Pragma Finalize_Storage_Only,  Next: Pragma Float_Representation,  Prev: Pragma Favor_Top_Level,  Up: Implementation Defined Pragmas

2.66 Pragma Finalize_Storage_Only
=================================

Syntax:

     pragma Finalize_Storage_Only (first_subtype_LOCAL_NAME);

The argument of pragma ‘Finalize_Storage_Only’ must denote a local type
which is derived from ‘Ada.Finalization.Controlled’ or
‘Limited_Controlled’.  The pragma suppresses the call to ‘Finalize’ for
declared library-level objects of the argument type.  This is mostly
useful for types where finalization is only used to deal with storage
reclamation since in most environments it is not necessary to reclaim
memory just before terminating execution, hence the name.  Note that
this pragma does not suppress Finalize calls for library-level
heap-allocated objects (see pragma ‘No_Heap_Finalization’).


File: gnat_rm.info,  Node: Pragma Float_Representation,  Next: Pragma Ghost,  Prev: Pragma Finalize_Storage_Only,  Up: Implementation Defined Pragmas

2.67 Pragma Float_Representation
================================

Syntax:

     pragma Float_Representation (FLOAT_REP[, float_type_LOCAL_NAME]);

     FLOAT_REP ::= VAX_Float | IEEE_Float

In the one argument form, this pragma is a configuration pragma which
allows control over the internal representation chosen for the
predefined floating point types declared in the packages ‘Standard’ and
‘System’.  This pragma is only provided for compatibility and has no
effect.

The two argument form specifies the representation to be used for the
specified floating-point type.  The argument must be ‘IEEE_Float’ to
specify the use of IEEE format, as follows:

   * For a digits value of 6, 32-bit IEEE short format will be used.

   * For a digits value of 15, 64-bit IEEE long format will be used.

   * No other value of digits is permitted.


File: gnat_rm.info,  Node: Pragma Ghost,  Next: Pragma Global,  Prev: Pragma Float_Representation,  Up: Implementation Defined Pragmas

2.68 Pragma Ghost
=================

Syntax:

     pragma Ghost [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect ‘Ghost’ in
the SPARK 2014 Reference Manual, section 6.9.


File: gnat_rm.info,  Node: Pragma Global,  Next: Pragma Ident,  Prev: Pragma Ghost,  Up: Implementation Defined Pragmas

2.69 Pragma Global
==================

Syntax:

     pragma Global (GLOBAL_SPECIFICATION);

     GLOBAL_SPECIFICATION ::=
          null
       | (GLOBAL_LIST)
       | (MODED_GLOBAL_LIST {, MODED_GLOBAL_LIST})

     MODED_GLOBAL_LIST ::= MODE_SELECTOR => GLOBAL_LIST

     MODE_SELECTOR ::= In_Out | Input | Output | Proof_In
     GLOBAL_LIST   ::= GLOBAL_ITEM | (GLOBAL_ITEM {, GLOBAL_ITEM})
     GLOBAL_ITEM   ::= NAME

For the semantics of this pragma, see the entry for aspect ‘Global’ in
the SPARK 2014 Reference Manual, section 6.1.4.


File: gnat_rm.info,  Node: Pragma Ident,  Next: Pragma Ignore_Pragma,  Prev: Pragma Global,  Up: Implementation Defined Pragmas

2.70 Pragma Ident
=================

Syntax:

     pragma Ident (static_string_EXPRESSION);

This pragma is identical in effect to pragma ‘Comment’.  It is provided
for compatibility with other Ada compilers providing this pragma.


File: gnat_rm.info,  Node: Pragma Ignore_Pragma,  Next: Pragma Implementation_Defined,  Prev: Pragma Ident,  Up: Implementation Defined Pragmas

2.71 Pragma Ignore_Pragma
=========================

Syntax:

     pragma Ignore_Pragma (pragma_IDENTIFIER);

This is a configuration pragma that takes a single argument that is a
simple identifier.  Any subsequent use of a pragma whose pragma
identifier matches this argument will be silently ignored.  This may be
useful when legacy code or code intended for compilation with some other
compiler contains pragmas that match the name, but not the exact
implementation, of a GNAT pragma.  The use of this pragma allows such
pragmas to be ignored, which may be useful in CodePeer mode, or during
porting of legacy code.


File: gnat_rm.info,  Node: Pragma Implementation_Defined,  Next: Pragma Implemented,  Prev: Pragma Ignore_Pragma,  Up: Implementation Defined Pragmas

2.72 Pragma Implementation_Defined
==================================

Syntax:

     pragma Implementation_Defined (local_NAME);

This pragma marks a previously declared entity as
implementation-defined.  For an overloaded entity, applies to the most
recent homonym.

     pragma Implementation_Defined;

The form with no arguments appears anywhere within a scope, most
typically a package spec, and indicates that all entities that are
defined within the package spec are Implementation_Defined.

This pragma is used within the GNAT runtime library to identify
implementation-defined entities introduced in language-defined units,
for the purpose of implementing the No_Implementation_Identifiers
restriction.


File: gnat_rm.info,  Node: Pragma Implemented,  Next: Pragma Implicit_Packing,  Prev: Pragma Implementation_Defined,  Up: Implementation Defined Pragmas

2.73 Pragma Implemented
=======================

Syntax:

     pragma Implemented (procedure_LOCAL_NAME, implementation_kind);

     implementation_kind ::= By_Entry | By_Protected_Procedure | By_Any

This is an Ada 2012 representation pragma which applies to protected,
task and synchronized interface primitives.  The use of pragma
Implemented provides a way to impose a static requirement on the
overriding operation by adhering to one of the three implementation
kinds: entry, protected procedure or any of the above.  This pragma is
available in all earlier versions of Ada as an implementation-defined
pragma.

     type Synch_Iface is synchronized interface;
     procedure Prim_Op (Obj : in out Iface) is abstract;
     pragma Implemented (Prim_Op, By_Protected_Procedure);

     protected type Prot_1 is new Synch_Iface with
        procedure Prim_Op;  --  Legal
     end Prot_1;

     protected type Prot_2 is new Synch_Iface with
        entry Prim_Op;      --  Illegal
     end Prot_2;

     task type Task_Typ is new Synch_Iface with
        entry Prim_Op;      --  Illegal
     end Task_Typ;

When applied to the procedure_or_entry_NAME of a requeue statement,
pragma Implemented determines the runtime behavior of the requeue.
Implementation kind By_Entry guarantees that the action of requeueing
will proceed from an entry to another entry.  Implementation kind
By_Protected_Procedure transforms the requeue into a dispatching call,
thus eliminating the chance of blocking.  Kind By_Any shares the
behavior of By_Entry and By_Protected_Procedure depending on the
target’s overriding subprogram kind.


File: gnat_rm.info,  Node: Pragma Implicit_Packing,  Next: Pragma Import_Function,  Prev: Pragma Implemented,  Up: Implementation Defined Pragmas

2.74 Pragma Implicit_Packing
============================

Syntax:

     pragma Implicit_Packing;

This is a configuration pragma that requests implicit packing for packed
arrays for which a size clause is given but no explicit pragma Pack or
specification of Component_Size is present.  It also applies to records
where no record representation clause is present.  Consider this
example:

     type R is array (0 .. 7) of Boolean;
     for R'Size use 8;

In accordance with the recommendation in the RM (RM 13.3(53)), a Size
clause does not change the layout of a composite object.  So the Size
clause in the above example is normally rejected, since the default
layout of the array uses 8-bit components, and thus the array requires a
minimum of 64 bits.

If this declaration is compiled in a region of code covered by an
occurrence of the configuration pragma Implicit_Packing, then the Size
clause in this and similar examples will cause implicit packing and thus
be accepted.  For this implicit packing to occur, the type in question
must be an array of small components whose size is known at compile
time, and the Size clause must specify the exact size that corresponds
to the number of elements in the array multiplied by the size in bits of
the component type (both single and multi-dimensioned arrays can be
controlled with this pragma).

Similarly, the following example shows the use in the record case

     type r is record
        a, b, c, d, e, f, g, h : boolean;
        chr                    : character;
     end record;
     for r'size use 16;

Without a pragma Pack, each Boolean field requires 8 bits, so the
minimum size is 72 bits, but with a pragma Pack, 16 bits would be
sufficient.  The use of pragma Implicit_Packing allows this record
declaration to compile without an explicit pragma Pack.


File: gnat_rm.info,  Node: Pragma Import_Function,  Next: Pragma Import_Object,  Prev: Pragma Implicit_Packing,  Up: Implementation Defined Pragmas

2.75 Pragma Import_Function
===========================

Syntax:

     pragma Import_Function (
          [Internal                 =>] LOCAL_NAME,
       [, [External                 =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types          =>] PARAMETER_TYPES]
       [, [Result_Type              =>] SUBTYPE_MARK]
       [, [Mechanism                =>] MECHANISM]
       [, [Result_Mechanism         =>] MECHANISM_NAME]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::=
       Value
     | Reference

This pragma is used in conjunction with a pragma ‘Import’ to specify
additional information for an imported function.  The pragma ‘Import’
(or equivalent pragma ‘Interface’) must precede the ‘Import_Function’
pragma and both must appear in the same declarative part as the function
specification.

The ‘Internal’ argument must uniquely designate the function to which
the pragma applies.  If more than one function name exists of this name
in the declarative part you must use the ‘Parameter_Types’ and
‘Result_Type’ parameters to achieve the required unique designation.
Subtype marks in these parameters must exactly match the subtypes in the
corresponding function specification, using positional notation to match
parameters with subtype marks.  The form with an ‘'Access’ attribute can
be used to match an anonymous access parameter.

You may optionally use the ‘Mechanism’ and ‘Result_Mechanism’ parameters
to specify passing mechanisms for the parameters and result.  If you
specify a single mechanism name, it applies to all parameters.
Otherwise you may specify a mechanism on a parameter by parameter basis
using either positional or named notation.  If the mechanism is not
specified, the default mechanism is used.


File: gnat_rm.info,  Node: Pragma Import_Object,  Next: Pragma Import_Procedure,  Prev: Pragma Import_Function,  Up: Implementation Defined Pragmas

2.76 Pragma Import_Object
=========================

Syntax:

     pragma Import_Object
          [Internal =>] LOCAL_NAME
       [, [External =>] EXTERNAL_SYMBOL]
       [, [Size     =>] EXTERNAL_SYMBOL]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

This pragma designates an object as imported, and apart from the
extended rules for external symbols, is identical in effect to the use
of the normal ‘Import’ pragma applied to an object.  Unlike the
subprogram case, you need not use a separate ‘Import’ pragma, although
you may do so (and probably should do so from a portability point of
view).  ‘size’ is syntax checked, but otherwise ignored by GNAT.


File: gnat_rm.info,  Node: Pragma Import_Procedure,  Next: Pragma Import_Valued_Procedure,  Prev: Pragma Import_Object,  Up: Implementation Defined Pragmas

2.77 Pragma Import_Procedure
============================

Syntax:

     pragma Import_Procedure (
          [Internal                 =>] LOCAL_NAME
       [, [External                 =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types          =>] PARAMETER_TYPES]
       [, [Mechanism                =>] MECHANISM]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::= Value | Reference

This pragma is identical to ‘Import_Function’ except that it applies to
a procedure rather than a function and the parameters ‘Result_Type’ and
‘Result_Mechanism’ are not permitted.


File: gnat_rm.info,  Node: Pragma Import_Valued_Procedure,  Next: Pragma Independent,  Prev: Pragma Import_Procedure,  Up: Implementation Defined Pragmas

2.78 Pragma Import_Valued_Procedure
===================================

Syntax:

     pragma Import_Valued_Procedure (
          [Internal                 =>] LOCAL_NAME
       [, [External                 =>] EXTERNAL_SYMBOL]
       [, [Parameter_Types          =>] PARAMETER_TYPES]
       [, [Mechanism                =>] MECHANISM]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

     PARAMETER_TYPES ::=
       null
     | TYPE_DESIGNATOR {, TYPE_DESIGNATOR}

     TYPE_DESIGNATOR ::=
       subtype_NAME
     | subtype_Name ' Access

     MECHANISM ::=
       MECHANISM_NAME
     | (MECHANISM_ASSOCIATION {, MECHANISM_ASSOCIATION})

     MECHANISM_ASSOCIATION ::=
       [formal_parameter_NAME =>] MECHANISM_NAME

     MECHANISM_NAME ::= Value | Reference

This pragma is identical to ‘Import_Procedure’ except that the first
parameter of ‘LOCAL_NAME’, which must be present, must be of mode ‘out’,
and externally the subprogram is treated as a function with this
parameter as the result of the function.  The purpose of this capability
is to allow the use of ‘out’ and ‘in out’ parameters in interfacing to
external functions (which are not permitted in Ada functions).  You may
optionally use the ‘Mechanism’ parameters to specify passing mechanisms
for the parameters.  If you specify a single mechanism name, it applies
to all parameters.  Otherwise you may specify a mechanism on a parameter
by parameter basis using either positional or named notation.  If the
mechanism is not specified, the default mechanism is used.

Note that it is important to use this pragma in conjunction with a
separate pragma Import that specifies the desired convention, since
otherwise the default convention is Ada, which is almost certainly not
what is required.


File: gnat_rm.info,  Node: Pragma Independent,  Next: Pragma Independent_Components,  Prev: Pragma Import_Valued_Procedure,  Up: Implementation Defined Pragmas

2.79 Pragma Independent
=======================

Syntax:

     pragma Independent (Local_NAME);

This pragma is standard in Ada 2012 mode (which also provides an aspect
of the same name).  It is also available as an implementation-defined
pragma in all earlier versions.  It specifies that the designated object
or all objects of the designated type must be independently addressable.
This means that separate tasks can safely manipulate such objects.  For
example, if two components of a record are independent, then two
separate tasks may access these two components.  This may place
constraints on the representation of the object (for instance
prohibiting tight packing).


File: gnat_rm.info,  Node: Pragma Independent_Components,  Next: Pragma Initial_Condition,  Prev: Pragma Independent,  Up: Implementation Defined Pragmas

2.80 Pragma Independent_Components
==================================

Syntax:

     pragma Independent_Components (Local_NAME);

This pragma is standard in Ada 2012 mode (which also provides an aspect
of the same name).  It is also available as an implementation-defined
pragma in all earlier versions.  It specifies that the components of the
designated object, or the components of each object of the designated
type, must be independently addressable.  This means that separate tasks
can safely manipulate separate components in the composite object.  This
may place constraints on the representation of the object (for instance
prohibiting tight packing).


File: gnat_rm.info,  Node: Pragma Initial_Condition,  Next: Pragma Initialize_Scalars,  Prev: Pragma Independent_Components,  Up: Implementation Defined Pragmas

2.81 Pragma Initial_Condition
=============================

Syntax:

     pragma Initial_Condition (boolean_EXPRESSION);

For the semantics of this pragma, see the entry for aspect
‘Initial_Condition’ in the SPARK 2014 Reference Manual, section 7.1.6.


File: gnat_rm.info,  Node: Pragma Initialize_Scalars,  Next: Pragma Initializes,  Prev: Pragma Initial_Condition,  Up: Implementation Defined Pragmas

2.82 Pragma Initialize_Scalars
==============================

Syntax:

     pragma Initialize_Scalars
       [ ( TYPE_VALUE_PAIR {, TYPE_VALUE_PAIR} ) ];

     TYPE_VALUE_PAIR ::=
       SCALAR_TYPE => static_EXPRESSION

     SCALAR_TYPE :=
       Short_Float
     | Float
     | Long_Float
     | Long_Long_Flat
     | Signed_8
     | Signed_16
     | Signed_32
     | Signed_64
     | Unsigned_8
     | Unsigned_16
     | Unsigned_32
     | Unsigned_64

This pragma is similar to ‘Normalize_Scalars’ conceptually but has two
important differences.

First, there is no requirement for the pragma to be used uniformly in
all units of a partition.  In particular, it is fine to use this just
for some or all of the application units of a partition, without needing
to recompile the run-time library.  In the case where some units are
compiled with the pragma, and some without, then a declaration of a
variable where the type is defined in package Standard or is locally
declared will always be subject to initialization, as will any
declaration of a scalar variable.  For composite variables, whether the
variable is initialized may also depend on whether the package in which
the type of the variable is declared is compiled with the pragma.

The other important difference is that the programmer can control the
value used for initializing scalar objects.  This effect can be achieved
in several different ways:

   * At compile time, the programmer can specify the invalid value for a
     particular family of scalar types using the optional arguments of
     the pragma.

     The compile-time approach is intended to optimize the generated
     code for the pragma, by possibly using fast operations such as
     ‘memset’.  Note that such optimizations require using values where
     the bytes all have the same binary representation.

   * At bind time, the programmer has several options:

        * Initialization with invalid values (similar to
          Normalize_Scalars, though for Initialize_Scalars it is not
          always possible to determine the invalid values in complex
          cases like signed component fields with nonstandard sizes).

        * Initialization with high values.

        * Initialization with low values.

        * Initialization with a specific bit pattern.

     See the GNAT User’s Guide for binder options for specifying these
     cases.

     The bind-time approach is intended to provide fast turnaround for
     testing with different values, without having to recompile the
     program.

   * At execution time, the programmer can specify the invalid values
     using an environment variable.  See the GNAT User’s Guide for
     details.

     The execution-time approach is intended to provide fast turnaround
     for testing with different values, without having to recompile and
     rebind the program.

Note that pragma ‘Initialize_Scalars’ is particularly useful in
conjunction with the enhanced validity checking that is now provided in
GNAT, which checks for invalid values under more conditions.  Using this
feature (see description of the `-gnatV' flag in the GNAT User’s Guide)
in conjunction with pragma ‘Initialize_Scalars’ provides a powerful new
tool to assist in the detection of problems caused by uninitialized
variables.

Note: the use of ‘Initialize_Scalars’ has a fairly extensive effect on
the generated code.  This may cause your code to be substantially
larger.  It may also cause an increase in the amount of stack required,
so it is probably a good idea to turn on stack checking (see description
of stack checking in the GNAT User’s Guide) when using this pragma.


File: gnat_rm.info,  Node: Pragma Initializes,  Next: Pragma Inline_Always,  Prev: Pragma Initialize_Scalars,  Up: Implementation Defined Pragmas

2.83 Pragma Initializes
=======================

Syntax:

     pragma Initializes (INITIALIZATION_LIST);

     INITIALIZATION_LIST ::=
          null
       | (INITIALIZATION_ITEM {, INITIALIZATION_ITEM})

     INITIALIZATION_ITEM ::= name [=> INPUT_LIST]

     INPUT_LIST ::=
          null
       |  INPUT
       | (INPUT {, INPUT})

     INPUT ::= name

For the semantics of this pragma, see the entry for aspect ‘Initializes’
in the SPARK 2014 Reference Manual, section 7.1.5.


File: gnat_rm.info,  Node: Pragma Inline_Always,  Next: Pragma Inline_Generic,  Prev: Pragma Initializes,  Up: Implementation Defined Pragmas

2.84 Pragma Inline_Always
=========================

Syntax:

     pragma Inline_Always (NAME [, NAME]);

Similar to pragma ‘Inline’ except that inlining is unconditional.
Inline_Always instructs the compiler to inline every direct call to the
subprogram or else to emit a compilation error, independently of any
option, in particular `-gnatn' or `-gnatN' or the optimization level.
It is an error to take the address or access of ‘NAME’.  It is also an
error to apply this pragma to a primitive operation of a tagged type.
Thanks to such restrictions, the compiler is allowed to remove the
out-of-line body of ‘NAME’.


File: gnat_rm.info,  Node: Pragma Inline_Generic,  Next: Pragma Interface,  Prev: Pragma Inline_Always,  Up: Implementation Defined Pragmas

2.85 Pragma Inline_Generic
==========================

Syntax:

     pragma Inline_Generic (GNAME {, GNAME});

     GNAME ::= generic_unit_NAME | generic_instance_NAME

This pragma is provided for compatibility with Dec Ada 83.  It has no
effect in GNAT (which always inlines generics), other than to check that
the given names are all names of generic units or generic instances.


File: gnat_rm.info,  Node: Pragma Interface,  Next: Pragma Interface_Name,  Prev: Pragma Inline_Generic,  Up: Implementation Defined Pragmas

2.86 Pragma Interface
=====================

Syntax:

     pragma Interface (
          [Convention    =>] convention_identifier,
          [Entity        =>] local_NAME
       [, [External_Name =>] static_string_expression]
       [, [Link_Name     =>] static_string_expression]);

This pragma is identical in syntax and semantics to the standard Ada
pragma ‘Import’.  It is provided for compatibility with Ada 83.  The
definition is upwards compatible both with pragma ‘Interface’ as defined
in the Ada 83 Reference Manual, and also with some extended
implementations of this pragma in certain Ada 83 implementations.  The
only difference between pragma ‘Interface’ and pragma ‘Import’ is that
there is special circuitry to allow both pragmas to appear for the same
subprogram entity (normally it is illegal to have multiple ‘Import’
pragmas.  This is useful in maintaining Ada 83/Ada 95 compatibility and
is compatible with other Ada 83 compilers.


File: gnat_rm.info,  Node: Pragma Interface_Name,  Next: Pragma Interrupt_Handler,  Prev: Pragma Interface,  Up: Implementation Defined Pragmas

2.87 Pragma Interface_Name
==========================

Syntax:

     pragma Interface_Name (
          [Entity        =>] LOCAL_NAME
       [, [External_Name =>] static_string_EXPRESSION]
       [, [Link_Name     =>] static_string_EXPRESSION]);

This pragma provides an alternative way of specifying the interface name
for an interfaced subprogram, and is provided for compatibility with Ada
83 compilers that use the pragma for this purpose.  You must provide at
least one of ‘External_Name’ or ‘Link_Name’.


File: gnat_rm.info,  Node: Pragma Interrupt_Handler,  Next: Pragma Interrupt_State,  Prev: Pragma Interface_Name,  Up: Implementation Defined Pragmas

2.88 Pragma Interrupt_Handler
=============================

Syntax:

     pragma Interrupt_Handler (procedure_LOCAL_NAME);

This program unit pragma is supported for parameterless protected
procedures as described in Annex C of the Ada Reference Manual.


File: gnat_rm.info,  Node: Pragma Interrupt_State,  Next: Pragma Invariant,  Prev: Pragma Interrupt_Handler,  Up: Implementation Defined Pragmas

2.89 Pragma Interrupt_State
===========================

Syntax:

     pragma Interrupt_State
      ([Name  =>] value,
       [State =>] SYSTEM | RUNTIME | USER);

Normally certain interrupts are reserved to the implementation.  Any
attempt to attach an interrupt causes Program_Error to be raised, as
described in RM C.3.2(22).  A typical example is the ‘SIGINT’ interrupt
used in many systems for an ‘Ctrl-C’ interrupt.  Normally this interrupt
is reserved to the implementation, so that ‘Ctrl-C’ can be used to
interrupt execution.  Additionally, signals such as ‘SIGSEGV’,
‘SIGABRT’, ‘SIGFPE’ and ‘SIGILL’ are often mapped to specific Ada
exceptions, or used to implement run-time functions such as the ‘abort’
statement and stack overflow checking.

Pragma ‘Interrupt_State’ provides a general mechanism for overriding
such uses of interrupts.  It subsumes the functionality of pragma
‘Unreserve_All_Interrupts’.  Pragma ‘Interrupt_State’ is not available
on Windows.  On all other platforms than VxWorks, it applies to signals;
on VxWorks, it applies to vectored hardware interrupts and may be used
to mark interrupts required by the board support package as reserved.

Interrupts can be in one of three states:

   * System

     The interrupt is reserved (no Ada handler can be installed), and
     the Ada run-time may not install a handler.  As a result you are
     guaranteed standard system default action if this interrupt is
     raised.  This also allows installing a low level handler via C APIs
     such as sigaction(), outside of Ada control.

   * Runtime

     The interrupt is reserved (no Ada handler can be installed).  The
     run time is allowed to install a handler for internal control
     purposes, but is not required to do so.

   * User

     The interrupt is unreserved.  The user may install an Ada handler
     via Ada.Interrupts and pragma Interrupt_Handler or Attach_Handler
     to provide some other action.

These states are the allowed values of the ‘State’ parameter of the
pragma.  The ‘Name’ parameter is a value of the type
‘Ada.Interrupts.Interrupt_ID’.  Typically, it is a name declared in
‘Ada.Interrupts.Names’.

This is a configuration pragma, and the binder will check that there are
no inconsistencies between different units in a partition in how a given
interrupt is specified.  It may appear anywhere a pragma is legal.

The effect is to move the interrupt to the specified state.

By declaring interrupts to be SYSTEM, you guarantee the standard system
action, such as a core dump.

By declaring interrupts to be USER, you guarantee that you can install a
handler.

Note that certain signals on many operating systems cannot be caught and
handled by applications.  In such cases, the pragma is ignored.  See the
operating system documentation, or the value of the array ‘Reserved’
declared in the spec of package ‘System.OS_Interface’.

Overriding the default state of signals used by the Ada runtime may
interfere with an application’s runtime behavior in the cases of the
synchronous signals, and in the case of the signal used to implement the
‘abort’ statement.


File: gnat_rm.info,  Node: Pragma Invariant,  Next: Pragma Keep_Names,  Prev: Pragma Interrupt_State,  Up: Implementation Defined Pragmas

2.90 Pragma Invariant
=====================

Syntax:

     pragma Invariant
       ([Entity =>]    private_type_LOCAL_NAME,
        [Check  =>]    EXPRESSION
        [,[Message =>] String_Expression]);

This pragma provides exactly the same capabilities as the Type_Invariant
aspect defined in AI05-0146-1, and in the Ada 2012 Reference Manual.
The Type_Invariant aspect is fully implemented in Ada 2012 mode, but
since it requires the use of the aspect syntax, which is not available
except in 2012 mode, it is not possible to use the Type_Invariant aspect
in earlier versions of Ada.  However the Invariant pragma may be used in
any version of Ada.  Also note that the aspect Invariant is a synonym in
GNAT for the aspect Type_Invariant, but there is no pragma
Type_Invariant.

The pragma must appear within the visible part of the package
specification, after the type to which its Entity argument appears.  As
with the Invariant aspect, the Check expression is not analyzed until
the end of the visible part of the package, so it may contain forward
references.  The Message argument, if present, provides the exception
message used if the invariant is violated.  If no Message parameter is
provided, a default message that identifies the line on which the pragma
appears is used.

It is permissible to have multiple Invariants for the same type entity,
in which case they are and’ed together.  It is permissible to use this
pragma in Ada 2012 mode, but you cannot have both an invariant aspect
and an invariant pragma for the same entity.

For further details on the use of this pragma, see the Ada 2012
documentation of the Type_Invariant aspect.


File: gnat_rm.info,  Node: Pragma Keep_Names,  Next: Pragma License,  Prev: Pragma Invariant,  Up: Implementation Defined Pragmas

2.91 Pragma Keep_Names
======================

Syntax:

     pragma Keep_Names ([On =>] enumeration_first_subtype_LOCAL_NAME);

The ‘LOCAL_NAME’ argument must refer to an enumeration first subtype in
the current declarative part.  The effect is to retain the enumeration
literal names for use by ‘Image’ and ‘Value’ even if a global
‘Discard_Names’ pragma applies.  This is useful when you want to
generally suppress enumeration literal names and for example you
therefore use a ‘Discard_Names’ pragma in the ‘gnat.adc’ file, but you
want to retain the names for specific enumeration types.


File: gnat_rm.info,  Node: Pragma License,  Next: Pragma Link_With,  Prev: Pragma Keep_Names,  Up: Implementation Defined Pragmas

2.92 Pragma License
===================

Syntax:

     pragma License (Unrestricted | GPL | Modified_GPL | Restricted);

This pragma is provided to allow automated checking for appropriate
license conditions with respect to the standard and modified GPL. A
pragma ‘License’, which is a configuration pragma that typically appears
at the start of a source file or in a separate ‘gnat.adc’ file,
specifies the licensing conditions of a unit as follows:

   * Unrestricted This is used for a unit that can be freely used with
     no license restrictions.  Examples of such units are public domain
     units, and units from the Ada Reference Manual.

   * GPL This is used for a unit that is licensed under the unmodified
     GPL, and which therefore cannot be ‘with’ed by a restricted unit.

   * Modified_GPL This is used for a unit licensed under the GNAT
     modified GPL that includes a special exception paragraph that
     specifically permits the inclusion of the unit in programs without
     requiring the entire program to be released under the GPL.

   * Restricted This is used for a unit that is restricted in that it is
     not permitted to depend on units that are licensed under the GPL.
     Typical examples are proprietary code that is to be released under
     more restrictive license conditions.  Note that restricted units
     are permitted to ‘with’ units which are licensed under the modified
     GPL (this is the whole point of the modified GPL).

Normally a unit with no ‘License’ pragma is considered to have an
unknown license, and no checking is done.  However, standard GNAT
headers are recognized, and license information is derived from them as
follows.

A GNAT license header starts with a line containing 78 hyphens.  The
following comment text is searched for the appearance of any of the
following strings.

If the string ‘GNU General Public License’ is found, then the unit is
assumed to have GPL license, unless the string ‘As a special exception’
follows, in which case the license is assumed to be modified GPL.

If one of the strings ‘This specification is adapted from the Ada
Semantic Interface’ or ‘This specification is derived from the Ada
Reference Manual’ is found then the unit is assumed to be unrestricted.

These default actions means that a program with a restricted license
pragma will automatically get warnings if a GPL unit is inappropriately
‘with’ed.  For example, the program:

     with Sem_Ch3;
     with GNAT.Sockets;
     procedure Secret_Stuff is
       ...
     end Secret_Stuff

if compiled with pragma ‘License’ (‘Restricted’) in a ‘gnat.adc’ file
will generate the warning:

     1.  with Sem_Ch3;
             |
        >>> license of withed unit "Sem_Ch3" is incompatible

     2.  with GNAT.Sockets;
     3.  procedure Secret_Stuff is

Here we get a warning on ‘Sem_Ch3’ since it is part of the GNAT compiler
and is licensed under the GPL, but no warning for ‘GNAT.Sockets’ which
is part of the GNAT run time, and is therefore licensed under the
modified GPL.


File: gnat_rm.info,  Node: Pragma Link_With,  Next: Pragma Linker_Alias,  Prev: Pragma License,  Up: Implementation Defined Pragmas

2.93 Pragma Link_With
=====================

Syntax:

     pragma Link_With (static_string_EXPRESSION {,static_string_EXPRESSION});

This pragma is provided for compatibility with certain Ada 83 compilers.
It has exactly the same effect as pragma ‘Linker_Options’ except that
spaces occurring within one of the string expressions are treated as
separators.  For example, in the following case:

     pragma Link_With ("-labc -ldef");

results in passing the strings ‘-labc’ and ‘-ldef’ as two separate
arguments to the linker.  In addition pragma Link_With allows multiple
arguments, with the same effect as successive pragmas.


File: gnat_rm.info,  Node: Pragma Linker_Alias,  Next: Pragma Linker_Constructor,  Prev: Pragma Link_With,  Up: Implementation Defined Pragmas

2.94 Pragma Linker_Alias
========================

Syntax:

     pragma Linker_Alias (
       [Entity =>] LOCAL_NAME,
       [Target =>] static_string_EXPRESSION);

‘LOCAL_NAME’ must refer to an object that is declared at the library
level.  This pragma establishes the given entity as a linker alias for
the given target.  It is equivalent to ‘__attribute__((alias))’ in GNU C
and causes ‘LOCAL_NAME’ to be emitted as an alias for the symbol
‘static_string_EXPRESSION’ in the object file, that is to say no space
is reserved for ‘LOCAL_NAME’ by the assembler and it will be resolved to
the same address as ‘static_string_EXPRESSION’ by the linker.

The actual linker name for the target must be used (e.g., the fully
encoded name with qualification in Ada, or the mangled name in C++), or
it must be declared using the C convention with ‘pragma Import’ or
‘pragma Export’.

Not all target machines support this pragma.  On some of them it is
accepted only if ‘pragma Weak_External’ has been applied to
‘LOCAL_NAME’.

     --  Example of the use of pragma Linker_Alias

     package p is
       i : Integer := 1;
       pragma Export (C, i);

       new_name_for_i : Integer;
       pragma Linker_Alias (new_name_for_i, "i");
     end p;


File: gnat_rm.info,  Node: Pragma Linker_Constructor,  Next: Pragma Linker_Destructor,  Prev: Pragma Linker_Alias,  Up: Implementation Defined Pragmas

2.95 Pragma Linker_Constructor
==============================

Syntax:

     pragma Linker_Constructor (procedure_LOCAL_NAME);

‘procedure_LOCAL_NAME’ must refer to a parameterless procedure that is
declared at the library level.  A procedure to which this pragma is
applied will be treated as an initialization routine by the linker.  It
is equivalent to ‘__attribute__((constructor))’ in GNU C and causes
‘procedure_LOCAL_NAME’ to be invoked before the entry point of the
executable is called (or immediately after the shared library is loaded
if the procedure is linked in a shared library), in particular before
the Ada run-time environment is set up.

Because of these specific contexts, the set of operations such a
procedure can perform is very limited and the type of objects it can
manipulate is essentially restricted to the elementary types.  In
particular, it must only contain code to which pragma Restrictions
(No_Elaboration_Code) applies.

This pragma is used by GNAT to implement auto-initialization of shared
Stand Alone Libraries, which provides a related capability without the
restrictions listed above.  Where possible, the use of Stand Alone
Libraries is preferable to the use of this pragma.


File: gnat_rm.info,  Node: Pragma Linker_Destructor,  Next: Pragma Linker_Section,  Prev: Pragma Linker_Constructor,  Up: Implementation Defined Pragmas

2.96 Pragma Linker_Destructor
=============================

Syntax:

     pragma Linker_Destructor (procedure_LOCAL_NAME);

‘procedure_LOCAL_NAME’ must refer to a parameterless procedure that is
declared at the library level.  A procedure to which this pragma is
applied will be treated as a finalization routine by the linker.  It is
equivalent to ‘__attribute__((destructor))’ in GNU C and causes
‘procedure_LOCAL_NAME’ to be invoked after the entry point of the
executable has exited (or immediately before the shared library is
unloaded if the procedure is linked in a shared library), in particular
after the Ada run-time environment is shut down.

See ‘pragma Linker_Constructor’ for the set of restrictions that apply
because of these specific contexts.


File: gnat_rm.info,  Node: Pragma Linker_Section,  Next: Pragma Lock_Free,  Prev: Pragma Linker_Destructor,  Up: Implementation Defined Pragmas

2.97 Pragma Linker_Section
==========================

Syntax:

     pragma Linker_Section (
       [Entity  =>] LOCAL_NAME,
       [Section =>] static_string_EXPRESSION);

‘LOCAL_NAME’ must refer to an object, type, or subprogram that is
declared at the library level.  This pragma specifies the name of the
linker section for the given entity.  It is equivalent to
‘__attribute__((section))’ in GNU C and causes ‘LOCAL_NAME’ to be placed
in the ‘static_string_EXPRESSION’ section of the executable (assuming
the linker doesn’t rename the section).  GNAT also provides an
implementation defined aspect of the same name.

In the case of specifying this aspect for a type, the effect is to
specify the corresponding section for all library-level objects of the
type that do not have an explicit linker section set.  Note that this
only applies to whole objects, not to components of composite objects.

In the case of a subprogram, the linker section applies to all
previously declared matching overloaded subprograms in the current
declarative part which do not already have a linker section assigned.
The linker section aspect is useful in this case for specifying
different linker sections for different elements of such an overloaded
set.

Note that an empty string specifies that no linker section is specified.
This is not quite the same as omitting the pragma or aspect, since it
can be used to specify that one element of an overloaded set of
subprograms has the default linker section, or that one object of a type
for which a linker section is specified should has the default linker
section.

The compiler normally places library-level entities in standard sections
depending on the class: procedures and functions generally go in the
‘.text’ section, initialized variables in the ‘.data’ section and
uninitialized variables in the ‘.bss’ section.

Other, special sections may exist on given target machines to map
special hardware, for example I/O ports or flash memory.  This pragma is
a means to defer the final layout of the executable to the linker, thus
fully working at the symbolic level with the compiler.

Some file formats do not support arbitrary sections so not all target
machines support this pragma.  The use of this pragma may cause a
program execution to be erroneous if it is used to place an entity into
an inappropriate section (e.g., a modified variable into the ‘.text’
section).  See also ‘pragma Persistent_BSS’.

     --  Example of the use of pragma Linker_Section

     package IO_Card is
       Port_A : Integer;
       pragma Volatile (Port_A);
       pragma Linker_Section (Port_A, ".bss.port_a");

       Port_B : Integer;
       pragma Volatile (Port_B);
       pragma Linker_Section (Port_B, ".bss.port_b");

       type Port_Type is new Integer with Linker_Section => ".bss";
       PA : Port_Type with Linker_Section => ".bss.PA";
       PB : Port_Type; --  ends up in linker section ".bss"

       procedure Q with Linker_Section => "Qsection";
     end IO_Card;


File: gnat_rm.info,  Node: Pragma Lock_Free,  Next: Pragma Loop_Invariant,  Prev: Pragma Linker_Section,  Up: Implementation Defined Pragmas

2.98 Pragma Lock_Free
=====================

Syntax: This pragma may be specified for protected types or objects.  It
specifies that the implementation of protected operations must be
implemented without locks.  Compilation fails if the compiler cannot
generate lock-free code for the operations.

The current conditions required to support this pragma are:

   * Protected type declarations may not contain entries

   * Protected subprogram declarations may not have nonelementary
     parameters

In addition, each protected subprogram body must satisfy:

   * May reference only one protected component

   * May not reference nonconstant entities outside the protected
     subprogram scope.

   * May not contain address representation items, allocators, or
     quantified expressions.

   * May not contain delay, goto, loop, or procedure-call statements.

   * May not contain exported and imported entities

   * May not dereferenced access values

   * Function calls and attribute references must be static


File: gnat_rm.info,  Node: Pragma Loop_Invariant,  Next: Pragma Loop_Optimize,  Prev: Pragma Lock_Free,  Up: Implementation Defined Pragmas

2.99 Pragma Loop_Invariant
==========================

Syntax:

     pragma Loop_Invariant ( boolean_EXPRESSION );

The effect of this pragma is similar to that of pragma ‘Assert’, except
that in an ‘Assertion_Policy’ pragma, the identifier ‘Loop_Invariant’ is
used to control whether it is ignored or checked (or disabled).

‘Loop_Invariant’ can only appear as one of the items in the sequence of
statements of a loop body, or nested inside block statements that appear
in the sequence of statements of a loop body.  The intention is that it
be used to represent a “loop invariant” assertion, i.e.  something that
is true each time through the loop, and which can be used to show that
the loop is achieving its purpose.

Multiple ‘Loop_Invariant’ and ‘Loop_Variant’ pragmas that apply to the
same loop should be grouped in the same sequence of statements.

To aid in writing such invariants, the special attribute ‘Loop_Entry’
may be used to refer to the value of an expression on entry to the loop.
This attribute can only be used within the expression of a
‘Loop_Invariant’ pragma.  For full details, see documentation of
attribute ‘Loop_Entry’.


File: gnat_rm.info,  Node: Pragma Loop_Optimize,  Next: Pragma Loop_Variant,  Prev: Pragma Loop_Invariant,  Up: Implementation Defined Pragmas

2.100 Pragma Loop_Optimize
==========================

Syntax:

     pragma Loop_Optimize (OPTIMIZATION_HINT {, OPTIMIZATION_HINT});

     OPTIMIZATION_HINT ::= Ivdep | No_Unroll | Unroll | No_Vector | Vector

This pragma must appear immediately within a loop statement.  It allows
the programmer to specify optimization hints for the enclosing loop.
The hints are not mutually exclusive and can be freely mixed, but not
all combinations will yield a sensible outcome.

There are five supported optimization hints for a loop:

   * Ivdep

     The programmer asserts that there are no loop-carried dependencies
     which would prevent consecutive iterations of the loop from being
     executed simultaneously.

   * No_Unroll

     The loop must not be unrolled.  This is a strong hint: the compiler
     will not unroll a loop marked with this hint.

   * Unroll

     The loop should be unrolled.  This is a weak hint: the compiler
     will try to apply unrolling to this loop preferably to other
     optimizations, notably vectorization, but there is no guarantee
     that the loop will be unrolled.

   * No_Vector

     The loop must not be vectorized.  This is a strong hint: the
     compiler will not vectorize a loop marked with this hint.

   * Vector

     The loop should be vectorized.  This is a weak hint: the compiler
     will try to apply vectorization to this loop preferably to other
     optimizations, notably unrolling, but there is no guarantee that
     the loop will be vectorized.

These hints do not remove the need to pass the appropriate switches to
the compiler in order to enable the relevant optimizations, that is to
say `-funroll-loops' for unrolling and `-ftree-vectorize' for
vectorization.


File: gnat_rm.info,  Node: Pragma Loop_Variant,  Next: Pragma Machine_Attribute,  Prev: Pragma Loop_Optimize,  Up: Implementation Defined Pragmas

2.101 Pragma Loop_Variant
=========================

Syntax:

     pragma Loop_Variant ( LOOP_VARIANT_ITEM {, LOOP_VARIANT_ITEM } );
     LOOP_VARIANT_ITEM ::= CHANGE_DIRECTION => discrete_EXPRESSION
     CHANGE_DIRECTION ::= Increases | Decreases

‘Loop_Variant’ can only appear as one of the items in the sequence of
statements of a loop body, or nested inside block statements that appear
in the sequence of statements of a loop body.  It allows the
specification of quantities which must always decrease or increase in
successive iterations of the loop.  In its simplest form, just one
expression is specified, whose value must increase or decrease on each
iteration of the loop.

In a more complex form, multiple arguments can be given which are
intepreted in a nesting lexicographic manner.  For example:

     pragma Loop_Variant (Increases => X, Decreases => Y);

specifies that each time through the loop either X increases, or X stays
the same and Y decreases.  A ‘Loop_Variant’ pragma ensures that the loop
is making progress.  It can be useful in helping to show informally or
prove formally that the loop always terminates.

‘Loop_Variant’ is an assertion whose effect can be controlled using an
‘Assertion_Policy’ with a check name of ‘Loop_Variant’.  The policy can
be ‘Check’ to enable the loop variant check, ‘Ignore’ to ignore the
check (in which case the pragma has no effect on the program), or
‘Disable’ in which case the pragma is not even checked for correct
syntax.

Multiple ‘Loop_Invariant’ and ‘Loop_Variant’ pragmas that apply to the
same loop should be grouped in the same sequence of statements.

The ‘Loop_Entry’ attribute may be used within the expressions of the
‘Loop_Variant’ pragma to refer to values on entry to the loop.


File: gnat_rm.info,  Node: Pragma Machine_Attribute,  Next: Pragma Main,  Prev: Pragma Loop_Variant,  Up: Implementation Defined Pragmas

2.102 Pragma Machine_Attribute
==============================

Syntax:

     pragma Machine_Attribute (
          [Entity         =>] LOCAL_NAME,
          [Attribute_Name =>] static_string_EXPRESSION
       [, [Info           =>] static_EXPRESSION {, static_EXPRESSION}] );

Machine-dependent attributes can be specified for types and/or
declarations.  This pragma is semantically equivalent to
‘__attribute__((`attribute_name'))’ (if ‘info’ is not specified) or
‘__attribute__((`attribute_name(info')))’ or
‘__attribute__((`attribute_name(info,...')))’ in GNU C, where
`attribute_name' is recognized by the compiler middle-end or the
‘TARGET_ATTRIBUTE_TABLE’ machine specific macro.  Note that a string
literal for the optional parameter ‘info’ or the following ones is
transformed by default into an identifier, which may make this pragma
unusable for some attributes.  For further information see ‘GNU Compiler
Collection (GCC) Internals’.


File: gnat_rm.info,  Node: Pragma Main,  Next: Pragma Main_Storage,  Prev: Pragma Machine_Attribute,  Up: Implementation Defined Pragmas

2.103 Pragma Main
=================

Syntax:

     pragma Main
      (MAIN_OPTION [, MAIN_OPTION]);

     MAIN_OPTION ::=
       [Stack_Size              =>] static_integer_EXPRESSION
     | [Task_Stack_Size_Default =>] static_integer_EXPRESSION
     | [Time_Slicing_Enabled    =>] static_boolean_EXPRESSION

This pragma is provided for compatibility with OpenVMS VAX Systems.  It
has no effect in GNAT, other than being syntax checked.


File: gnat_rm.info,  Node: Pragma Main_Storage,  Next: Pragma Max_Queue_Length,  Prev: Pragma Main,  Up: Implementation Defined Pragmas

2.104 Pragma Main_Storage
=========================

Syntax:

     pragma Main_Storage
       (MAIN_STORAGE_OPTION [, MAIN_STORAGE_OPTION]);

     MAIN_STORAGE_OPTION ::=
       [WORKING_STORAGE =>] static_SIMPLE_EXPRESSION
     | [TOP_GUARD       =>] static_SIMPLE_EXPRESSION

This pragma is provided for compatibility with OpenVMS VAX Systems.  It
has no effect in GNAT, other than being syntax checked.


File: gnat_rm.info,  Node: Pragma Max_Queue_Length,  Next: Pragma No_Body,  Prev: Pragma Main_Storage,  Up: Implementation Defined Pragmas

2.105 Pragma Max_Queue_Length
=============================

Syntax:

     pragma Max_Entry_Queue (static_integer_EXPRESSION);

This pragma is used to specify the maximum callers per entry queue for
individual protected entries and entry families.  It accepts a single
integer (-1 or more) as a parameter and must appear after the
declaration of an entry.

A value of -1 represents no additional restriction on queue length.


File: gnat_rm.info,  Node: Pragma No_Body,  Next: Pragma No_Caching,  Prev: Pragma Max_Queue_Length,  Up: Implementation Defined Pragmas

2.106 Pragma No_Body
====================

Syntax:

     pragma No_Body;

There are a number of cases in which a package spec does not require a
body, and in fact a body is not permitted.  GNAT will not permit the
spec to be compiled if there is a body around.  The pragma No_Body
allows you to provide a body file, even in a case where no body is
allowed.  The body file must contain only comments and a single No_Body
pragma.  This is recognized by the compiler as indicating that no body
is logically present.

This is particularly useful during maintenance when a package is
modified in such a way that a body needed before is no longer needed.
The provision of a dummy body with a No_Body pragma ensures that there
is no interference from earlier versions of the package body.


File: gnat_rm.info,  Node: Pragma No_Caching,  Next: Pragma No_Component_Reordering,  Prev: Pragma No_Body,  Up: Implementation Defined Pragmas

2.107 Pragma No_Caching
=======================

Syntax:

     pragma No_Caching [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect ‘No_Caching’
in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma No_Component_Reordering,  Next: Pragma No_Elaboration_Code_All,  Prev: Pragma No_Caching,  Up: Implementation Defined Pragmas

2.108 Pragma No_Component_Reordering
====================================

Syntax:

     pragma No_Component_Reordering [([Entity =>] type_LOCAL_NAME)];

‘type_LOCAL_NAME’ must refer to a record type declaration in the current
declarative part.  The effect is to preclude any reordering of
components for the layout of the record, i.e.  the record is laid out by
the compiler in the order in which the components are declared
textually.  The form with no argument is a configuration pragma which
applies to all record types declared in units to which the pragma
applies and there is a requirement that this pragma be used consistently
within a partition.


File: gnat_rm.info,  Node: Pragma No_Elaboration_Code_All,  Next: Pragma No_Heap_Finalization,  Prev: Pragma No_Component_Reordering,  Up: Implementation Defined Pragmas

2.109 Pragma No_Elaboration_Code_All
====================================

Syntax:

     pragma No_Elaboration_Code_All [(program_unit_NAME)];

This is a program unit pragma (there is also an equivalent aspect of the
same name) that establishes the restriction ‘No_Elaboration_Code’ for
the current unit and any extended main source units (body and subunits).
It also has the effect of enforcing a transitive application of this
aspect, so that if any unit is implicitly or explicitly with’ed by the
current unit, it must also have the No_Elaboration_Code_All aspect set.
It may be applied to package or subprogram specs or their generic
versions.


File: gnat_rm.info,  Node: Pragma No_Heap_Finalization,  Next: Pragma No_Inline,  Prev: Pragma No_Elaboration_Code_All,  Up: Implementation Defined Pragmas

2.110 Pragma No_Heap_Finalization
=================================

Syntax:

     pragma No_Heap_Finalization [ (first_subtype_LOCAL_NAME) ];

Pragma ‘No_Heap_Finalization’ may be used as a configuration pragma or
as a type-specific pragma.

In its configuration form, the pragma must appear within a configuration
file such as gnat.adc, without an argument.  The pragma suppresses the
call to ‘Finalize’ for heap-allocated objects created through
library-level named access-to-object types in cases where the designated
type requires finalization actions.

In its type-specific form, the argument of the pragma must denote a
library-level named access-to-object type.  The pragma suppresses the
call to ‘Finalize’ for heap-allocated objects created through the
specific access type in cases where the designated type requires
finalization actions.

It is still possible to finalize such heap-allocated objects by
explicitly deallocating them.

A library-level named access-to-object type declared within a generic
unit will lose its ‘No_Heap_Finalization’ pragma when the corresponding
instance does not appear at the library level.


File: gnat_rm.info,  Node: Pragma No_Inline,  Next: Pragma No_Return,  Prev: Pragma No_Heap_Finalization,  Up: Implementation Defined Pragmas

2.111 Pragma No_Inline
======================

Syntax:

     pragma No_Inline (NAME {, NAME});

This pragma suppresses inlining for the callable entity or the instances
of the generic subprogram designated by ‘NAME’, including inlining that
results from the use of pragma ‘Inline’.  This pragma is always active,
in particular it is not subject to the use of option `-gnatn' or
`-gnatN'. It is illegal to specify both pragma ‘No_Inline’ and pragma
‘Inline_Always’ for the same ‘NAME’.


File: gnat_rm.info,  Node: Pragma No_Return,  Next: Pragma No_Strict_Aliasing,  Prev: Pragma No_Inline,  Up: Implementation Defined Pragmas

2.112 Pragma No_Return
======================

Syntax:

     pragma No_Return (procedure_LOCAL_NAME {, procedure_LOCAL_NAME});

Each ‘procedure_LOCAL_NAME’ argument must refer to one or more procedure
declarations in the current declarative part.  A procedure to which this
pragma is applied may not contain any explicit ‘return’ statements.  In
addition, if the procedure contains any implicit returns from falling
off the end of a statement sequence, then execution of that implicit
return will cause Program_Error to be raised.

One use of this pragma is to identify procedures whose only purpose is
to raise an exception.  Another use of this pragma is to suppress
incorrect warnings about missing returns in functions, where the last
statement of a function statement sequence is a call to such a
procedure.

Note that in Ada 2005 mode, this pragma is part of the language.  It is
available in all earlier versions of Ada as an implementation-defined
pragma.


File: gnat_rm.info,  Node: Pragma No_Strict_Aliasing,  Next: Pragma No_Tagged_Streams,  Prev: Pragma No_Return,  Up: Implementation Defined Pragmas

2.113 Pragma No_Strict_Aliasing
===============================

Syntax:

     pragma No_Strict_Aliasing [([Entity =>] type_LOCAL_NAME)];

‘type_LOCAL_NAME’ must refer to an access type declaration in the
current declarative part.  The effect is to inhibit strict aliasing
optimization for the given type.  The form with no arguments is a
configuration pragma which applies to all access types declared in units
to which the pragma applies.  For a detailed description of the strict
aliasing optimization, and the situations in which it must be
suppressed, see the section on Optimization and Strict Aliasing in the
‘GNAT User’s Guide’.

This pragma currently has no effects on access to unconstrained array
types.


File: gnat_rm.info,  Node: Pragma No_Tagged_Streams,  Next: Pragma Normalize_Scalars,  Prev: Pragma No_Strict_Aliasing,  Up: Implementation Defined Pragmas

2.114 Pragma No_Tagged_Streams
==============================

Syntax:

     pragma No_Tagged_Streams [([Entity =>] tagged_type_LOCAL_NAME)];

Normally when a tagged type is introduced using a full type declaration,
part of the processing includes generating stream access routines to be
used by stream attributes referencing the type (or one of its subtypes
or derived types).  This can involve the generation of significant
amounts of code which is wasted space if stream routines are not needed
for the type in question.

The ‘No_Tagged_Streams’ pragma causes the generation of these stream
routines to be skipped, and any attempt to use stream operations on
types subject to this pragma will be statically rejected as illegal.

There are two forms of the pragma.  The form with no arguments must
appear in a declarative sequence or in the declarations of a package
spec.  This pragma affects all subsequent root tagged types declared in
the declaration sequence, and specifies that no stream routines be
generated.  The form with an argument (for which there is also a
corresponding aspect) specifies a single root tagged type for which
stream routines are not to be generated.

Once the pragma has been given for a particular root tagged type, all
subtypes and derived types of this type inherit the pragma
automatically, so the effect applies to a complete hierarchy (this is
necessary to deal with the class-wide dispatching versions of the stream
routines).

When pragmas ‘Discard_Names’ and ‘No_Tagged_Streams’ are simultaneously
applied to a tagged type its Expanded_Name and External_Tag are
initialized with empty strings.  This is useful to avoid exposing entity
names at binary level but has a negative impact on the debuggability of
tagged types.


File: gnat_rm.info,  Node: Pragma Normalize_Scalars,  Next: Pragma Obsolescent,  Prev: Pragma No_Tagged_Streams,  Up: Implementation Defined Pragmas

2.115 Pragma Normalize_Scalars
==============================

Syntax:

     pragma Normalize_Scalars;

This is a language defined pragma which is fully implemented in GNAT.
The effect is to cause all scalar objects that are not otherwise
initialized to be initialized.  The initial values are implementation
dependent and are as follows:

`Standard.Character'

     Objects whose root type is Standard.Character are initialized to
     Character’Last unless the subtype range excludes NUL (in which case
     NUL is used).  This choice will always generate an invalid value if
     one exists.

`Standard.Wide_Character'

     Objects whose root type is Standard.Wide_Character are initialized
     to Wide_Character’Last unless the subtype range excludes NUL (in
     which case NUL is used).  This choice will always generate an
     invalid value if one exists.

`Standard.Wide_Wide_Character'

     Objects whose root type is Standard.Wide_Wide_Character are
     initialized to the invalid value 16#FFFF_FFFF# unless the subtype
     range excludes NUL (in which case NUL is used).  This choice will
     always generate an invalid value if one exists.

`Integer types'

     Objects of an integer type are treated differently depending on
     whether negative values are present in the subtype.  If no negative
     values are present, then all one bits is used as the initial value
     except in the special case where zero is excluded from the subtype,
     in which case all zero bits are used.  This choice will always
     generate an invalid value if one exists.

     For subtypes with negative values present, the largest negative
     number is used, except in the unusual case where this largest
     negative number is in the subtype, and the largest positive number
     is not, in which case the largest positive value is used.  This
     choice will always generate an invalid value if one exists.

`Floating-Point Types'

     Objects of all floating-point types are initialized to all 1-bits.
     For standard IEEE format, this corresponds to a NaN (not a number)
     which is indeed an invalid value.

`Fixed-Point Types'

     Objects of all fixed-point types are treated as described above for
     integers, with the rules applying to the underlying integer value
     used to represent the fixed-point value.

`Modular types'

     Objects of a modular type are initialized to all one bits, except
     in the special case where zero is excluded from the subtype, in
     which case all zero bits are used.  This choice will always
     generate an invalid value if one exists.

`Enumeration types'

     Objects of an enumeration type are initialized to all one-bits,
     i.e., to the value ‘2 ** typ'Size - 1’ unless the subtype excludes
     the literal whose Pos value is zero, in which case a code of zero
     is used.  This choice will always generate an invalid value if one
     exists.


File: gnat_rm.info,  Node: Pragma Obsolescent,  Next: Pragma Optimize_Alignment,  Prev: Pragma Normalize_Scalars,  Up: Implementation Defined Pragmas

2.116 Pragma Obsolescent
========================

Syntax:

     pragma Obsolescent;

     pragma Obsolescent (
       [Message =>] static_string_EXPRESSION
     [,[Version =>] Ada_05]]);

     pragma Obsolescent (
       [Entity  =>] NAME
     [,[Message =>] static_string_EXPRESSION
     [,[Version =>] Ada_05]] );

This pragma can occur immediately following a declaration of an entity,
including the case of a record component.  If no Entity argument is
present, then this declaration is the one to which the pragma applies.
If an Entity parameter is present, it must either match the name of the
entity in this declaration, or alternatively, the pragma can immediately
follow an enumeration type declaration, where the Entity argument names
one of the enumeration literals.

This pragma is used to indicate that the named entity is considered
obsolescent and should not be used.  Typically this is used when an API
must be modified by eventually removing or modifying existing
subprograms or other entities.  The pragma can be used at an
intermediate stage when the entity is still present, but will be removed
later.

The effect of this pragma is to output a warning message on a reference
to an entity thus marked that the subprogram is obsolescent if the
appropriate warning option in the compiler is activated.  If the
‘Message’ parameter is present, then a second warning message is given
containing this text.  In addition, a reference to the entity is
considered to be a violation of pragma ‘Restrictions
(No_Obsolescent_Features)’.

This pragma can also be used as a program unit pragma for a package, in
which case the entity name is the name of the package, and the pragma
indicates that the entire package is considered obsolescent.  In this
case a client ‘with’ing such a package violates the restriction, and the
‘with’ clause is flagged with warnings if the warning option is set.

If the ‘Version’ parameter is present (which must be exactly the
identifier ‘Ada_05’, no other argument is allowed), then the indication
of obsolescence applies only when compiling in Ada 2005 mode.  This is
primarily intended for dealing with the situations in the predefined
library where subprograms or packages have become defined as obsolescent
in Ada 2005 (e.g., in ‘Ada.Characters.Handling’), but may be used
anywhere.

The following examples show typical uses of this pragma:

     package p is
        pragma Obsolescent (p, Message => "use pp instead of p");
     end p;

     package q is
        procedure q2;
        pragma Obsolescent ("use q2new instead");

        type R is new integer;
        pragma Obsolescent
          (Entity  => R,
           Message => "use RR in Ada 2005",
           Version => Ada_05);

        type M is record
           F1 : Integer;
           F2 : Integer;
           pragma Obsolescent;
           F3 : Integer;
        end record;

        type E is (a, bc, 'd', quack);
        pragma Obsolescent (Entity => bc)
        pragma Obsolescent (Entity => 'd')

        function "+"
          (a, b : character) return character;
        pragma Obsolescent (Entity => "+");
     end;

Note that, as for all pragmas, if you use a pragma argument identifier,
then all subsequent parameters must also use a pragma argument
identifier.  So if you specify ‘Entity =>’ for the ‘Entity’ argument,
and a ‘Message’ argument is present, it must be preceded by ‘Message
=>’.


File: gnat_rm.info,  Node: Pragma Optimize_Alignment,  Next: Pragma Ordered,  Prev: Pragma Obsolescent,  Up: Implementation Defined Pragmas

2.117 Pragma Optimize_Alignment
===============================

Syntax:

     pragma Optimize_Alignment (TIME | SPACE | OFF);

This is a configuration pragma which affects the choice of default
alignments for types and objects where no alignment is explicitly
specified.  There is a time/space trade-off in the selection of these
values.  Large alignments result in more efficient code, at the expense
of larger data space, since sizes have to be increased to match these
alignments.  Smaller alignments save space, but the access code is
slower.  The normal choice of default alignments for types and
individual alignment promotions for objects (which is what you get if
you do not use this pragma, or if you use an argument of OFF), tries to
balance these two requirements.

Specifying SPACE causes smaller default alignments to be chosen in two
cases.  First any packed record is given an alignment of 1.  Second, if
a size is given for the type, then the alignment is chosen to avoid
increasing this size.  For example, consider:

     type R is record
        X : Integer;
        Y : Character;
     end record;

     for R'Size use 5*8;

In the default mode, this type gets an alignment of 4, so that access to
the Integer field X are efficient.  But this means that objects of the
type end up with a size of 8 bytes.  This is a valid choice, since sizes
of objects are allowed to be bigger than the size of the type, but it
can waste space if for example fields of type R appear in an enclosing
record.  If the above type is compiled in ‘Optimize_Alignment (Space)’
mode, the alignment is set to 1.

However, there is one case in which SPACE is ignored.  If a variable
length record (that is a discriminated record with a component which is
an array whose length depends on a discriminant), has a pragma Pack,
then it is not in general possible to set the alignment of such a record
to one, so the pragma is ignored in this case (with a warning).

Specifying SPACE also disables alignment promotions for standalone
objects, which occur when the compiler increases the alignment of a
specific object without changing the alignment of its type.

Specifying SPACE also disables component reordering in unpacked record
types, which can result in larger sizes in order to meet alignment
requirements.

Specifying TIME causes larger default alignments to be chosen in the
case of small types with sizes that are not a power of 2.  For example,
consider:

     type R is record
        A : Character;
        B : Character;
        C : Boolean;
     end record;

     pragma Pack (R);
     for R'Size use 17;

The default alignment for this record is normally 1, but if this type is
compiled in ‘Optimize_Alignment (Time)’ mode, then the alignment is set
to 4, which wastes space for objects of the type, since they are now 4
bytes long, but results in more efficient access when the whole record
is referenced.

As noted above, this is a configuration pragma, and there is a
requirement that all units in a partition be compiled with a consistent
setting of the optimization setting.  This would normally be achieved by
use of a configuration pragma file containing the appropriate setting.
The exception to this rule is that units with an explicit configuration
pragma in the same file as the source unit are excluded from the
consistency check, as are all predefined units.  The latter are compiled
by default in pragma Optimize_Alignment (Off) mode if no pragma appears
at the start of the file.


File: gnat_rm.info,  Node: Pragma Ordered,  Next: Pragma Overflow_Mode,  Prev: Pragma Optimize_Alignment,  Up: Implementation Defined Pragmas

2.118 Pragma Ordered
====================

Syntax:

     pragma Ordered (enumeration_first_subtype_LOCAL_NAME);

Most enumeration types are from a conceptual point of view unordered.
For example, consider:

     type Color is (Red, Blue, Green, Yellow);

By Ada semantics ‘Blue > Red’ and ‘Green > Blue’, but really these
relations make no sense; the enumeration type merely specifies a set of
possible colors, and the order is unimportant.

For unordered enumeration types, it is generally a good idea if clients
avoid comparisons (other than equality or inequality) and explicit
ranges.  (A `client' is a unit where the type is referenced, other than
the unit where the type is declared, its body, and its subunits.)  For
example, if code buried in some client says:

     if Current_Color < Yellow then ...
     if Current_Color in Blue .. Green then ...

then the client code is relying on the order, which is undesirable.  It
makes the code hard to read and creates maintenance difficulties if
entries have to be added to the enumeration type.  Instead, the code in
the client should list the possibilities, or an appropriate subtype
should be declared in the unit that declares the original enumeration
type.  E.g., the following subtype could be declared along with the type
‘Color’:

     subtype RBG is Color range Red .. Green;

and then the client could write:

     if Current_Color in RBG then ...
     if Current_Color = Blue or Current_Color = Green then ...

However, some enumeration types are legitimately ordered from a
conceptual point of view.  For example, if you declare:

     type Day is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);

then the ordering imposed by the language is reasonable, and clients can
depend on it, writing for example:

     if D in Mon .. Fri then ...
     if D < Wed then ...

The pragma `Ordered' is provided to mark enumeration types that are
conceptually ordered, alerting the reader that clients may depend on the
ordering.  GNAT provides a pragma to mark enumerations as ordered rather
than one to mark them as unordered, since in our experience, the great
majority of enumeration types are conceptually unordered.

The types ‘Boolean’, ‘Character’, ‘Wide_Character’, and
‘Wide_Wide_Character’ are considered to be ordered types, so each is
declared with a pragma ‘Ordered’ in package ‘Standard’.

Normally pragma ‘Ordered’ serves only as documentation and a guide for
coding standards, but GNAT provides a warning switch `-gnatw.u' that
requests warnings for inappropriate uses (comparisons and explicit
subranges) for unordered types.  If this switch is used, then any
enumeration type not marked with pragma ‘Ordered’ will be considered as
unordered, and will generate warnings for inappropriate uses.

Note that generic types are not considered ordered or unordered (since
the template can be instantiated for both cases), so we never generate
warnings for the case of generic enumerated types.

For additional information please refer to the description of the
`-gnatw.u' switch in the GNAT User’s Guide.


File: gnat_rm.info,  Node: Pragma Overflow_Mode,  Next: Pragma Overriding_Renamings,  Prev: Pragma Ordered,  Up: Implementation Defined Pragmas

2.119 Pragma Overflow_Mode
==========================

Syntax:

     pragma Overflow_Mode
      (  [General    =>] MODE
       [,[Assertions =>] MODE]);

     MODE ::= STRICT | MINIMIZED | ELIMINATED

This pragma sets the current overflow mode to the given setting.  For
details of the meaning of these modes, please refer to the ‘Overflow
Check Handling in GNAT’ appendix in the GNAT User’s Guide.  If only the
‘General’ parameter is present, the given mode applies to all
expressions.  If both parameters are present, the ‘General’ mode applies
to expressions outside assertions, and the ‘Eliminated’ mode applies to
expressions within assertions.

The case of the ‘MODE’ parameter is ignored, so ‘MINIMIZED’, ‘Minimized’
and ‘minimized’ all have the same effect.

The ‘Overflow_Mode’ pragma has the same scoping and placement rules as
pragma ‘Suppress’, so it can occur either as a configuration pragma,
specifying a default for the whole program, or in a declarative scope,
where it applies to the remaining declarations and statements in that
scope.

The pragma ‘Suppress (Overflow_Check)’ suppresses overflow checking, but
does not affect the overflow mode.

The pragma ‘Unsuppress (Overflow_Check)’ unsuppresses (enables) overflow
checking, but does not affect the overflow mode.


File: gnat_rm.info,  Node: Pragma Overriding_Renamings,  Next: Pragma Partition_Elaboration_Policy,  Prev: Pragma Overflow_Mode,  Up: Implementation Defined Pragmas

2.120 Pragma Overriding_Renamings
=================================

Syntax:

     pragma Overriding_Renamings;

This is a GNAT configuration pragma to simplify porting legacy code
accepted by the Rational Ada compiler.  In the presence of this pragma,
a renaming declaration that renames an inherited operation declared in
the same scope is legal if selected notation is used as in:

     pragma Overriding_Renamings;
     ...
     package R is
       function F (..);
       ...
       function F (..) renames R.F;
     end R;

even though RM 8.3 (15) stipulates that an overridden operation is not
visible within the declaration of the overriding operation.


File: gnat_rm.info,  Node: Pragma Partition_Elaboration_Policy,  Next: Pragma Part_Of,  Prev: Pragma Overriding_Renamings,  Up: Implementation Defined Pragmas

2.121 Pragma Partition_Elaboration_Policy
=========================================

Syntax:

     pragma Partition_Elaboration_Policy (POLICY_IDENTIFIER);

     POLICY_IDENTIFIER ::= Concurrent | Sequential

This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Part_Of,  Next: Pragma Passive,  Prev: Pragma Partition_Elaboration_Policy,  Up: Implementation Defined Pragmas

2.122 Pragma Part_Of
====================

Syntax:

     pragma Part_Of (ABSTRACT_STATE);

     ABSTRACT_STATE ::= NAME

For the semantics of this pragma, see the entry for aspect ‘Part_Of’ in
the SPARK 2014 Reference Manual, section 7.2.6.


File: gnat_rm.info,  Node: Pragma Passive,  Next: Pragma Persistent_BSS,  Prev: Pragma Part_Of,  Up: Implementation Defined Pragmas

2.123 Pragma Passive
====================

Syntax:

     pragma Passive [(Semaphore | No)];

Syntax checked, but otherwise ignored by GNAT. This is recognized for
compatibility with DEC Ada 83 implementations, where it is used within a
task definition to request that a task be made passive.  If the argument
‘Semaphore’ is present, or the argument is omitted, then DEC Ada 83
treats the pragma as an assertion that the containing task is passive
and that optimization of context switch with this task is permitted and
desired.  If the argument ‘No’ is present, the task must not be
optimized.  GNAT does not attempt to optimize any tasks in this manner
(since protected objects are available in place of passive tasks).

For more information on the subject of passive tasks, see the section
‘Passive Task Optimization’ in the GNAT Users Guide.


File: gnat_rm.info,  Node: Pragma Persistent_BSS,  Next: Pragma Post,  Prev: Pragma Passive,  Up: Implementation Defined Pragmas

2.124 Pragma Persistent_BSS
===========================

Syntax:

     pragma Persistent_BSS [(LOCAL_NAME)]

This pragma allows selected objects to be placed in the
‘.persistent_bss’ section.  On some targets the linker and loader
provide for special treatment of this section, allowing a program to be
reloaded without affecting the contents of this data (hence the name
persistent).

There are two forms of usage.  If an argument is given, it must be the
local name of a library-level object, with no explicit initialization
and whose type is potentially persistent.  If no argument is given, then
the pragma is a configuration pragma, and applies to all library-level
objects with no explicit initialization of potentially persistent types.

A potentially persistent type is a scalar type, or an untagged,
non-discriminated record, all of whose components have no explicit
initialization and are themselves of a potentially persistent type, or
an array, all of whose constraints are static, and whose component type
is potentially persistent.

If this pragma is used on a target where this feature is not supported,
then the pragma will be ignored.  See also ‘pragma Linker_Section’.


File: gnat_rm.info,  Node: Pragma Post,  Next: Pragma Postcondition,  Prev: Pragma Persistent_BSS,  Up: Implementation Defined Pragmas

2.125 Pragma Post
=================

Syntax:

     pragma Post (Boolean_Expression);

The ‘Post’ pragma is intended to be an exact replacement for the
language-defined ‘Post’ aspect, and shares its restrictions and
semantics.  It must appear either immediately following the
corresponding subprogram declaration (only other pragmas may intervene),
or if there is no separate subprogram declaration, then it can appear at
the start of the declarations in a subprogram body (preceded only by
other pragmas).


File: gnat_rm.info,  Node: Pragma Postcondition,  Next: Pragma Post_Class,  Prev: Pragma Post,  Up: Implementation Defined Pragmas

2.126 Pragma Postcondition
==========================

Syntax:

     pragma Postcondition (
        [Check   =>] Boolean_Expression
      [,[Message =>] String_Expression]);

The ‘Postcondition’ pragma allows specification of automatic
postcondition checks for subprograms.  These checks are similar to
assertions, but are automatically inserted just prior to the return
statements of the subprogram with which they are associated (including
implicit returns at the end of procedure bodies and associated exception
handlers).

In addition, the boolean expression which is the condition which must be
true may contain references to function’Result in the case of a function
to refer to the returned value.

‘Postcondition’ pragmas may appear either immediately following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body.  Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the declaration
sequence in a subprogram body).  In the case of a postcondition
appearing after a subprogram declaration, the formal arguments of the
subprogram are visible, and can be referenced in the postcondition
expressions.

The postconditions are collected and automatically tested just before
any return (implicit or explicit) in the subprogram body.  A
postcondition is only recognized if postconditions are active at the
time the pragma is encountered.  The compiler switch `gnata' turns on
all postconditions by default, and pragma ‘Check_Policy’ with an
identifier of ‘Postcondition’ can also be used to control whether
postconditions are active.

The general approach is that postconditions are placed in the spec if
they represent functional aspects which make sense to the client.  For
example we might have:

     function Direction return Integer;
     pragma Postcondition
      (Direction'Result = +1
         or else
       Direction'Result = -1);

which serves to document that the result must be +1 or -1, and will test
that this is the case at run time if postcondition checking is active.

Postconditions within the subprogram body can be used to check that some
internal aspect of the implementation, not visible to the client, is
operating as expected.  For instance if a square root routine keeps an
internal counter of the number of times it is called, then we might have
the following postcondition:

     Sqrt_Calls : Natural := 0;

     function Sqrt (Arg : Float) return Float is
       pragma Postcondition
         (Sqrt_Calls = Sqrt_Calls'Old + 1);
       ...
     end Sqrt

As this example, shows, the use of the ‘Old’ attribute is often useful
in postconditions to refer to the state on entry to the subprogram.

Note that postconditions are only checked on normal returns from the
subprogram.  If an abnormal return results from raising an exception,
then the postconditions are not checked.

If a postcondition fails, then the exception
‘System.Assertions.Assert_Failure’ is raised.  If a message argument was
supplied, then the given string will be used as the exception message.
If no message argument was supplied, then the default message has the
form “Postcondition failed at file_name:line”.  The exception is raised
in the context of the subprogram body, so it is possible to catch
postcondition failures within the subprogram body itself.

Within a package spec, normal visibility rules in Ada would prevent
forward references within a postcondition pragma to functions defined
later in the same package.  This would introduce undesirable ordering
constraints.  To avoid this problem, all postcondition pragmas are
analyzed at the end of the package spec, allowing forward references.

The following example shows that this even allows mutually recursive
postconditions as in:

     package Parity_Functions is
        function Odd  (X : Natural) return Boolean;
        pragma Postcondition
          (Odd'Result =
             (x = 1
               or else
             (x /= 0 and then Even (X - 1))));

        function Even (X : Natural) return Boolean;
        pragma Postcondition
          (Even'Result =
             (x = 0
               or else
             (x /= 1 and then Odd (X - 1))));

     end Parity_Functions;

There are no restrictions on the complexity or form of conditions used
within ‘Postcondition’ pragmas.  The following example shows that it is
even possible to verify performance behavior.

     package Sort is

        Performance : constant Float;
        --  Performance constant set by implementation
        --  to match target architecture behavior.

        procedure Treesort (Arg : String);
        --  Sorts characters of argument using N*logN sort
        pragma Postcondition
          (Float (Clock - Clock'Old) <=
             Float (Arg'Length) *
             log (Float (Arg'Length)) *
             Performance);
     end Sort;

Note: postcondition pragmas associated with subprograms that are marked
as Inline_Always, or those marked as Inline with front-end inlining
(-gnatN option set) are accepted and legality-checked by the compiler,
but are ignored at run-time even if postcondition checking is enabled.

Note that pragma ‘Postcondition’ differs from the language-defined
‘Post’ aspect (and corresponding ‘Post’ pragma) in allowing multiple
occurrences, allowing occurences in the body even if there is a separate
spec, and allowing a second string parameter, and the use of the pragma
identifier ‘Check’.  Historically, pragma ‘Postcondition’ was
implemented prior to the development of Ada 2012, and has been retained
in its original form for compatibility purposes.


File: gnat_rm.info,  Node: Pragma Post_Class,  Next: Pragma Pre,  Prev: Pragma Postcondition,  Up: Implementation Defined Pragmas

2.127 Pragma Post_Class
=======================

Syntax:

     pragma Post_Class (Boolean_Expression);

The ‘Post_Class’ pragma is intended to be an exact replacement for the
language-defined ‘Post'Class’ aspect, and shares its restrictions and
semantics.  It must appear either immediately following the
corresponding subprogram declaration (only other pragmas may intervene),
or if there is no separate subprogram declaration, then it can appear at
the start of the declarations in a subprogram body (preceded only by
other pragmas).

Note: This pragma is called ‘Post_Class’ rather than ‘Post'Class’
because the latter would not be strictly conforming to the allowed
syntax for pragmas.  The motivation for provinding pragmas equivalent to
the aspects is to allow a program to be written using the pragmas, and
then compiled if necessary using an Ada compiler that does not recognize
the pragmas or aspects, but is prepared to ignore the pragmas.  The
assertion policy that controls this pragma is ‘Post'Class’, not
‘Post_Class’.


File: gnat_rm.info,  Node: Pragma Pre,  Next: Pragma Precondition,  Prev: Pragma Post_Class,  Up: Implementation Defined Pragmas

2.128 Pragma Pre
================

Syntax:

     pragma Pre (Boolean_Expression);

The ‘Pre’ pragma is intended to be an exact replacement for the
language-defined ‘Pre’ aspect, and shares its restrictions and
semantics.  It must appear either immediately following the
corresponding subprogram declaration (only other pragmas may intervene),
or if there is no separate subprogram declaration, then it can appear at
the start of the declarations in a subprogram body (preceded only by
other pragmas).


File: gnat_rm.info,  Node: Pragma Precondition,  Next: Pragma Predicate,  Prev: Pragma Pre,  Up: Implementation Defined Pragmas

2.129 Pragma Precondition
=========================

Syntax:

     pragma Precondition (
        [Check   =>] Boolean_Expression
      [,[Message =>] String_Expression]);

The ‘Precondition’ pragma is similar to ‘Postcondition’ except that the
corresponding checks take place immediately upon entry to the
subprogram, and if a precondition fails, the exception is raised in the
context of the caller, and the attribute ‘Result cannot be used within
the precondition expression.

Otherwise, the placement and visibility rules are identical to those
described for postconditions.  The following is an example of use within
a package spec:

     package Math_Functions is
        ...
        function Sqrt (Arg : Float) return Float;
        pragma Precondition (Arg >= 0.0)
        ...
     end Math_Functions;

‘Precondition’ pragmas may appear either immediately following the
(separate) declaration of a subprogram, or at the start of the
declarations of a subprogram body.  Only other pragmas may intervene
(that is appear between the subprogram declaration and its
postconditions, or appear before the postcondition in the declaration
sequence in a subprogram body).

Note: precondition pragmas associated with subprograms that are marked
as Inline_Always, or those marked as Inline with front-end inlining
(-gnatN option set) are accepted and legality-checked by the compiler,
but are ignored at run-time even if precondition checking is enabled.

Note that pragma ‘Precondition’ differs from the language-defined ‘Pre’
aspect (and corresponding ‘Pre’ pragma) in allowing multiple
occurrences, allowing occurences in the body even if there is a separate
spec, and allowing a second string parameter, and the use of the pragma
identifier ‘Check’.  Historically, pragma ‘Precondition’ was implemented
prior to the development of Ada 2012, and has been retained in its
original form for compatibility purposes.


File: gnat_rm.info,  Node: Pragma Predicate,  Next: Pragma Predicate_Failure,  Prev: Pragma Precondition,  Up: Implementation Defined Pragmas

2.130 Pragma Predicate
======================

Syntax:

     pragma Predicate
       ([Entity =>] type_LOCAL_NAME,
        [Check  =>] EXPRESSION);

This pragma (available in all versions of Ada in GNAT) encompasses both
the ‘Static_Predicate’ and ‘Dynamic_Predicate’ aspects in Ada 2012.  A
predicate is regarded as static if it has an allowed form for
‘Static_Predicate’ and is otherwise treated as a ‘Dynamic_Predicate’.
Otherwise, predicates specified by this pragma behave exactly as
described in the Ada 2012 reference manual.  For example, if we have

     type R is range 1 .. 10;
     subtype S is R;
     pragma Predicate (Entity => S, Check => S not in 4 .. 6);
     subtype Q is R
     pragma Predicate (Entity => Q, Check => F(Q) or G(Q));

the effect is identical to the following Ada 2012 code:

     type R is range 1 .. 10;
     subtype S is R with
       Static_Predicate => S not in 4 .. 6;
     subtype Q is R with
       Dynamic_Predicate => F(Q) or G(Q);

Note that there are no pragmas ‘Dynamic_Predicate’ or
‘Static_Predicate’.  That is because these pragmas would affect legality
and semantics of the program and thus do not have a neutral effect if
ignored.  The motivation behind providing pragmas equivalent to
corresponding aspects is to allow a program to be written using the
pragmas, and then compiled with a compiler that will ignore the pragmas.
That doesn’t work in the case of static and dynamic predicates, since if
the corresponding pragmas are ignored, then the behavior of the program
is fundamentally changed (for example a membership test ‘A in B’ would
not take into account a predicate defined for subtype B). When following
this approach, the use of predicates should be avoided.


File: gnat_rm.info,  Node: Pragma Predicate_Failure,  Next: Pragma Preelaborable_Initialization,  Prev: Pragma Predicate,  Up: Implementation Defined Pragmas

2.131 Pragma Predicate_Failure
==============================

Syntax:

     pragma Predicate_Failure
       ([Entity  =>] type_LOCAL_NAME,
        [Message =>] String_Expression);

The ‘Predicate_Failure’ pragma is intended to be an exact replacement
for the language-defined ‘Predicate_Failure’ aspect, and shares its
restrictions and semantics.


File: gnat_rm.info,  Node: Pragma Preelaborable_Initialization,  Next: Pragma Prefix_Exception_Messages,  Prev: Pragma Predicate_Failure,  Up: Implementation Defined Pragmas

2.132 Pragma Preelaborable_Initialization
=========================================

Syntax:

     pragma Preelaborable_Initialization (DIRECT_NAME);

This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Prefix_Exception_Messages,  Next: Pragma Pre_Class,  Prev: Pragma Preelaborable_Initialization,  Up: Implementation Defined Pragmas

2.133 Pragma Prefix_Exception_Messages
======================================

Syntax:

     pragma Prefix_Exception_Messages;

This is an implementation-defined configuration pragma that affects the
behavior of raise statements with a message given as a static string
constant (typically a string literal).  In such cases, the string will
be automatically prefixed by the name of the enclosing entity (giving
the package and subprogram containing the raise statement).  This helps
to identify where messages are coming from, and this mode is automatic
for the run-time library.

The pragma has no effect if the message is computed with an expression
other than a static string constant, since the assumption in this case
is that the program computes exactly the string it wants.  If you still
want the prefixing in this case, you can always call
‘GNAT.Source_Info.Enclosing_Entity’ and prepend the string manually.


File: gnat_rm.info,  Node: Pragma Pre_Class,  Next: Pragma Priority_Specific_Dispatching,  Prev: Pragma Prefix_Exception_Messages,  Up: Implementation Defined Pragmas

2.134 Pragma Pre_Class
======================

Syntax:

     pragma Pre_Class (Boolean_Expression);

The ‘Pre_Class’ pragma is intended to be an exact replacement for the
language-defined ‘Pre'Class’ aspect, and shares its restrictions and
semantics.  It must appear either immediately following the
corresponding subprogram declaration (only other pragmas may intervene),
or if there is no separate subprogram declaration, then it can appear at
the start of the declarations in a subprogram body (preceded only by
other pragmas).

Note: This pragma is called ‘Pre_Class’ rather than ‘Pre'Class’ because
the latter would not be strictly conforming to the allowed syntax for
pragmas.  The motivation for providing pragmas equivalent to the aspects
is to allow a program to be written using the pragmas, and then compiled
if necessary using an Ada compiler that does not recognize the pragmas
or aspects, but is prepared to ignore the pragmas.  The assertion policy
that controls this pragma is ‘Pre'Class’, not ‘Pre_Class’.


File: gnat_rm.info,  Node: Pragma Priority_Specific_Dispatching,  Next: Pragma Profile,  Prev: Pragma Pre_Class,  Up: Implementation Defined Pragmas

2.135 Pragma Priority_Specific_Dispatching
==========================================

Syntax:

     pragma Priority_Specific_Dispatching (
        POLICY_IDENTIFIER,
        first_priority_EXPRESSION,
        last_priority_EXPRESSION)

     POLICY_IDENTIFIER ::=
        EDF_Across_Priorities            |
        FIFO_Within_Priorities           |
        Non_Preemptive_Within_Priorities |
        Round_Robin_Within_Priorities

This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Profile,  Next: Pragma Profile_Warnings,  Prev: Pragma Priority_Specific_Dispatching,  Up: Implementation Defined Pragmas

2.136 Pragma Profile
====================

Syntax:

     pragma Profile (Ravenscar | Restricted | Rational | Jorvik |
                     GNAT_Extended_Ravenscar | GNAT_Ravenscar_EDF );

This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.  This is a
configuration pragma that establishes a set of configuration pragmas
that depend on the argument.  ‘Ravenscar’ is standard in Ada 2005.
‘Jorvik’ is standard in Ada 202x.  The other possibilities
(‘Restricted’, ‘Rational’, ‘GNAT_Extended_Ravenscar’,
‘GNAT_Ravenscar_EDF’) are implementation-defined.
‘GNAT_Extended_Ravenscar’ is an alias for ‘Jorvik’.

The set of configuration pragmas is defined in the following sections.

   * Pragma Profile (Ravenscar)

     The ‘Ravenscar’ profile is standard in Ada 2005, but is available
     in all earlier versions of Ada as an implementation-defined pragma.
     This profile establishes the following set of configuration
     pragmas:

        * ‘Task_Dispatching_Policy (FIFO_Within_Priorities)’

          [RM D.2.2] Tasks are dispatched following a preemptive
          priority-ordered scheduling policy.

        * ‘Locking_Policy (Ceiling_Locking)’

          [RM D.3] While tasks and interrupts execute a protected
          action, they inherit the ceiling priority of the corresponding
          protected object.

        * ‘Detect_Blocking’

          This pragma forces the detection of potentially blocking
          operations within a protected operation, and to raise
          Program_Error if that happens.

     plus the following set of restrictions:

        * ‘Max_Entry_Queue_Length => 1’

          No task can be queued on a protected entry.

        * ‘Max_Protected_Entries => 1’

        * ‘Max_Task_Entries => 0’

          No rendezvous statements are allowed.

        * ‘No_Abort_Statements’

        * ‘No_Dynamic_Attachment’

        * ‘No_Dynamic_Priorities’

        * ‘No_Implicit_Heap_Allocations’

        * ‘No_Local_Protected_Objects’

        * ‘No_Local_Timing_Events’

        * ‘No_Protected_Type_Allocators’

        * ‘No_Relative_Delay’

        * ‘No_Requeue_Statements’

        * ‘No_Select_Statements’

        * ‘No_Specific_Termination_Handlers’

        * ‘No_Task_Allocators’

        * ‘No_Task_Hierarchy’

        * ‘No_Task_Termination’

        * ‘Simple_Barriers’

     The Ravenscar profile also includes the following restrictions that
     specify that there are no semantic dependencies on the
     corresponding predefined packages:

        * ‘No_Dependence => Ada.Asynchronous_Task_Control’

        * ‘No_Dependence => Ada.Calendar’

        * ‘No_Dependence => Ada.Execution_Time.Group_Budget’

        * ‘No_Dependence => Ada.Execution_Time.Timers’

        * ‘No_Dependence => Ada.Task_Attributes’

        * ‘No_Dependence => System.Multiprocessors.Dispatching_Domains’

     This set of configuration pragmas and restrictions correspond to
     the definition of the ‘Ravenscar Profile’ for limited tasking,
     devised and published by the ‘International Real-Time Ada Workshop,
     1997’.  A description is also available at
     ‘http://www-users.cs.york.ac.uk/~burns/ravenscar.ps’.

     The original definition of the profile was revised at subsequent
     IRTAW meetings.  It has been included in the ISO ‘Guide for the Use
     of the Ada Programming Language in High Integrity Systems’, and was
     made part of the Ada 2005 standard.  The formal definition given by
     the Ada Rapporteur Group (ARG) can be found in two Ada Issues
     (AI-249 and AI-305) available at
     ‘http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00249.txt’ and
     ‘http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ais/ai-00305.txt’.

     The above set is a superset of the restrictions provided by pragma
     ‘Profile (Restricted)’, it includes six additional restrictions
     (‘Simple_Barriers’, ‘No_Select_Statements’, ‘No_Calendar’,
     ‘No_Implicit_Heap_Allocations’, ‘No_Relative_Delay’ and
     ‘No_Task_Termination’).  This means that pragma ‘Profile
     (Ravenscar)’, like the pragma ‘Profile (Restricted)’, automatically
     causes the use of a simplified, more efficient version of the
     tasking run-time library.

   * Pragma Profile (Jorvik)

     ‘Jorvik’ is the new profile added to the Ada 202x draft standard,
     previously implemented under the name ‘GNAT_Extended_Ravenscar’.

     The ‘No_Implicit_Heap_Allocations’ restriction has been replaced by
     ‘No_Implicit_Task_Allocations’ and
     ‘No_Implicit_Protected_Object_Allocations’.

     The ‘Simple_Barriers’ restriction has been replaced by
     ‘Pure_Barriers’.

     The ‘Max_Protected_Entries’, ‘Max_Entry_Queue_Length’, and
     ‘No_Relative_Delay’ restrictions have been removed.

     Details on the rationale for ‘Jorvik’ and implications for use may
     be found in ‘A New Ravenscar-Based Profile’ by P. Rogers, J. Ruiz,
     T. Gingold and P. Bernardi, in ‘Reliable Software Technologies –
     Ada Europe 2017’, Springer-Verlag Lecture Notes in Computer
     Science, Number 10300.

   * Pragma Profile (GNAT_Ravenscar_EDF)

     This profile corresponds to the Ravenscar profile but using
     EDF_Across_Priority as the Task_Scheduling_Policy.

   * Pragma Profile (Restricted)

     This profile corresponds to the GNAT restricted run time.  It
     establishes the following set of restrictions:

        * ‘No_Abort_Statements’

        * ‘No_Entry_Queue’

        * ‘No_Task_Hierarchy’

        * ‘No_Task_Allocators’

        * ‘No_Dynamic_Priorities’

        * ‘No_Terminate_Alternatives’

        * ‘No_Dynamic_Attachment’

        * ‘No_Protected_Type_Allocators’

        * ‘No_Local_Protected_Objects’

        * ‘No_Requeue_Statements’

        * ‘No_Task_Attributes_Package’

        * ‘Max_Asynchronous_Select_Nesting = 0’

        * ‘Max_Task_Entries = 0’

        * ‘Max_Protected_Entries = 1’

        * ‘Max_Select_Alternatives = 0’

     This set of restrictions causes the automatic selection of a
     simplified version of the run time that provides improved
     performance for the limited set of tasking functionality permitted
     by this set of restrictions.

   * Pragma Profile (Rational)

     The Rational profile is intended to facilitate porting legacy code
     that compiles with the Rational APEX compiler, even when the code
     includes non- conforming Ada constructs.  The profile enables the
     following three pragmas:

        * ‘pragma Implicit_Packing’

        * ‘pragma Overriding_Renamings’

        * ‘pragma Use_VADS_Size’


File: gnat_rm.info,  Node: Pragma Profile_Warnings,  Next: Pragma Propagate_Exceptions,  Prev: Pragma Profile,  Up: Implementation Defined Pragmas

2.137 Pragma Profile_Warnings
=============================

Syntax:

     pragma Profile_Warnings (Ravenscar | Restricted | Rational);

This is an implementation-defined pragma that is similar in effect to
‘pragma Profile’ except that instead of generating ‘Restrictions’
pragmas, it generates ‘Restriction_Warnings’ pragmas.  The result is
that violations of the profile generate warning messages instead of
error messages.


File: gnat_rm.info,  Node: Pragma Propagate_Exceptions,  Next: Pragma Provide_Shift_Operators,  Prev: Pragma Profile_Warnings,  Up: Implementation Defined Pragmas

2.138 Pragma Propagate_Exceptions
=================================

Syntax:

     pragma Propagate_Exceptions;

This pragma is now obsolete and, other than generating a warning if
warnings on obsolescent features are enabled, is ignored.  It is
retained for compatibility purposes.  It used to be used in connection
with optimization of a now-obsolete mechanism for implementation of
exceptions.


File: gnat_rm.info,  Node: Pragma Provide_Shift_Operators,  Next: Pragma Psect_Object,  Prev: Pragma Propagate_Exceptions,  Up: Implementation Defined Pragmas

2.139 Pragma Provide_Shift_Operators
====================================

Syntax:

     pragma Provide_Shift_Operators (integer_first_subtype_LOCAL_NAME);

This pragma can be applied to a first subtype local name that specifies
either an unsigned or signed type.  It has the effect of providing the
five shift operators (Shift_Left, Shift_Right, Shift_Right_Arithmetic,
Rotate_Left and Rotate_Right) for the given type.  It is similar to
including the function declarations for these five operators, together
with the pragma Import (Intrinsic, …) statements.


File: gnat_rm.info,  Node: Pragma Psect_Object,  Next: Pragma Pure_Function,  Prev: Pragma Provide_Shift_Operators,  Up: Implementation Defined Pragmas

2.140 Pragma Psect_Object
=========================

Syntax:

     pragma Psect_Object (
          [Internal =>] LOCAL_NAME,
       [, [External =>] EXTERNAL_SYMBOL]
       [, [Size     =>] EXTERNAL_SYMBOL]);

     EXTERNAL_SYMBOL ::=
       IDENTIFIER
     | static_string_EXPRESSION

This pragma is identical in effect to pragma ‘Common_Object’.


File: gnat_rm.info,  Node: Pragma Pure_Function,  Next: Pragma Rational,  Prev: Pragma Psect_Object,  Up: Implementation Defined Pragmas

2.141 Pragma Pure_Function
==========================

Syntax:

     pragma Pure_Function ([Entity =>] function_LOCAL_NAME);

This pragma appears in the same declarative part as a function
declaration (or a set of function declarations if more than one
overloaded declaration exists, in which case the pragma applies to all
entities).  It specifies that the function ‘Entity’ is to be considered
pure for the purposes of code generation.  This means that the compiler
can assume that there are no side effects, and in particular that two
calls with identical arguments produce the same result.  It also means
that the function can be used in an address clause.

Note that, quite deliberately, there are no static checks to try to
ensure that this promise is met, so ‘Pure_Function’ can be used with
functions that are conceptually pure, even if they do modify global
variables.  For example, a square root function that is instrumented to
count the number of times it is called is still conceptually pure, and
can still be optimized, even though it modifies a global variable (the
count).  Memo functions are another example (where a table of previous
calls is kept and consulted to avoid re-computation).

Note also that the normal rules excluding optimization of subprograms in
pure units (when parameter types are descended from System.Address, or
when the full view of a parameter type is limited), do not apply for the
Pure_Function case.  If you explicitly specify Pure_Function, the
compiler may optimize away calls with identical arguments, and if that
results in unexpected behavior, the proper action is not to use the
pragma for subprograms that are not (conceptually) pure.

Note: Most functions in a ‘Pure’ package are automatically pure, and
there is no need to use pragma ‘Pure_Function’ for such functions.  One
exception is any function that has at least one formal of type
‘System.Address’ or a type derived from it.  Such functions are not
considered pure by default, since the compiler assumes that the
‘Address’ parameter may be functioning as a pointer and that the
referenced data may change even if the address value does not.
Similarly, imported functions are not considered to be pure by default,
since there is no way of checking that they are in fact pure.  The use
of pragma ‘Pure_Function’ for such a function will override these
default assumption, and cause the compiler to treat a designated
subprogram as pure in these cases.

Note: If pragma ‘Pure_Function’ is applied to a renamed function, it
applies to the underlying renamed function.  This can be used to
disambiguate cases of overloading where some but not all functions in a
set of overloaded functions are to be designated as pure.

If pragma ‘Pure_Function’ is applied to a library-level function, the
function is also considered pure from an optimization point of view, but
the unit is not a Pure unit in the categorization sense.  So for
example, a function thus marked is free to ‘with’ non-pure units.


File: gnat_rm.info,  Node: Pragma Rational,  Next: Pragma Ravenscar,  Prev: Pragma Pure_Function,  Up: Implementation Defined Pragmas

2.142 Pragma Rational
=====================

Syntax:

     pragma Rational;

This pragma is considered obsolescent, but is retained for compatibility
purposes.  It is equivalent to:

     pragma Profile (Rational);


File: gnat_rm.info,  Node: Pragma Ravenscar,  Next: Pragma Refined_Depends,  Prev: Pragma Rational,  Up: Implementation Defined Pragmas

2.143 Pragma Ravenscar
======================

Syntax:

     pragma Ravenscar;

This pragma is considered obsolescent, but is retained for compatibility
purposes.  It is equivalent to:

     pragma Profile (Ravenscar);

which is the preferred method of setting the ‘Ravenscar’ profile.


File: gnat_rm.info,  Node: Pragma Refined_Depends,  Next: Pragma Refined_Global,  Prev: Pragma Ravenscar,  Up: Implementation Defined Pragmas

2.144 Pragma Refined_Depends
============================

Syntax:

     pragma Refined_Depends (DEPENDENCY_RELATION);

     DEPENDENCY_RELATION ::=
          null
       | (DEPENDENCY_CLAUSE {, DEPENDENCY_CLAUSE})

     DEPENDENCY_CLAUSE ::=
         OUTPUT_LIST =>[+] INPUT_LIST
       | NULL_DEPENDENCY_CLAUSE

     NULL_DEPENDENCY_CLAUSE ::= null => INPUT_LIST

     OUTPUT_LIST ::= OUTPUT | (OUTPUT {, OUTPUT})

     INPUT_LIST ::= null | INPUT | (INPUT {, INPUT})

     OUTPUT ::= NAME | FUNCTION_RESULT
     INPUT  ::= NAME

     where FUNCTION_RESULT is a function Result attribute_reference

For the semantics of this pragma, see the entry for aspect
‘Refined_Depends’ in the SPARK 2014 Reference Manual, section 6.1.5.


File: gnat_rm.info,  Node: Pragma Refined_Global,  Next: Pragma Refined_Post,  Prev: Pragma Refined_Depends,  Up: Implementation Defined Pragmas

2.145 Pragma Refined_Global
===========================

Syntax:

     pragma Refined_Global (GLOBAL_SPECIFICATION);

     GLOBAL_SPECIFICATION ::=
          null
       | (GLOBAL_LIST)
       | (MODED_GLOBAL_LIST {, MODED_GLOBAL_LIST})

     MODED_GLOBAL_LIST ::= MODE_SELECTOR => GLOBAL_LIST

     MODE_SELECTOR ::= In_Out | Input | Output | Proof_In
     GLOBAL_LIST   ::= GLOBAL_ITEM | (GLOBAL_ITEM {, GLOBAL_ITEM})
     GLOBAL_ITEM   ::= NAME

For the semantics of this pragma, see the entry for aspect
‘Refined_Global’ in the SPARK 2014 Reference Manual, section 6.1.4.


File: gnat_rm.info,  Node: Pragma Refined_Post,  Next: Pragma Refined_State,  Prev: Pragma Refined_Global,  Up: Implementation Defined Pragmas

2.146 Pragma Refined_Post
=========================

Syntax:

     pragma Refined_Post (boolean_EXPRESSION);

For the semantics of this pragma, see the entry for aspect
‘Refined_Post’ in the SPARK 2014 Reference Manual, section 7.2.7.


File: gnat_rm.info,  Node: Pragma Refined_State,  Next: Pragma Relative_Deadline,  Prev: Pragma Refined_Post,  Up: Implementation Defined Pragmas

2.147 Pragma Refined_State
==========================

Syntax:

     pragma Refined_State (REFINEMENT_LIST);

     REFINEMENT_LIST ::=
       (REFINEMENT_CLAUSE {, REFINEMENT_CLAUSE})

     REFINEMENT_CLAUSE ::= state_NAME => CONSTITUENT_LIST

     CONSTITUENT_LIST ::=
          null
       |  CONSTITUENT
       | (CONSTITUENT {, CONSTITUENT})

     CONSTITUENT ::= object_NAME | state_NAME

For the semantics of this pragma, see the entry for aspect
‘Refined_State’ in the SPARK 2014 Reference Manual, section 7.2.2.


File: gnat_rm.info,  Node: Pragma Relative_Deadline,  Next: Pragma Remote_Access_Type,  Prev: Pragma Refined_State,  Up: Implementation Defined Pragmas

2.148 Pragma Relative_Deadline
==============================

Syntax:

     pragma Relative_Deadline (time_span_EXPRESSION);

This pragma is standard in Ada 2005, but is available in all earlier
versions of Ada as an implementation-defined pragma.  See Ada 2012
Reference Manual for details.


File: gnat_rm.info,  Node: Pragma Remote_Access_Type,  Next: Pragma Rename_Pragma,  Prev: Pragma Relative_Deadline,  Up: Implementation Defined Pragmas

2.149 Pragma Remote_Access_Type
===============================

Syntax:

     pragma Remote_Access_Type ([Entity =>] formal_access_type_LOCAL_NAME);

This pragma appears in the formal part of a generic declaration.  It
specifies an exception to the RM rule from E.2.2(17/2), which forbids
the use of a remote access to class-wide type as actual for a formal
access type.

When this pragma applies to a formal access type ‘Entity’, that type is
treated as a remote access to class-wide type in the generic.  It must
be a formal general access type, and its designated type must be the
class-wide type of a formal tagged limited private type from the same
generic declaration.

In the generic unit, the formal type is subject to all restrictions
pertaining to remote access to class-wide types.  At instantiation, the
actual type must be a remote access to class-wide type.


File: gnat_rm.info,  Node: Pragma Rename_Pragma,  Next: Pragma Restricted_Run_Time,  Prev: Pragma Remote_Access_Type,  Up: Implementation Defined Pragmas

2.150 Pragma Rename_Pragma
==========================

Syntax:

     pragma Rename_Pragma (
              [New_Name =>] IDENTIFIER,
              [Renamed  =>] pragma_IDENTIFIER);

This pragma provides a mechanism for supplying new names for existing
pragmas.  The ‘New_Name’ identifier can subsequently be used as a
synonym for the Renamed pragma.  For example, suppose you have code that
was originally developed on a compiler that supports Inline_Only as an
implementation defined pragma.  And suppose the semantics of pragma
Inline_Only are identical to (or at least very similar to) the GNAT
implementation defined pragma Inline_Always.  You could globally replace
Inline_Only with Inline_Always.

However, to avoid that source modification, you could instead add a
configuration pragma:

     pragma Rename_Pragma (
              New_Name => Inline_Only,
              Renamed  => Inline_Always);

Then GNAT will treat “pragma Inline_Only …” as if you had written
“pragma Inline_Always …”.

Pragma Inline_Only will not necessarily mean the same thing as the other
Ada compiler; it’s up to you to make sure the semantics are close
enough.


File: gnat_rm.info,  Node: Pragma Restricted_Run_Time,  Next: Pragma Restriction_Warnings,  Prev: Pragma Rename_Pragma,  Up: Implementation Defined Pragmas

2.151 Pragma Restricted_Run_Time
================================

Syntax:

     pragma Restricted_Run_Time;

This pragma is considered obsolescent, but is retained for compatibility
purposes.  It is equivalent to:

     pragma Profile (Restricted);

which is the preferred method of setting the restricted run time
profile.


File: gnat_rm.info,  Node: Pragma Restriction_Warnings,  Next: Pragma Reviewable,  Prev: Pragma Restricted_Run_Time,  Up: Implementation Defined Pragmas

2.152 Pragma Restriction_Warnings
=================================

Syntax:

     pragma Restriction_Warnings
       (restriction_IDENTIFIER {, restriction_IDENTIFIER});

This pragma allows a series of restriction identifiers to be specified
(the list of allowed identifiers is the same as for pragma
‘Restrictions’).  For each of these identifiers the compiler checks for
violations of the restriction, but generates a warning message rather
than an error message if the restriction is violated.

One use of this is in situations where you want to know about violations
of a restriction, but you want to ignore some of these violations.
Consider this example, where you want to set Ada_95 mode and enable
style checks, but you want to know about any other use of implementation
pragmas:

     pragma Restriction_Warnings (No_Implementation_Pragmas);
     pragma Warnings (Off, "violation of No_Implementation_Pragmas");
     pragma Ada_95;
     pragma Style_Checks ("2bfhkM160");
     pragma Warnings (On, "violation of No_Implementation_Pragmas");

By including the above lines in a configuration pragmas file, the Ada_95
and Style_Checks pragmas are accepted without generating a warning, but
any other use of implementation defined pragmas will cause a warning to
be generated.


File: gnat_rm.info,  Node: Pragma Reviewable,  Next: Pragma Secondary_Stack_Size,  Prev: Pragma Restriction_Warnings,  Up: Implementation Defined Pragmas

2.153 Pragma Reviewable
=======================

Syntax:

     pragma Reviewable;

This pragma is an RM-defined standard pragma, but has no effect on the
program being compiled, or on the code generated for the program.

To obtain the required output specified in RM H.3.1, the compiler must
be run with various special switches as follows:

   * `Where compiler-generated run-time checks remain'

     The switch `-gnatGL' may be used to list the expanded code in
     pseudo-Ada form.  Runtime checks show up in the listing either as
     explicit checks or operators marked with {} to indicate a check is
     present.

   * `An identification of known exceptions at compile time'

     If the program is compiled with `-gnatwa', the compiler warning
     messages will indicate all cases where the compiler detects that an
     exception is certain to occur at run time.

   * `Possible reads of uninitialized variables'

     The compiler warns of many such cases, but its output is
     incomplete.

A supplemental static analysis tool may be used to obtain a
comprehensive list of all possible points at which uninitialized data
may be read.

   * `Where run-time support routines are implicitly invoked'

     In the output from `-gnatGL', run-time calls are explicitly listed
     as calls to the relevant run-time routine.

   * `Object code listing'

     This may be obtained either by using the `-S' switch, or the
     objdump utility.

   * `Constructs known to be erroneous at compile time'

     These are identified by warnings issued by the compiler (use
     `-gnatwa').

   * `Stack usage information'

     Static stack usage data (maximum per-subprogram) can be obtained
     via the `-fstack-usage' switch to the compiler.  Dynamic stack
     usage data (per task) can be obtained via the `-u' switch to
     gnatbind

   * `Object code listing of entire partition'

     This can be obtained by compiling the partition with `-S', or by
     applying objdump to all the object files that are part of the
     partition.

   * `A description of the run-time model'

     The full sources of the run-time are available, and the
     documentation of these routines describes how these run-time
     routines interface to the underlying operating system facilities.

   * `Control and data-flow information'

A supplemental static analysis tool may be used to obtain complete
control and data-flow information, as well as comprehensive messages
identifying possible problems based on this information.


File: gnat_rm.info,  Node: Pragma Secondary_Stack_Size,  Next: Pragma Share_Generic,  Prev: Pragma Reviewable,  Up: Implementation Defined Pragmas

2.154 Pragma Secondary_Stack_Size
=================================

Syntax:

     pragma Secondary_Stack_Size (integer_EXPRESSION);

This pragma appears within the task definition of a single task
declaration or a task type declaration (like pragma ‘Storage_Size’) and
applies to all task objects of that type.  The argument specifies the
size of the secondary stack to be used by these task objects, and must
be of an integer type.  The secondary stack is used to handle functions
that return a variable-sized result, for example a function returning an
unconstrained String.

Note this pragma only applies to targets using fixed secondary stacks,
like VxWorks 653 and bare board targets, where a fixed block for the
secondary stack is allocated from the primary stack of the task.  By
default, these targets assign a percentage of the primary stack for the
secondary stack, as defined by ‘System.Parameter.Sec_Stack_Percentage’.
With this pragma, an ‘integer_EXPRESSION’ of bytes is assigned from the
primary stack instead.

For most targets, the pragma does not apply as the secondary stack grows
on demand: allocated as a chain of blocks in the heap.  The default size
of these blocks can be modified via the ‘-D’ binder option as described
in ‘GNAT User’s Guide’.

Note that no check is made to see if the secondary stack can fit inside
the primary stack.

Note the pragma cannot appear when the restriction ‘No_Secondary_Stack’
is in effect.


File: gnat_rm.info,  Node: Pragma Share_Generic,  Next: Pragma Shared,  Prev: Pragma Secondary_Stack_Size,  Up: Implementation Defined Pragmas

2.155 Pragma Share_Generic
==========================

Syntax:

     pragma Share_Generic (GNAME {, GNAME});

     GNAME ::= generic_unit_NAME | generic_instance_NAME

This pragma is provided for compatibility with Dec Ada 83.  It has no
effect in GNAT (which does not implement shared generics), other than to
check that the given names are all names of generic units or generic
instances.


File: gnat_rm.info,  Node: Pragma Shared,  Next: Pragma Short_Circuit_And_Or,  Prev: Pragma Share_Generic,  Up: Implementation Defined Pragmas

2.156 Pragma Shared
===================

This pragma is provided for compatibility with Ada 83.  The syntax and
semantics are identical to pragma Atomic.


File: gnat_rm.info,  Node: Pragma Short_Circuit_And_Or,  Next: Pragma Short_Descriptors,  Prev: Pragma Shared,  Up: Implementation Defined Pragmas

2.157 Pragma Short_Circuit_And_Or
=================================

Syntax:

     pragma Short_Circuit_And_Or;

This configuration pragma causes any occurrence of the AND operator
applied to operands of type Standard.Boolean to be short-circuited (i.e.
the AND operator is treated as if it were AND THEN). Or is similarly
treated as OR ELSE. This may be useful in the context of certification
protocols requiring the use of short-circuited logical operators.  If
this configuration pragma occurs locally within the file being compiled,
it applies only to the file being compiled.  There is no requirement
that all units in a partition use this option.


File: gnat_rm.info,  Node: Pragma Short_Descriptors,  Next: Pragma Simple_Storage_Pool_Type,  Prev: Pragma Short_Circuit_And_Or,  Up: Implementation Defined Pragmas

2.158 Pragma Short_Descriptors
==============================

Syntax:

     pragma Short_Descriptors

This pragma is provided for compatibility with other Ada
implementations.  It is recognized but ignored by all current versions
of GNAT.


File: gnat_rm.info,  Node: Pragma Simple_Storage_Pool_Type,  Next: Pragma Source_File_Name,  Prev: Pragma Short_Descriptors,  Up: Implementation Defined Pragmas

2.159 Pragma Simple_Storage_Pool_Type
=====================================

Syntax:

     pragma Simple_Storage_Pool_Type (type_LOCAL_NAME);

A type can be established as a ‘simple storage pool type’ by applying
the representation pragma ‘Simple_Storage_Pool_Type’ to the type.  A
type named in the pragma must be a library-level immutably limited
record type or limited tagged type declared immediately within a package
declaration.  The type can also be a limited private type whose full
type is allowed as a simple storage pool type.

For a simple storage pool type ‘SSP’, nonabstract primitive subprograms
‘Allocate’, ‘Deallocate’, and ‘Storage_Size’ can be declared that are
subtype conformant with the following subprogram declarations:

     procedure Allocate
       (Pool                     : in out SSP;
        Storage_Address          : out System.Address;
        Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;
        Alignment                : System.Storage_Elements.Storage_Count);

     procedure Deallocate
       (Pool : in out SSP;
        Storage_Address          : System.Address;
        Size_In_Storage_Elements : System.Storage_Elements.Storage_Count;
        Alignment                : System.Storage_Elements.Storage_Count);

     function Storage_Size (Pool : SSP)
       return System.Storage_Elements.Storage_Count;

Procedure ‘Allocate’ must be declared, whereas ‘Deallocate’ and
‘Storage_Size’ are optional.  If ‘Deallocate’ is not declared, then
applying an unchecked deallocation has no effect other than to set its
actual parameter to null.  If ‘Storage_Size’ is not declared, then the
‘Storage_Size’ attribute applied to an access type associated with a
pool object of type SSP returns zero.  Additional operations can be
declared for a simple storage pool type (such as for supporting a
mark/release storage-management discipline).

An object of a simple storage pool type can be associated with an access
type by specifying the attribute *note Simple_Storage_Pool: e3.  For
example:

     My_Pool : My_Simple_Storage_Pool_Type;

     type Acc is access My_Data_Type;

     for Acc'Simple_Storage_Pool use My_Pool;

See attribute *note Simple_Storage_Pool: e3. for further details.


File: gnat_rm.info,  Node: Pragma Source_File_Name,  Next: Pragma Source_File_Name_Project,  Prev: Pragma Simple_Storage_Pool_Type,  Up: Implementation Defined Pragmas

2.160 Pragma Source_File_Name
=============================

Syntax:

     pragma Source_File_Name (
       [Unit_Name   =>] unit_NAME,
       Spec_File_Name =>  STRING_LITERAL,
       [Index => INTEGER_LITERAL]);

     pragma Source_File_Name (
       [Unit_Name   =>] unit_NAME,
       Body_File_Name =>  STRING_LITERAL,
       [Index => INTEGER_LITERAL]);

Use this to override the normal naming convention.  It is a
configuration pragma, and so has the usual applicability of
configuration pragmas (i.e., it applies to either an entire partition,
or to all units in a compilation, or to a single unit, depending on how
it is used.  ‘unit_name’ is mapped to ‘file_name_literal’.  The
identifier for the second argument is required, and indicates whether
this is the file name for the spec or for the body.

The optional Index argument should be used when a file contains multiple
units, and when you do not want to use ‘gnatchop’ to separate then into
multiple files (which is the recommended procedure to limit the number
of recompilations that are needed when some sources change).  For
instance, if the source file ‘source.ada’ contains

     package B is
     ...
     end B;

     with B;
     procedure A is
     begin
        ..
     end A;

you could use the following configuration pragmas:

     pragma Source_File_Name
       (B, Spec_File_Name => "source.ada", Index => 1);
     pragma Source_File_Name
       (A, Body_File_Name => "source.ada", Index => 2);

Note that the ‘gnatname’ utility can also be used to generate those
configuration pragmas.

Another form of the ‘Source_File_Name’ pragma allows the specification
of patterns defining alternative file naming schemes to apply to all
files.

     pragma Source_File_Name
       (  [Spec_File_Name  =>] STRING_LITERAL
        [,[Casing          =>] CASING_SPEC]
        [,[Dot_Replacement =>] STRING_LITERAL]);

     pragma Source_File_Name
       (  [Body_File_Name  =>] STRING_LITERAL
        [,[Casing          =>] CASING_SPEC]
        [,[Dot_Replacement =>] STRING_LITERAL]);

     pragma Source_File_Name
       (  [Subunit_File_Name =>] STRING_LITERAL
        [,[Casing            =>] CASING_SPEC]
        [,[Dot_Replacement   =>] STRING_LITERAL]);

     CASING_SPEC ::= Lowercase | Uppercase | Mixedcase

The first argument is a pattern that contains a single asterisk
indicating the point at which the unit name is to be inserted in the
pattern string to form the file name.  The second argument is optional.
If present it specifies the casing of the unit name in the resulting
file name string.  The default is lower case.  Finally the third
argument allows for systematic replacement of any dots in the unit name
by the specified string literal.

Note that Source_File_Name pragmas should not be used if you are using
project files.  The reason for this rule is that the project manager is
not aware of these pragmas, and so other tools that use the projet file
would not be aware of the intended naming conventions.  If you are using
project files, file naming is controlled by Source_File_Name_Project
pragmas, which are usually supplied automatically by the project
manager.  A pragma Source_File_Name cannot appear after a *note Pragma
Source_File_Name_Project: e6.

For more details on the use of the ‘Source_File_Name’ pragma, see the
sections on ‘Using Other File Names’ and ‘Alternative File Naming
Schemes’ in the ‘GNAT User’s Guide’.


File: gnat_rm.info,  Node: Pragma Source_File_Name_Project,  Next: Pragma Source_Reference,  Prev: Pragma Source_File_Name,  Up: Implementation Defined Pragmas

2.161 Pragma Source_File_Name_Project
=====================================

This pragma has the same syntax and semantics as pragma
Source_File_Name.  It is only allowed as a stand-alone configuration
pragma.  It cannot appear after a *note Pragma Source_File_Name: e5, and
most importantly, once pragma Source_File_Name_Project appears, no
further Source_File_Name pragmas are allowed.

The intention is that Source_File_Name_Project pragmas are always
generated by the Project Manager in a manner consistent with the naming
specified in a project file, and when naming is controlled in this
manner, it is not permissible to attempt to modify this naming scheme
using Source_File_Name or Source_File_Name_Project pragmas (which would
not be known to the project manager).


File: gnat_rm.info,  Node: Pragma Source_Reference,  Next: Pragma SPARK_Mode,  Prev: Pragma Source_File_Name_Project,  Up: Implementation Defined Pragmas

2.162 Pragma Source_Reference
=============================

Syntax:

     pragma Source_Reference (INTEGER_LITERAL, STRING_LITERAL);

This pragma must appear as the first line of a source file.
‘integer_literal’ is the logical line number of the line following the
pragma line (for use in error messages and debugging information).
‘string_literal’ is a static string constant that specifies the file
name to be used in error messages and debugging information.  This is
most notably used for the output of ‘gnatchop’ with the `-r' switch, to
make sure that the original unchopped source file is the one referred
to.

The second argument must be a string literal, it cannot be a static
string expression other than a string literal.  This is because its
value is needed for error messages issued by all phases of the compiler.


File: gnat_rm.info,  Node: Pragma SPARK_Mode,  Next: Pragma Static_Elaboration_Desired,  Prev: Pragma Source_Reference,  Up: Implementation Defined Pragmas

2.163 Pragma SPARK_Mode
=======================

Syntax:

     pragma SPARK_Mode [(On | Off)] ;

In general a program can have some parts that are in SPARK 2014 (and
follow all the rules in the SPARK Reference Manual), and some parts that
are full Ada 2012.

The SPARK_Mode pragma is used to identify which parts are in SPARK 2014
(by default programs are in full Ada).  The SPARK_Mode pragma can be
used in the following places:

   * As a configuration pragma, in which case it sets the default mode
     for all units compiled with this pragma.

   * Immediately following a library-level subprogram spec

   * Immediately within a library-level package body

   * Immediately following the ‘private’ keyword of a library-level
     package spec

   * Immediately following the ‘begin’ keyword of a library-level
     package body

   * Immediately within a library-level subprogram body

Normally a subprogram or package spec/body inherits the current mode
that is active at the point it is declared.  But this can be overridden
by pragma within the spec or body as above.

The basic consistency rule is that you can’t turn SPARK_Mode back ‘On’,
once you have explicitly (with a pragma) turned if ‘Off’.  So the
following rules apply:

If a subprogram spec has SPARK_Mode ‘Off’, then the body must also have
SPARK_Mode ‘Off’.

For a package, we have four parts:

   * the package public declarations

   * the package private part

   * the body of the package

   * the elaboration code after ‘begin’

For a package, the rule is that if you explicitly turn SPARK_Mode ‘Off’
for any part, then all the following parts must have SPARK_Mode ‘Off’.
Note that this may require repeating a pragma SPARK_Mode (‘Off’) in the
body.  For example, if we have a configuration pragma SPARK_Mode (‘On’)
that turns the mode on by default everywhere, and one particular package
spec has pragma SPARK_Mode (‘Off’), then that pragma will need to be
repeated in the package body.


File: gnat_rm.info,  Node: Pragma Static_Elaboration_Desired,  Next: Pragma Stream_Convert,  Prev: Pragma SPARK_Mode,  Up: Implementation Defined Pragmas

2.164 Pragma Static_Elaboration_Desired
=======================================

Syntax:

     pragma Static_Elaboration_Desired;

This pragma is used to indicate that the compiler should attempt to
initialize statically the objects declared in the library unit to which
the pragma applies, when these objects are initialized (explicitly or
implicitly) by an aggregate.  In the absence of this pragma, aggregates
in object declarations are expanded into assignments and loops, even
when the aggregate components are static constants.  When the aggregate
is present the compiler builds a static expression that requires no
run-time code, so that the initialized object can be placed in read-only
data space.  If the components are not static, or the aggregate has more
that 100 components, the compiler emits a warning that the pragma cannot
be obeyed.  (See also the restriction No_Implicit_Loops, which supports
static construction of larger aggregates with static components that
include an others choice.)


File: gnat_rm.info,  Node: Pragma Stream_Convert,  Next: Pragma Style_Checks,  Prev: Pragma Static_Elaboration_Desired,  Up: Implementation Defined Pragmas

2.165 Pragma Stream_Convert
===========================

Syntax:

     pragma Stream_Convert (
       [Entity =>] type_LOCAL_NAME,
       [Read   =>] function_NAME,
       [Write  =>] function_NAME);

This pragma provides an efficient way of providing user-defined stream
attributes.  Not only is it simpler to use than specifying the
attributes directly, but more importantly, it allows the specification
to be made in such a way that the predefined unit Ada.Streams is not
loaded unless it is actually needed (i.e.  unless the stream attributes
are actually used); the use of the Stream_Convert pragma adds no
overhead at all, unless the stream attributes are actually used on the
designated type.

The first argument specifies the type for which stream functions are
provided.  The second parameter provides a function used to read values
of this type.  It must name a function whose argument type may be any
subtype, and whose returned type must be the type given as the first
argument to the pragma.

The meaning of the ‘Read’ parameter is that if a stream attribute
directly or indirectly specifies reading of the type given as the first
parameter, then a value of the type given as the argument to the Read
function is read from the stream, and then the Read function is used to
convert this to the required target type.

Similarly the ‘Write’ parameter specifies how to treat write attributes
that directly or indirectly apply to the type given as the first
parameter.  It must have an input parameter of the type specified by the
first parameter, and the return type must be the same as the input type
of the Read function.  The effect is to first call the Write function to
convert to the given stream type, and then write the result type to the
stream.

The Read and Write functions must not be overloaded subprograms.  If
necessary renamings can be supplied to meet this requirement.  The usage
of this attribute is best illustrated by a simple example, taken from
the GNAT implementation of package Ada.Strings.Unbounded:

     function To_Unbounded (S : String) return Unbounded_String
       renames To_Unbounded_String;

     pragma Stream_Convert
       (Unbounded_String, To_Unbounded, To_String);

The specifications of the referenced functions, as given in the Ada
Reference Manual are:

     function To_Unbounded_String (Source : String)
       return Unbounded_String;

     function To_String (Source : Unbounded_String)
       return String;

The effect is that if the value of an unbounded string is written to a
stream, then the representation of the item in the stream is in the same
format that would be used for ‘Standard.String'Output’, and this same
representation is expected when a value of this type is read from the
stream.  Note that the value written always includes the bounds, even
for Unbounded_String’Write, since Unbounded_String is not an array type.

Note that the ‘Stream_Convert’ pragma is not effective in the case of a
derived type of a non-limited tagged type.  If such a type is specified
then the pragma is silently ignored, and the default implementation of
the stream attributes is used instead.


File: gnat_rm.info,  Node: Pragma Style_Checks,  Next: Pragma Subtitle,  Prev: Pragma Stream_Convert,  Up: Implementation Defined Pragmas

2.166 Pragma Style_Checks
=========================

Syntax:

     pragma Style_Checks (string_LITERAL | ALL_CHECKS |
                          On | Off [, LOCAL_NAME]);

This pragma is used in conjunction with compiler switches to control the
built in style checking provided by GNAT. The compiler switches, if set,
provide an initial setting for the switches, and this pragma may be used
to modify these settings, or the settings may be provided entirely by
the use of the pragma.  This pragma can be used anywhere that a pragma
is legal, including use as a configuration pragma (including use in the
‘gnat.adc’ file).

The form with a string literal specifies which style options are to be
activated.  These are additive, so they apply in addition to any
previously set style check options.  The codes for the options are the
same as those used in the `-gnaty' switch to `gcc' or `gnatmake'.  For
example the following two methods can be used to enable layout checking:

   *      pragma Style_Checks ("l");

   *      gcc -c -gnatyl ...

The form ‘ALL_CHECKS’ activates all standard checks (its use is
equivalent to the use of the ‘gnaty’ switch with no options.  See the
‘GNAT User’s Guide’ for details.)

Note: the behavior is slightly different in GNAT mode (‘-gnatg’ used).
In this case, ‘ALL_CHECKS’ implies the standard set of GNAT mode style
check options (i.e.  equivalent to ‘-gnatyg’).

The forms with ‘Off’ and ‘On’ can be used to temporarily disable style
checks as shown in the following example:

     pragma Style_Checks ("k"); -- requires keywords in lower case
     pragma Style_Checks (Off); -- turn off style checks
     NULL;                      -- this will not generate an error message
     pragma Style_Checks (On);  -- turn style checks back on
     NULL;                      -- this will generate an error message

Finally the two argument form is allowed only if the first argument is
‘On’ or ‘Off’.  The effect is to turn of semantic style checks for the
specified entity, as shown in the following example:

     pragma Style_Checks ("r"); -- require consistency of identifier casing
     Arg : Integer;
     Rf1 : Integer := ARG;      -- incorrect, wrong case
     pragma Style_Checks (Off, Arg);
     Rf2 : Integer := ARG;      -- OK, no error


File: gnat_rm.info,  Node: Pragma Subtitle,  Next: Pragma Suppress,  Prev: Pragma Style_Checks,  Up: Implementation Defined Pragmas

2.167 Pragma Subtitle
=====================

Syntax:

     pragma Subtitle ([Subtitle =>] STRING_LITERAL);

This pragma is recognized for compatibility with other Ada compilers but
is ignored by GNAT.


File: gnat_rm.info,  Node: Pragma Suppress,  Next: Pragma Suppress_All,  Prev: Pragma Subtitle,  Up: Implementation Defined Pragmas

2.168 Pragma Suppress
=====================

Syntax:

     pragma Suppress (Identifier [, [On =>] Name]);

This is a standard pragma, and supports all the check names required in
the RM. It is included here because GNAT recognizes some additional
check names that are implementation defined (as permitted by the RM):

   * ‘Alignment_Check’ can be used to suppress alignment checks on
     addresses used in address clauses.  Such checks can also be
     suppressed by suppressing range checks, but the specific use of
     ‘Alignment_Check’ allows suppression of alignment checks without
     suppressing other range checks.  Note that ‘Alignment_Check’ is
     suppressed by default on machines (such as the x86) with non-strict
     alignment.

   * ‘Atomic_Synchronization’ can be used to suppress the special memory
     synchronization instructions that are normally generated for access
     to ‘Atomic’ variables to ensure correct synchronization between
     tasks that use such variables for synchronization purposes.

   * ‘Duplicated_Tag_Check’ Can be used to suppress the check that is
     generated for a duplicated tag value when a tagged type is
     declared.

   * ‘Container_Checks’ Can be used to suppress all checks within
     Ada.Containers and instances of its children, including
     Tampering_Check.

   * ‘Tampering_Check’ Can be used to suppress tampering check in the
     containers.

   * ‘Predicate_Check’ can be used to control whether predicate checks
     are active.  It is applicable only to predicates for which the
     policy is ‘Check’.  Unlike ‘Assertion_Policy’, which determines if
     a given predicate is ignored or checked for the whole program, the
     use of ‘Suppress’ and ‘Unsuppress’ with this check name allows a
     given predicate to be turned on and off at specific points in the
     program.

   * ‘Validity_Check’ can be used specifically to control validity
     checks.  If ‘Suppress’ is used to suppress validity checks, then no
     validity checks are performed, including those specified by the
     appropriate compiler switch or the ‘Validity_Checks’ pragma.

   * Additional check names previously introduced by use of the
     ‘Check_Name’ pragma are also allowed.

Note that pragma Suppress gives the compiler permission to omit checks,
but does not require the compiler to omit checks.  The compiler will
generate checks if they are essentially free, even when they are
suppressed.  In particular, if the compiler can prove that a certain
check will necessarily fail, it will generate code to do an
unconditional ‘raise’, even if checks are suppressed.  The compiler
warns in this case.

Of course, run-time checks are omitted whenever the compiler can prove
that they will not fail, whether or not checks are suppressed.


File: gnat_rm.info,  Node: Pragma Suppress_All,  Next: Pragma Suppress_Debug_Info,  Prev: Pragma Suppress,  Up: Implementation Defined Pragmas

2.169 Pragma Suppress_All
=========================

Syntax:

     pragma Suppress_All;

This pragma can appear anywhere within a unit.  The effect is to apply
‘Suppress (All_Checks)’ to the unit in which it appears.  This pragma is
implemented for compatibility with DEC Ada 83 usage where it appears at
the end of a unit, and for compatibility with Rational Ada, where it
appears as a program unit pragma.  The use of the standard Ada pragma
‘Suppress (All_Checks)’ as a normal configuration pragma is the
preferred usage in GNAT.


File: gnat_rm.info,  Node: Pragma Suppress_Debug_Info,  Next: Pragma Suppress_Exception_Locations,  Prev: Pragma Suppress_All,  Up: Implementation Defined Pragmas

2.170 Pragma Suppress_Debug_Info
================================

Syntax:

     pragma Suppress_Debug_Info ([Entity =>] LOCAL_NAME);

This pragma can be used to suppress generation of debug information for
the specified entity.  It is intended primarily for use in debugging the
debugger, and navigating around debugger problems.


File: gnat_rm.info,  Node: Pragma Suppress_Exception_Locations,  Next: Pragma Suppress_Initialization,  Prev: Pragma Suppress_Debug_Info,  Up: Implementation Defined Pragmas

2.171 Pragma Suppress_Exception_Locations
=========================================

Syntax:

     pragma Suppress_Exception_Locations;

In normal mode, a raise statement for an exception by default generates
an exception message giving the file name and line number for the
location of the raise.  This is useful for debugging and logging
purposes, but this entails extra space for the strings for the messages.
The configuration pragma ‘Suppress_Exception_Locations’ can be used to
suppress the generation of these strings, with the result that space is
saved, but the exception message for such raises is null.  This
configuration pragma may appear in a global configuration pragma file,
or in a specific unit as usual.  It is not required that this pragma be
used consistently within a partition, so it is fine to have some units
within a partition compiled with this pragma and others compiled in
normal mode without it.


File: gnat_rm.info,  Node: Pragma Suppress_Initialization,  Next: Pragma Task_Name,  Prev: Pragma Suppress_Exception_Locations,  Up: Implementation Defined Pragmas

2.172 Pragma Suppress_Initialization
====================================

Syntax:

     pragma Suppress_Initialization ([Entity =>] variable_or_subtype_Name);

Here variable_or_subtype_Name is the name introduced by a type
declaration or subtype declaration or the name of a variable introduced
by an object declaration.

In the case of a type or subtype this pragma suppresses any implicit or
explicit initialization for all variables of the given type or subtype,
including initialization resulting from the use of pragmas
Normalize_Scalars or Initialize_Scalars.

This is considered a representation item, so it cannot be given after
the type is frozen.  It applies to all subsequent object declarations,
and also any allocator that creates objects of the type.

If the pragma is given for the first subtype, then it is considered to
apply to the base type and all its subtypes.  If the pragma is given for
other than a first subtype, then it applies only to the given subtype.
The pragma may not be given after the type is frozen.

Note that this includes eliminating initialization of discriminants for
discriminated types, and tags for tagged types.  In these cases, you
will have to use some non-portable mechanism (e.g.  address overlays or
unchecked conversion) to achieve required initialization of these fields
before accessing any object of the corresponding type.

For the variable case, implicit initialization for the named variable is
suppressed, just as though its subtype had been given in a pragma
Suppress_Initialization, as described above.


File: gnat_rm.info,  Node: Pragma Task_Name,  Next: Pragma Task_Storage,  Prev: Pragma Suppress_Initialization,  Up: Implementation Defined Pragmas

2.173 Pragma Task_Name
======================

Syntax

     pragma Task_Name (string_EXPRESSION);

This pragma appears within a task definition (like pragma ‘Priority’)
and applies to the task in which it appears.  The argument must be of
type String, and provides a name to be used for the task instance when
the task is created.  Note that this expression is not required to be
static, and in particular, it can contain references to task
discriminants.  This facility can be used to provide different names for
different tasks as they are created, as illustrated in the example
below.

The task name is recorded internally in the run-time structures and is
accessible to tools like the debugger.  In addition the routine
‘Ada.Task_Identification.Image’ will return this string, with a unique
task address appended.

     --  Example of the use of pragma Task_Name

     with Ada.Task_Identification;
     use Ada.Task_Identification;
     with Text_IO; use Text_IO;
     procedure t3 is

        type Astring is access String;

        task type Task_Typ (Name : access String) is
           pragma Task_Name (Name.all);
        end Task_Typ;

        task body Task_Typ is
           Nam : constant String := Image (Current_Task);
        begin
           Put_Line ("-->" & Nam (1 .. 14) & "<--");
        end Task_Typ;

        type Ptr_Task is access Task_Typ;
        Task_Var : Ptr_Task;

     begin
        Task_Var :=
          new Task_Typ (new String'("This is task 1"));
        Task_Var :=
          new Task_Typ (new String'("This is task 2"));
     end;


File: gnat_rm.info,  Node: Pragma Task_Storage,  Next: Pragma Test_Case,  Prev: Pragma Task_Name,  Up: Implementation Defined Pragmas

2.174 Pragma Task_Storage
=========================

Syntax:

     pragma Task_Storage (
       [Task_Type =>] LOCAL_NAME,
       [Top_Guard =>] static_integer_EXPRESSION);

This pragma specifies the length of the guard area for tasks.  The guard
area is an additional storage area allocated to a task.  A value of zero
means that either no guard area is created or a minimal guard area is
created, depending on the target.  This pragma can appear anywhere a
‘Storage_Size’ attribute definition clause is allowed for a task type.


File: gnat_rm.info,  Node: Pragma Test_Case,  Next: Pragma Thread_Local_Storage,  Prev: Pragma Task_Storage,  Up: Implementation Defined Pragmas

2.175 Pragma Test_Case
======================

Syntax:

     pragma Test_Case (
        [Name     =>] static_string_Expression
       ,[Mode     =>] (Nominal | Robustness)
      [, Requires =>  Boolean_Expression]
      [, Ensures  =>  Boolean_Expression]);

The ‘Test_Case’ pragma allows defining fine-grain specifications for use
by testing tools.  The compiler checks the validity of the ‘Test_Case’
pragma, but its presence does not lead to any modification of the code
generated by the compiler.

‘Test_Case’ pragmas may only appear immediately following the (separate)
declaration of a subprogram in a package declaration, inside a package
spec unit.  Only other pragmas may intervene (that is appear between the
subprogram declaration and a test case).

The compiler checks that boolean expressions given in ‘Requires’ and
‘Ensures’ are valid, where the rules for ‘Requires’ are the same as the
rule for an expression in ‘Precondition’ and the rules for ‘Ensures’ are
the same as the rule for an expression in ‘Postcondition’.  In
particular, attributes ‘'Old’ and ‘'Result’ can only be used within the
‘Ensures’ expression.  The following is an example of use within a
package spec:

     package Math_Functions is
        ...
        function Sqrt (Arg : Float) return Float;
        pragma Test_Case (Name     => "Test 1",
                          Mode     => Nominal,
                          Requires => Arg < 10000.0,
                          Ensures  => Sqrt'Result < 10.0);
        ...
     end Math_Functions;

The meaning of a test case is that there is at least one context where
‘Requires’ holds such that, if the associated subprogram is executed in
that context, then ‘Ensures’ holds when the subprogram returns.  Mode
‘Nominal’ indicates that the input context should also satisfy the
precondition of the subprogram, and the output context should also
satisfy its postcondition.  Mode ‘Robustness’ indicates that the
precondition and postcondition of the subprogram should be ignored for
this test case.


File: gnat_rm.info,  Node: Pragma Thread_Local_Storage,  Next: Pragma Time_Slice,  Prev: Pragma Test_Case,  Up: Implementation Defined Pragmas

2.176 Pragma Thread_Local_Storage
=================================

Syntax:

     pragma Thread_Local_Storage ([Entity =>] LOCAL_NAME);

This pragma specifies that the specified entity, which must be a
variable declared in a library-level package, is to be marked as “Thread
Local Storage” (‘TLS’).  On systems supporting this (which include
Windows, Solaris, GNU/Linux, and VxWorks 6), this causes each thread
(and hence each Ada task) to see a distinct copy of the variable.

The variable must not have default initialization, and if there is an
explicit initialization, it must be either ‘null’ for an access
variable, a static expression for a scalar variable, or a fully static
aggregate for a composite type, that is to say, an aggregate all of
whose components are static, and which does not include packed or
discriminated components.

This provides a low-level mechanism similar to that provided by the
‘Ada.Task_Attributes’ package, but much more efficient and is also
useful in writing interface code that will interact with foreign
threads.

If this pragma is used on a system where ‘TLS’ is not supported, then an
error message will be generated and the program will be rejected.


File: gnat_rm.info,  Node: Pragma Time_Slice,  Next: Pragma Title,  Prev: Pragma Thread_Local_Storage,  Up: Implementation Defined Pragmas

2.177 Pragma Time_Slice
=======================

Syntax:

     pragma Time_Slice (static_duration_EXPRESSION);

For implementations of GNAT on operating systems where it is possible to
supply a time slice value, this pragma may be used for this purpose.  It
is ignored if it is used in a system that does not allow this control,
or if it appears in other than the main program unit.


File: gnat_rm.info,  Node: Pragma Title,  Next: Pragma Type_Invariant,  Prev: Pragma Time_Slice,  Up: Implementation Defined Pragmas

2.178 Pragma Title
==================

Syntax:

     pragma Title (TITLING_OPTION [, TITLING OPTION]);

     TITLING_OPTION ::=
       [Title    =>] STRING_LITERAL,
     | [Subtitle =>] STRING_LITERAL

Syntax checked but otherwise ignored by GNAT. This is a listing control
pragma used in DEC Ada 83 implementations to provide a title and/or
subtitle for the program listing.  The program listing generated by GNAT
does not have titles or subtitles.

Unlike other pragmas, the full flexibility of named notation is allowed
for this pragma, i.e., the parameters may be given in any order if named
notation is used, and named and positional notation can be mixed
following the normal rules for procedure calls in Ada.


File: gnat_rm.info,  Node: Pragma Type_Invariant,  Next: Pragma Type_Invariant_Class,  Prev: Pragma Title,  Up: Implementation Defined Pragmas

2.179 Pragma Type_Invariant
===========================

Syntax:

     pragma Type_Invariant
       ([Entity =>] type_LOCAL_NAME,
        [Check  =>] EXPRESSION);

The ‘Type_Invariant’ pragma is intended to be an exact replacement for
the language-defined ‘Type_Invariant’ aspect, and shares its
restrictions and semantics.  It differs from the language defined
‘Invariant’ pragma in that it does not permit a string parameter, and it
is controlled by the assertion identifier ‘Type_Invariant’ rather than
‘Invariant’.


File: gnat_rm.info,  Node: Pragma Type_Invariant_Class,  Next: Pragma Unchecked_Union,  Prev: Pragma Type_Invariant,  Up: Implementation Defined Pragmas

2.180 Pragma Type_Invariant_Class
=================================

Syntax:

     pragma Type_Invariant_Class
       ([Entity =>] type_LOCAL_NAME,
        [Check  =>] EXPRESSION);

The ‘Type_Invariant_Class’ pragma is intended to be an exact replacement
for the language-defined ‘Type_Invariant'Class’ aspect, and shares its
restrictions and semantics.

Note: This pragma is called ‘Type_Invariant_Class’ rather than
‘Type_Invariant'Class’ because the latter would not be strictly
conforming to the allowed syntax for pragmas.  The motivation for
providing pragmas equivalent to the aspects is to allow a program to be
written using the pragmas, and then compiled if necessary using an Ada
compiler that does not recognize the pragmas or aspects, but is prepared
to ignore the pragmas.  The assertion policy that controls this pragma
is ‘Type_Invariant'Class’, not ‘Type_Invariant_Class’.


File: gnat_rm.info,  Node: Pragma Unchecked_Union,  Next: Pragma Unevaluated_Use_Of_Old,  Prev: Pragma Type_Invariant_Class,  Up: Implementation Defined Pragmas

2.181 Pragma Unchecked_Union
============================

Syntax:

     pragma Unchecked_Union (first_subtype_LOCAL_NAME);

This pragma is used to specify a representation of a record type that is
equivalent to a C union.  It was introduced as a GNAT implementation
defined pragma in the GNAT Ada 95 mode.  Ada 2005 includes an extended
version of this pragma, making it language defined, and GNAT fully
implements this extended version in all language modes (Ada 83, Ada 95,
and Ada 2005).  For full details, consult the Ada 2012 Reference Manual,
section B.3.3.


File: gnat_rm.info,  Node: Pragma Unevaluated_Use_Of_Old,  Next: Pragma Unimplemented_Unit,  Prev: Pragma Unchecked_Union,  Up: Implementation Defined Pragmas

2.182 Pragma Unevaluated_Use_Of_Old
===================================

Syntax:

     pragma Unevaluated_Use_Of_Old (Error | Warn | Allow);

This pragma controls the processing of attributes Old and Loop_Entry.
If either of these attributes is used in a potentially unevaluated
expression (e.g.  the then or else parts of an if expression), then
normally this usage is considered illegal if the prefix of the attribute
is other than an entity name.  The language requires this behavior for
Old, and GNAT copies the same rule for Loop_Entry.

The reason for this rule is that otherwise, we can have a situation
where we save the Old value, and this results in an exception, even
though we might not evaluate the attribute.  Consider this example:

     package UnevalOld is
        K : Character;
        procedure U (A : String; C : Boolean)  -- ERROR
          with Post => (if C then A(1)'Old = K else True);
     end;

If procedure U is called with a string with a lower bound of 2, and C
false, then an exception would be raised trying to evaluate A(1) on
entry even though the value would not be actually used.

Although the rule guarantees against this possibility, it is sometimes
too restrictive.  For example if we know that the string has a lower
bound of 1, then we will never raise an exception.  The pragma
‘Unevaluated_Use_Of_Old’ can be used to modify this behavior.  If the
argument is ‘Error’ then an error is given (this is the default RM
behavior).  If the argument is ‘Warn’ then the usage is allowed as legal
but with a warning that an exception might be raised.  If the argument
is ‘Allow’ then the usage is allowed as legal without generating a
warning.

This pragma may appear as a configuration pragma, or in a declarative
part or package specification.  In the latter case it applies to uses up
to the end of the corresponding statement sequence or sequence of
package declarations.


File: gnat_rm.info,  Node: Pragma Unimplemented_Unit,  Next: Pragma Universal_Aliasing,  Prev: Pragma Unevaluated_Use_Of_Old,  Up: Implementation Defined Pragmas

2.183 Pragma Unimplemented_Unit
===============================

Syntax:

     pragma Unimplemented_Unit;

If this pragma occurs in a unit that is processed by the compiler, GNAT
aborts with the message ‘xxx not implemented’, where ‘xxx’ is the name
of the current compilation unit.  This pragma is intended to allow the
compiler to handle unimplemented library units in a clean manner.

The abort only happens if code is being generated.  Thus you can use
specs of unimplemented packages in syntax or semantic checking mode.


File: gnat_rm.info,  Node: Pragma Universal_Aliasing,  Next: Pragma Unmodified,  Prev: Pragma Unimplemented_Unit,  Up: Implementation Defined Pragmas

2.184 Pragma Universal_Aliasing
===============================

Syntax:

     pragma Universal_Aliasing [([Entity =>] type_LOCAL_NAME)];

‘type_LOCAL_NAME’ must refer to a type declaration in the current
declarative part.  The effect is to inhibit strict type-based aliasing
optimization for the given type.  In other words, the effect is as
though access types designating this type were subject to pragma
No_Strict_Aliasing.  For a detailed description of the strict aliasing
optimization, and the situations in which it must be suppressed, see the
section on ‘Optimization and Strict Aliasing’ in the ‘GNAT User’s
Guide’.


File: gnat_rm.info,  Node: Pragma Unmodified,  Next: Pragma Unreferenced,  Prev: Pragma Universal_Aliasing,  Up: Implementation Defined Pragmas

2.185 Pragma Unmodified
=======================

Syntax:

     pragma Unmodified (LOCAL_NAME {, LOCAL_NAME});

This pragma signals that the assignable entities (variables, ‘out’
parameters, ‘in out’ parameters) whose names are listed are deliberately
not assigned in the current source unit.  This suppresses warnings about
the entities being referenced but not assigned, and in addition a
warning will be generated if one of these entities is in fact assigned
in the same unit as the pragma (or in the corresponding body, or one of
its subunits).

This is particularly useful for clearly signaling that a particular
parameter is not modified, even though the spec suggests that it might
be.

For the variable case, warnings are never given for unreferenced
variables whose name contains one of the substrings ‘DISCARD, DUMMY,
IGNORE, JUNK, UNUSED’ in any casing.  Such names are typically to be
used in cases where such warnings are expected.  Thus it is never
necessary to use ‘pragma Unmodified’ for such variables, though it is
harmless to do so.


File: gnat_rm.info,  Node: Pragma Unreferenced,  Next: Pragma Unreferenced_Objects,  Prev: Pragma Unmodified,  Up: Implementation Defined Pragmas

2.186 Pragma Unreferenced
=========================

Syntax:

     pragma Unreferenced (LOCAL_NAME {, LOCAL_NAME});
     pragma Unreferenced (library_unit_NAME {, library_unit_NAME});

This pragma signals that the entities whose names are listed are
deliberately not referenced in the current source unit after the
occurrence of the pragma.  This suppresses warnings about the entities
being unreferenced, and in addition a warning will be generated if one
of these entities is in fact subsequently referenced in the same unit as
the pragma (or in the corresponding body, or one of its subunits).

This is particularly useful for clearly signaling that a particular
parameter is not referenced in some particular subprogram implementation
and that this is deliberate.  It can also be useful in the case of
objects declared only for their initialization or finalization side
effects.

If ‘LOCAL_NAME’ identifies more than one matching homonym in the current
scope, then the entity most recently declared is the one to which the
pragma applies.  Note that in the case of accept formals, the pragma
Unreferenced may appear immediately after the keyword ‘do’ which allows
the indication of whether or not accept formals are referenced or not to
be given individually for each accept statement.

The left hand side of an assignment does not count as a reference for
the purpose of this pragma.  Thus it is fine to assign to an entity for
which pragma Unreferenced is given.  However, use of an entity as an
actual for an out parameter does count as a reference unless warnings
for unread output parameters are enabled via ‘-gnatw.o’.

Note that if a warning is desired for all calls to a given subprogram,
regardless of whether they occur in the same unit as the subprogram
declaration, then this pragma should not be used (calls from another
unit would not be flagged); pragma Obsolescent can be used instead for
this purpose, see *note Pragma Obsolescent: ab.

The second form of pragma ‘Unreferenced’ is used within a context
clause.  In this case the arguments must be unit names of units
previously mentioned in ‘with’ clauses (similar to the usage of pragma
‘Elaborate_All’.  The effect is to suppress warnings about unreferenced
units and unreferenced entities within these units.

For the variable case, warnings are never given for unreferenced
variables whose name contains one of the substrings ‘DISCARD, DUMMY,
IGNORE, JUNK, UNUSED’ in any casing.  Such names are typically to be
used in cases where such warnings are expected.  Thus it is never
necessary to use ‘pragma Unreferenced’ for such variables, though it is
harmless to do so.


File: gnat_rm.info,  Node: Pragma Unreferenced_Objects,  Next: Pragma Unreserve_All_Interrupts,  Prev: Pragma Unreferenced,  Up: Implementation Defined Pragmas

2.187 Pragma Unreferenced_Objects
=================================

Syntax:

     pragma Unreferenced_Objects (local_subtype_NAME {, local_subtype_NAME});

This pragma signals that for the types or subtypes whose names are
listed, objects which are declared with one of these types or subtypes
may not be referenced, and if no references appear, no warnings are
given.

This is particularly useful for objects which are declared solely for
their initialization and finalization effect.  Such variables are
sometimes referred to as RAII variables (Resource Acquisition Is
Initialization).  Using this pragma on the relevant type (most typically
a limited controlled type), the compiler will automatically suppress
unwanted warnings about these variables not being referenced.


File: gnat_rm.info,  Node: Pragma Unreserve_All_Interrupts,  Next: Pragma Unsuppress,  Prev: Pragma Unreferenced_Objects,  Up: Implementation Defined Pragmas

2.188 Pragma Unreserve_All_Interrupts
=====================================

Syntax:

     pragma Unreserve_All_Interrupts;

Normally certain interrupts are reserved to the implementation.  Any
attempt to attach an interrupt causes Program_Error to be raised, as
described in RM C.3.2(22).  A typical example is the ‘SIGINT’ interrupt
used in many systems for a ‘Ctrl-C’ interrupt.  Normally this interrupt
is reserved to the implementation, so that ‘Ctrl-C’ can be used to
interrupt execution.

If the pragma ‘Unreserve_All_Interrupts’ appears anywhere in any unit in
a program, then all such interrupts are unreserved.  This allows the
program to handle these interrupts, but disables their standard
functions.  For example, if this pragma is used, then pressing ‘Ctrl-C’
will not automatically interrupt execution.  However, a program can then
handle the ‘SIGINT’ interrupt as it chooses.

For a full list of the interrupts handled in a specific implementation,
see the source code for the spec of ‘Ada.Interrupts.Names’ in file
‘a-intnam.ads’.  This is a target dependent file that contains the list
of interrupts recognized for a given target.  The documentation in this
file also specifies what interrupts are affected by the use of the
‘Unreserve_All_Interrupts’ pragma.

For a more general facility for controlling what interrupts can be
handled, see pragma ‘Interrupt_State’, which subsumes the functionality
of the ‘Unreserve_All_Interrupts’ pragma.


File: gnat_rm.info,  Node: Pragma Unsuppress,  Next: Pragma Use_VADS_Size,  Prev: Pragma Unreserve_All_Interrupts,  Up: Implementation Defined Pragmas

2.189 Pragma Unsuppress
=======================

Syntax:

     pragma Unsuppress (IDENTIFIER [, [On =>] NAME]);

This pragma undoes the effect of a previous pragma ‘Suppress’.  If there
is no corresponding pragma ‘Suppress’ in effect, it has no effect.  The
range of the effect is the same as for pragma ‘Suppress’.  The meaning
of the arguments is identical to that used in pragma ‘Suppress’.

One important application is to ensure that checks are on in cases where
code depends on the checks for its correct functioning, so that the code
will compile correctly even if the compiler switches are set to suppress
checks.  For example, in a program that depends on external names of
tagged types and wants to ensure that the duplicated tag check occurs
even if all run-time checks are suppressed by a compiler switch, the
following configuration pragma will ensure this test is not suppressed:

     pragma Unsuppress (Duplicated_Tag_Check);

This pragma is standard in Ada 2005.  It is available in all earlier
versions of Ada as an implementation-defined pragma.

Note that in addition to the checks defined in the Ada RM, GNAT
recogizes a number of implementation-defined check names.  See the
description of pragma ‘Suppress’ for full details.


File: gnat_rm.info,  Node: Pragma Use_VADS_Size,  Next: Pragma Unused,  Prev: Pragma Unsuppress,  Up: Implementation Defined Pragmas

2.190 Pragma Use_VADS_Size
==========================

Syntax:

     pragma Use_VADS_Size;

This is a configuration pragma.  In a unit to which it applies, any use
of the ‘Size attribute is automatically interpreted as a use of the
‘VADS_Size attribute.  Note that this may result in incorrect semantic
processing of valid Ada 95 or Ada 2005 programs.  This is intended to
aid in the handling of existing code which depends on the interpretation
of Size as implemented in the VADS compiler.  See description of the
VADS_Size attribute for further details.


File: gnat_rm.info,  Node: Pragma Unused,  Next: Pragma Validity_Checks,  Prev: Pragma Use_VADS_Size,  Up: Implementation Defined Pragmas

2.191 Pragma Unused
===================

Syntax:

     pragma Unused (LOCAL_NAME {, LOCAL_NAME});

This pragma signals that the assignable entities (variables, ‘out’
parameters, and ‘in out’ parameters) whose names are listed deliberately
do not get assigned or referenced in the current source unit after the
occurrence of the pragma in the current source unit.  This suppresses
warnings about the entities that are unreferenced and/or not assigned,
and, in addition, a warning will be generated if one of these entities
gets assigned or subsequently referenced in the same unit as the pragma
(in the corresponding body or one of its subunits).

This is particularly useful for clearly signaling that a particular
parameter is not modified or referenced, even though the spec suggests
that it might be.

For the variable case, warnings are never given for unreferenced
variables whose name contains one of the substrings ‘DISCARD, DUMMY,
IGNORE, JUNK, UNUSED’ in any casing.  Such names are typically to be
used in cases where such warnings are expected.  Thus it is never
necessary to use ‘pragma Unmodified’ for such variables, though it is
harmless to do so.


File: gnat_rm.info,  Node: Pragma Validity_Checks,  Next: Pragma Volatile,  Prev: Pragma Unused,  Up: Implementation Defined Pragmas

2.192 Pragma Validity_Checks
============================

Syntax:

     pragma Validity_Checks (string_LITERAL | ALL_CHECKS | On | Off);

This pragma is used in conjunction with compiler switches to control the
built-in validity checking provided by GNAT. The compiler switches, if
set provide an initial setting for the switches, and this pragma may be
used to modify these settings, or the settings may be provided entirely
by the use of the pragma.  This pragma can be used anywhere that a
pragma is legal, including use as a configuration pragma (including use
in the ‘gnat.adc’ file).

The form with a string literal specifies which validity options are to
be activated.  The validity checks are first set to include only the
default reference manual settings, and then a string of letters in the
string specifies the exact set of options required.  The form of this
string is exactly as described for the `-gnatVx' compiler switch (see
the GNAT User’s Guide for details).  For example the following two
methods can be used to enable validity checking for mode ‘in’ and ‘in
out’ subprogram parameters:

   *      pragma Validity_Checks ("im");

   *      $ gcc -c -gnatVim ...

The form ALL_CHECKS activates all standard checks (its use is equivalent
to the use of the ‘gnatVa’ switch).

The forms with ‘Off’ and ‘On’ can be used to temporarily disable
validity checks as shown in the following example:

     pragma Validity_Checks ("c"); -- validity checks for copies
     pragma Validity_Checks (Off); -- turn off validity checks
     A := B;                       -- B will not be validity checked
     pragma Validity_Checks (On);  -- turn validity checks back on
     A := C;                       -- C will be validity checked


File: gnat_rm.info,  Node: Pragma Volatile,  Next: Pragma Volatile_Full_Access,  Prev: Pragma Validity_Checks,  Up: Implementation Defined Pragmas

2.193 Pragma Volatile
=====================

Syntax:

     pragma Volatile (LOCAL_NAME);

This pragma is defined by the Ada Reference Manual, and the GNAT
implementation is fully conformant with this definition.  The reason it
is mentioned in this section is that a pragma of the same name was
supplied in some Ada 83 compilers, including DEC Ada 83.  The Ada 95 /
Ada 2005 implementation of pragma Volatile is upwards compatible with
the implementation in DEC Ada 83.


File: gnat_rm.info,  Node: Pragma Volatile_Full_Access,  Next: Pragma Volatile_Function,  Prev: Pragma Volatile,  Up: Implementation Defined Pragmas

2.194 Pragma Volatile_Full_Access
=================================

Syntax:

     pragma Volatile_Full_Access (LOCAL_NAME);

This is similar in effect to pragma Volatile, except that any reference
to the object is guaranteed to be done only with instructions that read
or write all the bits of the object.  Furthermore, if the object is of a
composite type, then any reference to a subcomponent of the object is
guaranteed to read and/or write all the bits of the object.

The intention is that this be suitable for use with memory-mapped I/O
devices on some machines.  Note that there are two important respects in
which this is different from ‘pragma Atomic’.  First a reference to a
‘Volatile_Full_Access’ object is not a sequential action in the RM 9.10
sense and, therefore, does not create a synchronization point.  Second,
in the case of ‘pragma Atomic’, there is no guarantee that all the bits
will be accessed if the reference is not to the whole object; the
compiler is allowed (and generally will) access only part of the object
in this case.


File: gnat_rm.info,  Node: Pragma Volatile_Function,  Next: Pragma Warning_As_Error,  Prev: Pragma Volatile_Full_Access,  Up: Implementation Defined Pragmas

2.195 Pragma Volatile_Function
==============================

Syntax:

     pragma Volatile_Function [ (boolean_EXPRESSION) ];

For the semantics of this pragma, see the entry for aspect
‘Volatile_Function’ in the SPARK 2014 Reference Manual, section 7.1.2.


File: gnat_rm.info,  Node: Pragma Warning_As_Error,  Next: Pragma Warnings,  Prev: Pragma Volatile_Function,  Up: Implementation Defined Pragmas

2.196 Pragma Warning_As_Error
=============================

Syntax:

     pragma Warning_As_Error (static_string_EXPRESSION);

This configuration pragma allows the programmer to specify a set of
warnings that will be treated as errors.  Any warning that matches the
pattern given by the pragma argument will be treated as an error.  This
gives more precise control than -gnatwe, which treats warnings as
errors.

This pragma can apply to regular warnings (messages enabled by -gnatw)
and to style warnings (messages that start with “(style)”, enabled by
-gnaty).

The pattern may contain asterisks, which match zero or more characters
in the message.  For example, you can use ‘pragma Warning_As_Error
("bits of*unused")’ to treat the warning message ‘warning: 960 bits of
"a" unused’ as an error.  All characters other than asterisk are treated
as literal characters in the match.  The match is case insensitive; for
example XYZ matches xyz.

Note that the pattern matches if it occurs anywhere within the warning
message string (it is not necessary to put an asterisk at the start and
the end of the message, since this is implied).

Another possibility for the static_string_EXPRESSION which works whether
or not error tags are enabled (`-gnatw.d') is to use a single `-gnatw'
tag string, enclosed in brackets, as shown in the example below, to
treat one category of warnings as errors.  Note that if you want to
treat multiple categories of warnings as errors, you can use multiple
pragma Warning_As_Error.

The above use of patterns to match the message applies only to warning
messages generated by the front end.  This pragma can also be applied to
warnings provided by the back end and mentioned in *note Pragma
Warnings: 119.  By using a single full `-Wxxx' switch in the pragma,
such warnings can also be treated as errors.

The pragma can appear either in a global configuration pragma file (e.g.
‘gnat.adc’), or at the start of a file.  Given a global configuration
pragma file containing:

     pragma Warning_As_Error ("[-gnatwj]");

which will treat all obsolescent feature warnings as errors, the
following program compiles as shown (compile options here are `-gnatwa.d
-gnatl -gnatj55').

         1. pragma Warning_As_Error ("*never assigned*");
         2. function Warnerr return String is
         3.    X : Integer;
               |
            >>> error: variable "X" is never read and
                never assigned [-gnatwv] [warning-as-error]

         4.    Y : Integer;
               |
            >>> warning: variable "Y" is assigned but
                never read [-gnatwu]

         5. begin
         6.    Y := 0;
         7.    return %ABC%;
                      |
            >>> error: use of "%" is an obsolescent
                feature (RM J.2(4)), use """ instead
                [-gnatwj] [warning-as-error]

         8. end;

     8 lines: No errors, 3 warnings (2 treated as errors)

Note that this pragma does not affect the set of warnings issued in any
way, it merely changes the effect of a matching warning if one is
produced as a result of other warnings options.  As shown in this
example, if the pragma results in a warning being treated as an error,
the tag is changed from “warning:” to “error:” and the string
“[warning-as-error]” is appended to the end of the message.


File: gnat_rm.info,  Node: Pragma Warnings,  Next: Pragma Weak_External,  Prev: Pragma Warning_As_Error,  Up: Implementation Defined Pragmas

2.197 Pragma Warnings
=====================

Syntax:

     pragma Warnings ([TOOL_NAME,] DETAILS [, REASON]);

     DETAILS ::= On | Off
     DETAILS ::= On | Off, local_NAME
     DETAILS ::= static_string_EXPRESSION
     DETAILS ::= On | Off, static_string_EXPRESSION

     TOOL_NAME ::= GNAT | GNATprove

     REASON ::= Reason => STRING_LITERAL {& STRING_LITERAL}

Note: in Ada 83 mode, a string literal may be used in place of a static
string expression (which does not exist in Ada 83).

Note if the second argument of ‘DETAILS’ is a ‘local_NAME’ then the
second form is always understood.  If the intention is to use the fourth
form, then you can write ‘NAME & ""’ to force the intepretation as a
`static_string_EXPRESSION'.

Note: if the first argument is a valid ‘TOOL_NAME’, it will be
interpreted that way.  The use of the ‘TOOL_NAME’ argument is relevant
only to users of SPARK and GNATprove, see last part of this section for
details.

Normally warnings are enabled, with the output being controlled by the
command line switch.  Warnings (‘Off’) turns off generation of warnings
until a Warnings (‘On’) is encountered or the end of the current unit.
If generation of warnings is turned off using this pragma, then some or
all of the warning messages are suppressed, regardless of the setting of
the command line switches.

The ‘Reason’ parameter may optionally appear as the last argument in any
of the forms of this pragma.  It is intended purely for the purposes of
documenting the reason for the ‘Warnings’ pragma.  The compiler will
check that the argument is a static string but otherwise ignore this
argument.  Other tools may provide specialized processing for this
string.

The form with a single argument (or two arguments if Reason present),
where the first argument is ‘ON’ or ‘OFF’ may be used as a configuration
pragma.

If the ‘LOCAL_NAME’ parameter is present, warnings are suppressed for
the specified entity.  This suppression is effective from the point
where it occurs till the end of the extended scope of the variable
(similar to the scope of ‘Suppress’).  This form cannot be used as a
configuration pragma.

In the case where the first argument is other than ‘ON’ or ‘OFF’, the
third form with a single static_string_EXPRESSION argument (and possible
reason) provides more precise control over which warnings are active.
The string is a list of letters specifying which warnings are to be
activated and which deactivated.  The code for these letters is the same
as the string used in the command line switch controlling warnings.  For
a brief summary, use the gnatmake command with no arguments, which will
generate usage information containing the list of warnings switches
supported.  For full details see the section on ‘Warning Message
Control’ in the ‘GNAT User’s Guide’.  This form can also be used as a
configuration pragma.

The warnings controlled by the ‘-gnatw’ switch are generated by the
front end of the compiler.  The GCC back end can provide additional
warnings and they are controlled by the ‘-W’ switch.  Such warnings can
be identified by the appearance of a string of the form ‘[-W{xxx}]’ in
the message which designates the ‘-W`xxx'’ switch that controls the
message.  The form with a single `static_string_EXPRESSION' argument
also works for these warnings, but the string must be a single full
‘-W`xxx'’ switch in this case.  The above reference lists a few examples
of these additional warnings.

The specified warnings will be in effect until the end of the program or
another pragma ‘Warnings’ is encountered.  The effect of the pragma is
cumulative.  Initially the set of warnings is the standard default set
as possibly modified by compiler switches.  Then each pragma Warning
modifies this set of warnings as specified.  This form of the pragma may
also be used as a configuration pragma.

The fourth form, with an ‘On|Off’ parameter and a string, is used to
control individual messages, based on their text.  The string argument
is a pattern that is used to match against the text of individual
warning messages (not including the initial “warning: ” tag).

The pattern may contain asterisks, which match zero or more characters
in the message.  For example, you can use ‘pragma Warnings (Off, "bits
of*unused")’ to suppress the warning message ‘warning: 960 bits of "a"
unused’.  No other regular expression notations are permitted.  All
characters other than asterisk in these three specific cases are treated
as literal characters in the match.  The match is case insensitive, for
example XYZ matches xyz.

Note that the pattern matches if it occurs anywhere within the warning
message string (it is not necessary to put an asterisk at the start and
the end of the message, since this is implied).

The above use of patterns to match the message applies only to warning
messages generated by the front end.  This form of the pragma with a
string argument can also be used to control warnings provided by the
back end and mentioned above.  By using a single full ‘-W`xxx'’ switch
in the pragma, such warnings can be turned on and off.

There are two ways to use the pragma in this form.  The OFF form can be
used as a configuration pragma.  The effect is to suppress all warnings
(if any) that match the pattern string throughout the compilation (or
match the -W switch in the back end case).

The second usage is to suppress a warning locally, and in this case, two
pragmas must appear in sequence:

     pragma Warnings (Off, Pattern);
     ... code where given warning is to be suppressed
     pragma Warnings (On, Pattern);

In this usage, the pattern string must match in the Off and On pragmas,
and (if `-gnatw.w' is given) at least one matching warning must be
suppressed.

Note: if the ON form is not found, then the effect of the OFF form
extends until the end of the file (pragma Warnings is purely textual, so
its effect does not stop at the end of the enclosing scope).

Note: to write a string that will match any warning, use the string
‘"***"’.  It will not work to use a single asterisk or two asterisks
since this looks like an operator name.  This form with three asterisks
is similar in effect to specifying ‘pragma Warnings (Off)’ except (if
‘-gnatw.w’ is given) that a matching ‘pragma Warnings (On, "***")’ will
be required.  This can be helpful in avoiding forgetting to turn
warnings back on.

Note: the debug flag ‘-gnatd.i’ can be used to cause the compiler to
entirely ignore all WARNINGS pragmas.  This can be useful in checking
whether obsolete pragmas in existing programs are hiding real problems.

Note: pragma Warnings does not affect the processing of style messages.
See separate entry for pragma Style_Checks for control of style
messages.

Users of the formal verification tool GNATprove for the SPARK subset of
Ada may use the version of the pragma with a ‘TOOL_NAME’ parameter.

If present, ‘TOOL_NAME’ is the name of a tool, currently either ‘GNAT’
for the compiler or ‘GNATprove’ for the formal verification tool.  A
given tool only takes into account pragma Warnings that do not specify a
tool name, or that specify the matching tool name.  This makes it
possible to disable warnings selectively for each tool, and as a
consequence to detect useless pragma Warnings with switch ‘-gnatw.w’.


File: gnat_rm.info,  Node: Pragma Weak_External,  Next: Pragma Wide_Character_Encoding,  Prev: Pragma Warnings,  Up: Implementation Defined Pragmas

2.198 Pragma Weak_External
==========================

Syntax:

     pragma Weak_External ([Entity =>] LOCAL_NAME);

‘LOCAL_NAME’ must refer to an object that is declared at the library
level.  This pragma specifies that the given entity should be marked as
a weak symbol for the linker.  It is equivalent to
‘__attribute__((weak))’ in GNU C and causes ‘LOCAL_NAME’ to be emitted
as a weak symbol instead of a regular symbol, that is to say a symbol
that does not have to be resolved by the linker if used in conjunction
with a pragma Import.

When a weak symbol is not resolved by the linker, its address is set to
zero.  This is useful in writing interfaces to external modules that may
or may not be linked in the final executable, for example depending on
configuration settings.

If a program references at run time an entity to which this pragma has
been applied, and the corresponding symbol was not resolved at link
time, then the execution of the program is erroneous.  It is not
erroneous to take the Address of such an entity, for example to guard
potential references, as shown in the example below.

Some file formats do not support weak symbols so not all target machines
support this pragma.

     --  Example of the use of pragma Weak_External

     package External_Module is
       key : Integer;
       pragma Import (C, key);
       pragma Weak_External (key);
       function Present return boolean;
     end External_Module;

     with System; use System;
     package body External_Module is
       function Present return boolean is
       begin
         return key'Address /= System.Null_Address;
       end Present;
     end External_Module;


File: gnat_rm.info,  Node: Pragma Wide_Character_Encoding,  Prev: Pragma Weak_External,  Up: Implementation Defined Pragmas

2.199 Pragma Wide_Character_Encoding
====================================

Syntax:

     pragma Wide_Character_Encoding (IDENTIFIER | CHARACTER_LITERAL);

This pragma specifies the wide character encoding to be used in program
source text appearing subsequently.  It is a configuration pragma, but
may also be used at any point that a pragma is allowed, and it is
permissible to have more than one such pragma in a file, allowing
multiple encodings to appear within the same file.

However, note that the pragma cannot immediately precede the relevant
wide character, because then the previous encoding will still be in
effect, causing “illegal character” errors.

The argument can be an identifier or a character literal.  In the
identifier case, it is one of ‘HEX’, ‘UPPER’, ‘SHIFT_JIS’, ‘EUC’,
‘UTF8’, or ‘BRACKETS’.  In the character literal case it is
correspondingly one of the characters ‘h’, ‘u’, ‘s’, ‘e’, ‘8’, or ‘b’.

Note that when the pragma is used within a file, it affects only the
encoding within that file, and does not affect withed units, specs, or
subunits.


File: gnat_rm.info,  Node: Implementation Defined Aspects,  Next: Implementation Defined Attributes,  Prev: Implementation Defined Pragmas,  Up: Top

3 Implementation Defined Aspects
********************************

Ada defines (throughout the Ada 2012 reference manual, summarized in
Annex K) a set of aspects that can be specified for certain entities.
These language defined aspects are implemented in GNAT in Ada 2012 mode
and work as described in the Ada 2012 Reference Manual.

In addition, Ada 2012 allows implementations to define additional
aspects whose meaning is defined by the implementation.  GNAT provides a
number of these implementation-defined aspects which can be used to
extend and enhance the functionality of the compiler.  This section of
the GNAT reference manual describes these additional aspects.

Note that any program using these aspects may not be portable to other
compilers (although GNAT implements this set of aspects on all
platforms).  Therefore if portability to other compilers is an important
consideration, you should minimize the use of these aspects.

Note that for many of these aspects, the effect is essentially similar
to the use of a pragma or attribute specification with the same name
applied to the entity.  For example, if we write:

     type R is range 1 .. 100
       with Value_Size => 10;

then the effect is the same as:

     type R is range 1 .. 100;
     for R'Value_Size use 10;

and if we write:

     type R is new Integer
       with Shared => True;

then the effect is the same as:

     type R is new Integer;
     pragma Shared (R);

In the documentation below, such cases are simply marked as being
boolean aspects equivalent to the corresponding pragma or attribute
definition clause.

* Menu:

* Aspect Abstract_State::
* Aspect Annotate::
* Aspect Async_Readers::
* Aspect Async_Writers::
* Aspect Constant_After_Elaboration::
* Aspect Contract_Cases::
* Aspect Depends::
* Aspect Default_Initial_Condition::
* Aspect Dimension::
* Aspect Dimension_System::
* Aspect Disable_Controlled::
* Aspect Effective_Reads::
* Aspect Effective_Writes::
* Aspect Extensions_Visible::
* Aspect Favor_Top_Level::
* Aspect Ghost::
* Aspect Global::
* Aspect Initial_Condition::
* Aspect Initializes::
* Aspect Inline_Always::
* Aspect Invariant::
* Aspect Invariant’Class::
* Aspect Iterable::
* Aspect Linker_Section::
* Aspect Lock_Free::
* Aspect Max_Queue_Length::
* Aspect No_Caching::
* Aspect No_Elaboration_Code_All::
* Aspect No_Inline::
* Aspect No_Tagged_Streams::
* Aspect No_Task_Parts::
* Aspect Object_Size::
* Aspect Obsolescent::
* Aspect Part_Of::
* Aspect Persistent_BSS::
* Aspect Predicate::
* Aspect Pure_Function::
* Aspect Refined_Depends::
* Aspect Refined_Global::
* Aspect Refined_Post::
* Aspect Refined_State::
* Aspect Relaxed_Initialization::
* Aspect Remote_Access_Type::
* Aspect Secondary_Stack_Size::
* Aspect Scalar_Storage_Order::
* Aspect Shared::
* Aspect Simple_Storage_Pool::
* Aspect Simple_Storage_Pool_Type::
* Aspect SPARK_Mode::
* Aspect Suppress_Debug_Info::
* Aspect Suppress_Initialization::
* Aspect Test_Case::
* Aspect Thread_Local_Storage::
* Aspect Universal_Aliasing::
* Aspect Unmodified::
* Aspect Unreferenced::
* Aspect Unreferenced_Objects::
* Aspect Value_Size::
* Aspect Volatile_Full_Access::
* Aspect Volatile_Function::
* Aspect Warnings::


File: gnat_rm.info,  Node: Aspect Abstract_State,  Next: Aspect Annotate,  Up: Implementation Defined Aspects

3.1 Aspect Abstract_State
=========================

This aspect is equivalent to *note pragma Abstract_State: 1e.


File: gnat_rm.info,  Node: Aspect Annotate,  Next: Aspect Async_Readers,  Prev: Aspect Abstract_State,  Up: Implementation Defined Aspects

3.2 Aspect Annotate
===================

There are three forms of this aspect (where ID is an identifier, and ARG
is a general expression), corresponding to *note pragma Annotate: 28.

`Annotate => ID'

     Equivalent to ‘pragma Annotate (ID, Entity => Name);’

`Annotate => (ID)'

     Equivalent to ‘pragma Annotate (ID, Entity => Name);’

`Annotate => (ID ,ID {, ARG})'

     Equivalent to ‘pragma Annotate (ID, ID {, ARG}, Entity => Name);’


File: gnat_rm.info,  Node: Aspect Async_Readers,  Next: Aspect Async_Writers,  Prev: Aspect Annotate,  Up: Implementation Defined Aspects

3.3 Aspect Async_Readers
========================

This boolean aspect is equivalent to *note pragma Async_Readers: 2f.


File: gnat_rm.info,  Node: Aspect Async_Writers,  Next: Aspect Constant_After_Elaboration,  Prev: Aspect Async_Readers,  Up: Implementation Defined Aspects

3.4 Aspect Async_Writers
========================

This boolean aspect is equivalent to *note pragma Async_Writers: 31.


File: gnat_rm.info,  Node: Aspect Constant_After_Elaboration,  Next: Aspect Contract_Cases,  Prev: Aspect Async_Writers,  Up: Implementation Defined Aspects

3.5 Aspect Constant_After_Elaboration
=====================================

This aspect is equivalent to *note pragma Constant_After_Elaboration:
41.


File: gnat_rm.info,  Node: Aspect Contract_Cases,  Next: Aspect Depends,  Prev: Aspect Constant_After_Elaboration,  Up: Implementation Defined Aspects

3.6 Aspect Contract_Cases
=========================

This aspect is equivalent to *note pragma Contract_Cases: 43, the
sequence of clauses being enclosed in parentheses so that syntactically
it is an aggregate.


File: gnat_rm.info,  Node: Aspect Depends,  Next: Aspect Default_Initial_Condition,  Prev: Aspect Contract_Cases,  Up: Implementation Defined Aspects

3.7 Aspect Depends
==================

This aspect is equivalent to *note pragma Depends: 53.


File: gnat_rm.info,  Node: Aspect Default_Initial_Condition,  Next: Aspect Dimension,  Prev: Aspect Depends,  Up: Implementation Defined Aspects

3.8 Aspect Default_Initial_Condition
====================================

This aspect is equivalent to *note pragma Default_Initial_Condition: 4d.


File: gnat_rm.info,  Node: Aspect Dimension,  Next: Aspect Dimension_System,  Prev: Aspect Default_Initial_Condition,  Up: Implementation Defined Aspects

3.9 Aspect Dimension
====================

The ‘Dimension’ aspect is used to specify the dimensions of a given
subtype of a dimensioned numeric type.  The aspect also specifies a
symbol used when doing formatted output of dimensioned quantities.  The
syntax is:

     with Dimension =>
       ([Symbol =>] SYMBOL, DIMENSION_VALUE {, DIMENSION_Value})

     SYMBOL ::= STRING_LITERAL | CHARACTER_LITERAL

     DIMENSION_VALUE ::=
       RATIONAL
     | others               => RATIONAL
     | DISCRETE_CHOICE_LIST => RATIONAL

     RATIONAL ::= [-] NUMERIC_LITERAL [/ NUMERIC_LITERAL]

This aspect can only be applied to a subtype whose parent type has a
‘Dimension_System’ aspect.  The aspect must specify values for all
dimensions of the system.  The rational values are the powers of the
corresponding dimensions that are used by the compiler to verify that
physical (numeric) computations are dimensionally consistent.  For
example, the computation of a force must result in dimensions (L => 1, M
=> 1, T => -2).  For further examples of the usage of this aspect, see
package ‘System.Dim.Mks’.  Note that when the dimensioned type is an
integer type, then any dimension value must be an integer literal.


File: gnat_rm.info,  Node: Aspect Dimension_System,  Next: Aspect Disable_Controlled,  Prev: Aspect Dimension,  Up: Implementation Defined Aspects

3.10 Aspect Dimension_System
============================

The ‘Dimension_System’ aspect is used to define a system of dimensions
that will be used in subsequent subtype declarations with ‘Dimension’
aspects that reference this system.  The syntax is:

     with Dimension_System => (DIMENSION {, DIMENSION});

     DIMENSION ::= ([Unit_Name   =>] IDENTIFIER,
                    [Unit_Symbol =>] SYMBOL,
                    [Dim_Symbol  =>] SYMBOL)

     SYMBOL ::= CHARACTER_LITERAL | STRING_LITERAL

This aspect is applied to a type, which must be a numeric derived type
(typically a floating-point type), that will represent values within the
dimension system.  Each ‘DIMENSION’ corresponds to one particular
dimension.  A maximum of 7 dimensions may be specified.  ‘Unit_Name’ is
the name of the dimension (for example ‘Meter’).  ‘Unit_Symbol’ is the
shorthand used for quantities of this dimension (for example ‘m’ for
‘Meter’).  ‘Dim_Symbol’ gives the identification within the dimension
system (typically this is a single letter, e.g.  ‘L’ standing for length
for unit name ‘Meter’).  The ‘Unit_Symbol’ is used in formatted output
of dimensioned quantities.  The ‘Dim_Symbol’ is used in error messages
when numeric operations have inconsistent dimensions.

GNAT provides the standard definition of the International MKS system in
the run-time package ‘System.Dim.Mks’.  You can easily define similar
packages for cgs units or British units, and define conversion factors
between values in different systems.  The MKS system is characterized by
the following aspect:

     type Mks_Type is new Long_Long_Float with
       Dimension_System => (
         (Unit_Name => Meter,    Unit_Symbol => 'm',   Dim_Symbol => 'L'),
         (Unit_Name => Kilogram, Unit_Symbol => "kg",  Dim_Symbol => 'M'),
         (Unit_Name => Second,   Unit_Symbol => 's',   Dim_Symbol => 'T'),
         (Unit_Name => Ampere,   Unit_Symbol => 'A',   Dim_Symbol => 'I'),
         (Unit_Name => Kelvin,   Unit_Symbol => 'K',   Dim_Symbol => '@'),
         (Unit_Name => Mole,     Unit_Symbol => "mol", Dim_Symbol => 'N'),
         (Unit_Name => Candela,  Unit_Symbol => "cd",  Dim_Symbol => 'J'));

Note that in the above type definition, we use the ‘at’ symbol (‘@’) to
represent a theta character (avoiding the use of extended Latin-1
characters in this context).

See section ‘Performing Dimensionality Analysis in GNAT’ in the GNAT
Users Guide for detailed examples of use of the dimension system.


File: gnat_rm.info,  Node: Aspect Disable_Controlled,  Next: Aspect Effective_Reads,  Prev: Aspect Dimension_System,  Up: Implementation Defined Aspects

3.11 Aspect Disable_Controlled
==============================

The aspect ‘Disable_Controlled’ is defined for controlled record types.
If active, this aspect causes suppression of all related calls to
‘Initialize’, ‘Adjust’, and ‘Finalize’.  The intended use is for
conditional compilation, where for example you might want a record to be
controlled or not depending on whether some run-time check is enabled or
suppressed.


File: gnat_rm.info,  Node: Aspect Effective_Reads,  Next: Aspect Effective_Writes,  Prev: Aspect Disable_Controlled,  Up: Implementation Defined Aspects

3.12 Aspect Effective_Reads
===========================

This aspect is equivalent to *note pragma Effective_Reads: 58.


File: gnat_rm.info,  Node: Aspect Effective_Writes,  Next: Aspect Extensions_Visible,  Prev: Aspect Effective_Reads,  Up: Implementation Defined Aspects

3.13 Aspect Effective_Writes
============================

This aspect is equivalent to *note pragma Effective_Writes: 5a.


File: gnat_rm.info,  Node: Aspect Extensions_Visible,  Next: Aspect Favor_Top_Level,  Prev: Aspect Effective_Writes,  Up: Implementation Defined Aspects

3.14 Aspect Extensions_Visible
==============================

This aspect is equivalent to *note pragma Extensions_Visible: 65.


File: gnat_rm.info,  Node: Aspect Favor_Top_Level,  Next: Aspect Ghost,  Prev: Aspect Extensions_Visible,  Up: Implementation Defined Aspects

3.15 Aspect Favor_Top_Level
===========================

This boolean aspect is equivalent to *note pragma Favor_Top_Level: 6a.


File: gnat_rm.info,  Node: Aspect Ghost,  Next: Aspect Global,  Prev: Aspect Favor_Top_Level,  Up: Implementation Defined Aspects

3.16 Aspect Ghost
=================

This aspect is equivalent to *note pragma Ghost: 6e.


File: gnat_rm.info,  Node: Aspect Global,  Next: Aspect Initial_Condition,  Prev: Aspect Ghost,  Up: Implementation Defined Aspects

3.17 Aspect Global
==================

This aspect is equivalent to *note pragma Global: 70.


File: gnat_rm.info,  Node: Aspect Initial_Condition,  Next: Aspect Initializes,  Prev: Aspect Global,  Up: Implementation Defined Aspects

3.18 Aspect Initial_Condition
=============================

This aspect is equivalent to *note pragma Initial_Condition: 7d.


File: gnat_rm.info,  Node: Aspect Initializes,  Next: Aspect Inline_Always,  Prev: Aspect Initial_Condition,  Up: Implementation Defined Aspects

3.19 Aspect Initializes
=======================

This aspect is equivalent to *note pragma Initializes: 80.


File: gnat_rm.info,  Node: Aspect Inline_Always,  Next: Aspect Invariant,  Prev: Aspect Initializes,  Up: Implementation Defined Aspects

3.20 Aspect Inline_Always
=========================

This boolean aspect is equivalent to *note pragma Inline_Always: 82.


File: gnat_rm.info,  Node: Aspect Invariant,  Next: Aspect Invariant’Class,  Prev: Aspect Inline_Always,  Up: Implementation Defined Aspects

3.21 Aspect Invariant
=====================

This aspect is equivalent to *note pragma Invariant: 89.  It is a
synonym for the language defined aspect ‘Type_Invariant’ except that it
is separately controllable using pragma ‘Assertion_Policy’.


File: gnat_rm.info,  Node: Aspect Invariant’Class,  Next: Aspect Iterable,  Prev: Aspect Invariant,  Up: Implementation Defined Aspects

3.22 Aspect Invariant’Class
===========================

This aspect is equivalent to *note pragma Type_Invariant_Class: 100.  It
is a synonym for the language defined aspect ‘Type_Invariant'Class’
except that it is separately controllable using pragma
‘Assertion_Policy’.


File: gnat_rm.info,  Node: Aspect Iterable,  Next: Aspect Linker_Section,  Prev: Aspect Invariant’Class,  Up: Implementation Defined Aspects

3.23 Aspect Iterable
====================

This aspect provides a light-weight mechanism for loops and quantified
expressions over container types, without the overhead imposed by the
tampering checks of standard Ada 2012 iterators.  The value of the
aspect is an aggregate with six named components, of which the last
three are optional: ‘First’, ‘Next’, ‘Has_Element’, ‘Element’, ‘Last’,
and ‘Previous’.  When only the first three components are specified,
only the ‘for .. in’ form of iteration over cursors is available.  When
‘Element’ is specified, both this form and the ‘for .. of’ form of
iteration over elements are available.  If the last two components are
specified, reverse iterations over the container can be specified
(analogous to what can be done over predefined containers that support
the ‘Reverse_Iterator’ interface).  The following is a typical example
of use:

     type List is private with
         Iterable => (First        => First_Cursor,
                      Next         => Advance,
                      Has_Element  => Cursor_Has_Element,
                     [Element      => Get_Element]);

   * The value denoted by ‘First’ must denote a primitive operation of
     the container type that returns a ‘Cursor’, which must a be a type
     declared in the container package or visible from it.  For example:

     function First_Cursor (Cont : Container) return Cursor;

   * The value of ‘Next’ is a primitive operation of the container type
     that takes both a container and a cursor and yields a cursor.  For
     example:

     function Advance (Cont : Container; Position : Cursor) return Cursor;

   * The value of ‘Has_Element’ is a primitive operation of the
     container type that takes both a container and a cursor and yields
     a boolean.  For example:

     function Cursor_Has_Element (Cont : Container; Position : Cursor) return Boolean;

   * The value of ‘Element’ is a primitive operation of the container
     type that takes both a container and a cursor and yields an
     ‘Element_Type’, which must be a type declared in the container
     package or visible from it.  For example:

     function Get_Element (Cont : Container; Position : Cursor) return Element_Type;

This aspect is used in the GNAT-defined formal container packages.


File: gnat_rm.info,  Node: Aspect Linker_Section,  Next: Aspect Lock_Free,  Prev: Aspect Iterable,  Up: Implementation Defined Aspects

3.24 Aspect Linker_Section
==========================

This aspect is equivalent to *note pragma Linker_Section: 91.


File: gnat_rm.info,  Node: Aspect Lock_Free,  Next: Aspect Max_Queue_Length,  Prev: Aspect Linker_Section,  Up: Implementation Defined Aspects

3.25 Aspect Lock_Free
=====================

This boolean aspect is equivalent to *note pragma Lock_Free: 93.


File: gnat_rm.info,  Node: Aspect Max_Queue_Length,  Next: Aspect No_Caching,  Prev: Aspect Lock_Free,  Up: Implementation Defined Aspects

3.26 Aspect Max_Queue_Length
============================

This aspect is equivalent to *note pragma Max_Queue_Length: 9b.


File: gnat_rm.info,  Node: Aspect No_Caching,  Next: Aspect No_Elaboration_Code_All,  Prev: Aspect Max_Queue_Length,  Up: Implementation Defined Aspects

3.27 Aspect No_Caching
======================

This boolean aspect is equivalent to *note pragma No_Caching: 9e.


File: gnat_rm.info,  Node: Aspect No_Elaboration_Code_All,  Next: Aspect No_Inline,  Prev: Aspect No_Caching,  Up: Implementation Defined Aspects

3.28 Aspect No_Elaboration_Code_All
===================================

This aspect is equivalent to *note pragma No_Elaboration_Code_All: a1.
for a program unit.


File: gnat_rm.info,  Node: Aspect No_Inline,  Next: Aspect No_Tagged_Streams,  Prev: Aspect No_Elaboration_Code_All,  Up: Implementation Defined Aspects

3.29 Aspect No_Inline
=====================

This boolean aspect is equivalent to *note pragma No_Inline: a4.


File: gnat_rm.info,  Node: Aspect No_Tagged_Streams,  Next: Aspect No_Task_Parts,  Prev: Aspect No_Inline,  Up: Implementation Defined Aspects

3.30 Aspect No_Tagged_Streams
=============================

This aspect is equivalent to *note pragma No_Tagged_Streams: a8. with an
argument specifying a root tagged type (thus this aspect can only be
applied to such a type).


File: gnat_rm.info,  Node: Aspect No_Task_Parts,  Next: Aspect Object_Size,  Prev: Aspect No_Tagged_Streams,  Up: Implementation Defined Aspects

3.31 Aspect No_Task_Parts
=========================

Applies to a type.  If True, requires that the type and any descendants
do not have any task parts.  The rules for this aspect are the same as
for the language-defined No_Controlled_Parts aspect (see RM-H.4.1),
replacing “controlled” with “task”.

If No_Task_Parts is True for a type T, then the compiler can optimize
away certain tasking-related code that would otherwise be needed for
T’Class, because descendants of T might contain tasks.


File: gnat_rm.info,  Node: Aspect Object_Size,  Next: Aspect Obsolescent,  Prev: Aspect No_Task_Parts,  Up: Implementation Defined Aspects

3.32 Aspect Object_Size
=======================

This aspect is equivalent to *note attribute Object_Size: 140.


File: gnat_rm.info,  Node: Aspect Obsolescent,  Next: Aspect Part_Of,  Prev: Aspect Object_Size,  Up: Implementation Defined Aspects

3.33 Aspect Obsolescent
=======================

This aspect is equivalent to *note pragma Obsolescent: ab.  Note that
the evaluation of this aspect happens at the point of occurrence, it is
not delayed until the freeze point.


File: gnat_rm.info,  Node: Aspect Part_Of,  Next: Aspect Persistent_BSS,  Prev: Aspect Obsolescent,  Up: Implementation Defined Aspects

3.34 Aspect Part_Of
===================

This aspect is equivalent to *note pragma Part_Of: b2.


File: gnat_rm.info,  Node: Aspect Persistent_BSS,  Next: Aspect Predicate,  Prev: Aspect Part_Of,  Up: Implementation Defined Aspects

3.35 Aspect Persistent_BSS
==========================

This boolean aspect is equivalent to *note pragma Persistent_BSS: b5.


File: gnat_rm.info,  Node: Aspect Predicate,  Next: Aspect Pure_Function,  Prev: Aspect Persistent_BSS,  Up: Implementation Defined Aspects

3.36 Aspect Predicate
=====================

This aspect is equivalent to *note pragma Predicate: bc.  It is thus
similar to the language defined aspects ‘Dynamic_Predicate’ and
‘Static_Predicate’ except that whether the resulting predicate is static
or dynamic is controlled by the form of the expression.  It is also
separately controllable using pragma ‘Assertion_Policy’.


File: gnat_rm.info,  Node: Aspect Pure_Function,  Next: Aspect Refined_Depends,  Prev: Aspect Predicate,  Up: Implementation Defined Aspects

3.37 Aspect Pure_Function
=========================

This boolean aspect is equivalent to *note pragma Pure_Function: c8.


File: gnat_rm.info,  Node: Aspect Refined_Depends,  Next: Aspect Refined_Global,  Prev: Aspect Pure_Function,  Up: Implementation Defined Aspects

3.38 Aspect Refined_Depends
===========================

This aspect is equivalent to *note pragma Refined_Depends: cc.


File: gnat_rm.info,  Node: Aspect Refined_Global,  Next: Aspect Refined_Post,  Prev: Aspect Refined_Depends,  Up: Implementation Defined Aspects

3.39 Aspect Refined_Global
==========================

This aspect is equivalent to *note pragma Refined_Global: ce.


File: gnat_rm.info,  Node: Aspect Refined_Post,  Next: Aspect Refined_State,  Prev: Aspect Refined_Global,  Up: Implementation Defined Aspects

3.40 Aspect Refined_Post
========================

This aspect is equivalent to *note pragma Refined_Post: d0.


File: gnat_rm.info,  Node: Aspect Refined_State,  Next: Aspect Relaxed_Initialization,  Prev: Aspect Refined_Post,  Up: Implementation Defined Aspects

3.41 Aspect Refined_State
=========================

This aspect is equivalent to *note pragma Refined_State: d2.


File: gnat_rm.info,  Node: Aspect Relaxed_Initialization,  Next: Aspect Remote_Access_Type,  Prev: Aspect Refined_State,  Up: Implementation Defined Aspects

3.42 Aspect Relaxed_Initialization
==================================

For the syntax and semantics of this aspect, see the SPARK 2014
Reference Manual, section 6.10.


File: gnat_rm.info,  Node: Aspect Remote_Access_Type,  Next: Aspect Secondary_Stack_Size,  Prev: Aspect Relaxed_Initialization,  Up: Implementation Defined Aspects

3.43 Aspect Remote_Access_Type
==============================

This aspect is equivalent to *note pragma Remote_Access_Type: d5.


File: gnat_rm.info,  Node: Aspect Secondary_Stack_Size,  Next: Aspect Scalar_Storage_Order,  Prev: Aspect Remote_Access_Type,  Up: Implementation Defined Aspects

3.44 Aspect Secondary_Stack_Size
================================

This aspect is equivalent to *note pragma Secondary_Stack_Size: db.


File: gnat_rm.info,  Node: Aspect Scalar_Storage_Order,  Next: Aspect Shared,  Prev: Aspect Secondary_Stack_Size,  Up: Implementation Defined Aspects

3.45 Aspect Scalar_Storage_Order
================================

This aspect is equivalent to a *note attribute Scalar_Storage_Order:
14e.


File: gnat_rm.info,  Node: Aspect Shared,  Next: Aspect Simple_Storage_Pool,  Prev: Aspect Scalar_Storage_Order,  Up: Implementation Defined Aspects

3.46 Aspect Shared
==================

This boolean aspect is equivalent to *note pragma Shared: de. and is
thus a synonym for aspect ‘Atomic’.


File: gnat_rm.info,  Node: Aspect Simple_Storage_Pool,  Next: Aspect Simple_Storage_Pool_Type,  Prev: Aspect Shared,  Up: Implementation Defined Aspects

3.47 Aspect Simple_Storage_Pool
===============================

This aspect is equivalent to *note attribute Simple_Storage_Pool: e3.


File: gnat_rm.info,  Node: Aspect Simple_Storage_Pool_Type,  Next: Aspect SPARK_Mode,  Prev: Aspect Simple_Storage_Pool,  Up: Implementation Defined Aspects

3.48 Aspect Simple_Storage_Pool_Type
====================================

This boolean aspect is equivalent to *note pragma
Simple_Storage_Pool_Type: e2.


File: gnat_rm.info,  Node: Aspect SPARK_Mode,  Next: Aspect Suppress_Debug_Info,  Prev: Aspect Simple_Storage_Pool_Type,  Up: Implementation Defined Aspects

3.49 Aspect SPARK_Mode
======================

This aspect is equivalent to *note pragma SPARK_Mode: ea. and may be
specified for either or both of the specification and body of a
subprogram or package.


File: gnat_rm.info,  Node: Aspect Suppress_Debug_Info,  Next: Aspect Suppress_Initialization,  Prev: Aspect SPARK_Mode,  Up: Implementation Defined Aspects

3.50 Aspect Suppress_Debug_Info
===============================

This boolean aspect is equivalent to *note pragma Suppress_Debug_Info:
f2.


File: gnat_rm.info,  Node: Aspect Suppress_Initialization,  Next: Aspect Test_Case,  Prev: Aspect Suppress_Debug_Info,  Up: Implementation Defined Aspects

3.51 Aspect Suppress_Initialization
===================================

This boolean aspect is equivalent to *note pragma
Suppress_Initialization: f5.


File: gnat_rm.info,  Node: Aspect Test_Case,  Next: Aspect Thread_Local_Storage,  Prev: Aspect Suppress_Initialization,  Up: Implementation Defined Aspects

3.52 Aspect Test_Case
=====================

This aspect is equivalent to *note pragma Test_Case: f9.


File: gnat_rm.info,  Node: Aspect Thread_Local_Storage,  Next: Aspect Universal_Aliasing,  Prev: Aspect Test_Case,  Up: Implementation Defined Aspects

3.53 Aspect Thread_Local_Storage
================================

This boolean aspect is equivalent to *note pragma Thread_Local_Storage:
fb.


File: gnat_rm.info,  Node: Aspect Universal_Aliasing,  Next: Aspect Unmodified,  Prev: Aspect Thread_Local_Storage,  Up: Implementation Defined Aspects

3.54 Aspect Universal_Aliasing
==============================

This boolean aspect is equivalent to *note pragma Universal_Aliasing:
105.


File: gnat_rm.info,  Node: Aspect Unmodified,  Next: Aspect Unreferenced,  Prev: Aspect Universal_Aliasing,  Up: Implementation Defined Aspects

3.55 Aspect Unmodified
======================

This boolean aspect is equivalent to *note pragma Unmodified: 107.


File: gnat_rm.info,  Node: Aspect Unreferenced,  Next: Aspect Unreferenced_Objects,  Prev: Aspect Unmodified,  Up: Implementation Defined Aspects

3.56 Aspect Unreferenced
========================

This boolean aspect is equivalent to *note pragma Unreferenced: 109.

When using the ‘-gnat2022’ switch, this aspect is also supported on
formal parameters, which is in particular the only form possible for
expression functions.


File: gnat_rm.info,  Node: Aspect Unreferenced_Objects,  Next: Aspect Value_Size,  Prev: Aspect Unreferenced,  Up: Implementation Defined Aspects

3.57 Aspect Unreferenced_Objects
================================

This boolean aspect is equivalent to *note pragma Unreferenced_Objects:
10b.


File: gnat_rm.info,  Node: Aspect Value_Size,  Next: Aspect Volatile_Full_Access,  Prev: Aspect Unreferenced_Objects,  Up: Implementation Defined Aspects

3.58 Aspect Value_Size
======================

This aspect is equivalent to *note attribute Value_Size: 15c.


File: gnat_rm.info,  Node: Aspect Volatile_Full_Access,  Next: Aspect Volatile_Function,  Prev: Aspect Value_Size,  Up: Implementation Defined Aspects

3.59 Aspect Volatile_Full_Access
================================

This boolean aspect is equivalent to *note pragma Volatile_Full_Access:
115.


File: gnat_rm.info,  Node: Aspect Volatile_Function,  Next: Aspect Warnings,  Prev: Aspect Volatile_Full_Access,  Up: Implementation Defined Aspects

3.60 Aspect Volatile_Function
=============================

This boolean aspect is equivalent to *note pragma Volatile_Function:
117.


File: gnat_rm.info,  Node: Aspect Warnings,  Prev: Aspect Volatile_Function,  Up: Implementation Defined Aspects

3.61 Aspect Warnings
====================

This aspect is equivalent to the two argument form of *note pragma
Warnings: 119, where the first argument is ‘ON’ or ‘OFF’ and the second
argument is the entity.


File: gnat_rm.info,  Node: Implementation Defined Attributes,  Next: Standard and Implementation Defined Restrictions,  Prev: Implementation Defined Aspects,  Up: Top

4 Implementation Defined Attributes
***********************************

Ada defines (throughout the Ada reference manual, summarized in Annex
K), a set of attributes that provide useful additional functionality in
all areas of the language.  These language defined attributes are
implemented in GNAT and work as described in the Ada Reference Manual.

In addition, Ada allows implementations to define additional attributes
whose meaning is defined by the implementation.  GNAT provides a number
of these implementation-dependent attributes which can be used to extend
and enhance the functionality of the compiler.  This section of the GNAT
reference manual describes these additional attributes.  It also
describes additional implementation-dependent features of standard
language-defined attributes.

Note that any program using these attributes may not be portable to
other compilers (although GNAT implements this set of attributes on all
platforms).  Therefore if portability to other compilers is an important
consideration, you should minimize the use of these attributes.

* Menu:

* Attribute Abort_Signal::
* Attribute Address_Size::
* Attribute Asm_Input::
* Attribute Asm_Output::
* Attribute Atomic_Always_Lock_Free::
* Attribute Bit::
* Attribute Bit_Position::
* Attribute Code_Address::
* Attribute Compiler_Version::
* Attribute Constrained::
* Attribute Default_Bit_Order::
* Attribute Default_Scalar_Storage_Order::
* Attribute Deref::
* Attribute Descriptor_Size::
* Attribute Elaborated::
* Attribute Elab_Body::
* Attribute Elab_Spec::
* Attribute Elab_Subp_Body::
* Attribute Emax::
* Attribute Enabled::
* Attribute Enum_Rep::
* Attribute Enum_Val::
* Attribute Epsilon::
* Attribute Fast_Math::
* Attribute Finalization_Size::
* Attribute Fixed_Value::
* Attribute From_Any::
* Attribute Has_Access_Values::
* Attribute Has_Discriminants::
* Attribute Has_Tagged_Values::
* Attribute Img::
* Attribute Initialized::
* Attribute Integer_Value::
* Attribute Invalid_Value::
* Attribute Iterable::
* Attribute Large::
* Attribute Library_Level::
* Attribute Lock_Free::
* Attribute Loop_Entry::
* Attribute Machine_Size::
* Attribute Mantissa::
* Attribute Maximum_Alignment::
* Attribute Max_Integer_Size::
* Attribute Mechanism_Code::
* Attribute Null_Parameter::
* Attribute Object_Size::
* Attribute Old::
* Attribute Passed_By_Reference::
* Attribute Pool_Address::
* Attribute Range_Length::
* Attribute Restriction_Set::
* Attribute Result::
* Attribute Safe_Emax::
* Attribute Safe_Large::
* Attribute Safe_Small::
* Attribute Scalar_Storage_Order::
* Attribute Simple_Storage_Pool::
* Attribute Small::
* Attribute Small_Denominator::
* Attribute Small_Numerator::
* Attribute Storage_Unit::
* Attribute Stub_Type::
* Attribute System_Allocator_Alignment::
* Attribute Target_Name::
* Attribute To_Address::
* Attribute To_Any::
* Attribute Type_Class::
* Attribute Type_Key::
* Attribute TypeCode::
* Attribute Unconstrained_Array::
* Attribute Universal_Literal_String::
* Attribute Unrestricted_Access::
* Attribute Update::
* Attribute Valid_Image::
* Attribute Valid_Scalars::
* Attribute VADS_Size::
* Attribute Value_Size::
* Attribute Wchar_T_Size::
* Attribute Word_Size::


File: gnat_rm.info,  Node: Attribute Abort_Signal,  Next: Attribute Address_Size,  Up: Implementation Defined Attributes

4.1 Attribute Abort_Signal
==========================

‘Standard'Abort_Signal’ (‘Standard’ is the only allowed prefix) provides
the entity for the special exception used to signal task abort or
asynchronous transfer of control.  Normally this attribute should only
be used in the tasking runtime (it is highly peculiar, and completely
outside the normal semantics of Ada, for a user program to intercept the
abort exception).


File: gnat_rm.info,  Node: Attribute Address_Size,  Next: Attribute Asm_Input,  Prev: Attribute Abort_Signal,  Up: Implementation Defined Attributes

4.2 Attribute Address_Size
==========================

‘Standard'Address_Size’ (‘Standard’ is the only allowed prefix) is a
static constant giving the number of bits in an ‘Address’.  It is the
same value as System.Address’Size, but has the advantage of being
static, while a direct reference to System.Address’Size is nonstatic
because Address is a private type.


File: gnat_rm.info,  Node: Attribute Asm_Input,  Next: Attribute Asm_Output,  Prev: Attribute Address_Size,  Up: Implementation Defined Attributes

4.3 Attribute Asm_Input
=======================

The ‘Asm_Input’ attribute denotes a function that takes two parameters.
The first is a string, the second is an expression of the type
designated by the prefix.  The first (string) argument is required to be
a static expression, and is the constraint for the parameter, (e.g.,
what kind of register is required).  The second argument is the value to
be used as the input argument.  The possible values for the constant are
the same as those used in the RTL, and are dependent on the
configuration file used to built the GCC back end.  *note Machine Code
Insertions: 165.


File: gnat_rm.info,  Node: Attribute Asm_Output,  Next: Attribute Atomic_Always_Lock_Free,  Prev: Attribute Asm_Input,  Up: Implementation Defined Attributes

4.4 Attribute Asm_Output
========================

The ‘Asm_Output’ attribute denotes a function that takes two parameters.
The first is a string, the second is the name of a variable of the type
designated by the attribute prefix.  The first (string) argument is
required to be a static expression and designates the constraint for the
parameter (e.g., what kind of register is required).  The second
argument is the variable to be updated with the result.  The possible
values for constraint are the same as those used in the RTL, and are
dependent on the configuration file used to build the GCC back end.  If
there are no output operands, then this argument may either be omitted,
or explicitly given as ‘No_Output_Operands’.  *note Machine Code
Insertions: 165.


File: gnat_rm.info,  Node: Attribute Atomic_Always_Lock_Free,  Next: Attribute Bit,  Prev: Attribute Asm_Output,  Up: Implementation Defined Attributes

4.5 Attribute Atomic_Always_Lock_Free
=====================================

The prefix of the ‘Atomic_Always_Lock_Free’ attribute is a type.  The
result is a Boolean value which is True if the type has discriminants,
and False otherwise.  The result indicate whether atomic operations are
supported by the target for the given type.


File: gnat_rm.info,  Node: Attribute Bit,  Next: Attribute Bit_Position,  Prev: Attribute Atomic_Always_Lock_Free,  Up: Implementation Defined Attributes

4.6 Attribute Bit
=================

‘obj'Bit’, where ‘obj’ is any object, yields the bit offset within the
storage unit (byte) that contains the first bit of storage allocated for
the object.  The value of this attribute is of the type
`universal_integer' and is always a nonnegative number smaller than
‘System.Storage_Unit’.

For an object that is a variable or a constant allocated in a register,
the value is zero.  (The use of this attribute does not force the
allocation of a variable to memory).

For an object that is a formal parameter, this attribute applies to
either the matching actual parameter or to a copy of the matching actual
parameter.

For an access object the value is zero.  Note that ‘obj.all'Bit’ is
subject to an ‘Access_Check’ for the designated object.  Similarly for a
record component ‘X.C'Bit’ is subject to a discriminant check and
‘X(I).Bit’ and ‘X(I1..I2)'Bit’ are subject to index checks.

This attribute is designed to be compatible with the DEC Ada 83
definition and implementation of the ‘Bit’ attribute.


File: gnat_rm.info,  Node: Attribute Bit_Position,  Next: Attribute Code_Address,  Prev: Attribute Bit,  Up: Implementation Defined Attributes

4.7 Attribute Bit_Position
==========================

‘R.C'Bit_Position’, where ‘R’ is a record object and ‘C’ is one of the
fields of the record type, yields the bit offset within the record
contains the first bit of storage allocated for the object.  The value
of this attribute is of the type `universal_integer'.  The value depends
only on the field ‘C’ and is independent of the alignment of the
containing record ‘R’.


File: gnat_rm.info,  Node: Attribute Code_Address,  Next: Attribute Compiler_Version,  Prev: Attribute Bit_Position,  Up: Implementation Defined Attributes

4.8 Attribute Code_Address
==========================

The ‘'Address’ attribute may be applied to subprograms in Ada 95 and Ada
2005, but the intended effect seems to be to provide an address value
which can be used to call the subprogram by means of an address clause
as in the following example:

     procedure K is ...

     procedure L;
     for L'Address use K'Address;
     pragma Import (Ada, L);

A call to ‘L’ is then expected to result in a call to ‘K’.  In Ada 83,
where there were no access-to-subprogram values, this was a common
work-around for getting the effect of an indirect call.  GNAT implements
the above use of ‘Address’ and the technique illustrated by the example
code works correctly.

However, for some purposes, it is useful to have the address of the
start of the generated code for the subprogram.  On some architectures,
this is not necessarily the same as the ‘Address’ value described above.
For example, the ‘Address’ value may reference a subprogram descriptor
rather than the subprogram itself.

The ‘'Code_Address’ attribute, which can only be applied to subprogram
entities, always returns the address of the start of the generated code
of the specified subprogram, which may or may not be the same value as
is returned by the corresponding ‘'Address’ attribute.


File: gnat_rm.info,  Node: Attribute Compiler_Version,  Next: Attribute Constrained,  Prev: Attribute Code_Address,  Up: Implementation Defined Attributes

4.9 Attribute Compiler_Version
==============================

‘Standard'Compiler_Version’ (‘Standard’ is the only allowed prefix)
yields a static string identifying the version of the compiler being
used to compile the unit containing the attribute reference.


File: gnat_rm.info,  Node: Attribute Constrained,  Next: Attribute Default_Bit_Order,  Prev: Attribute Compiler_Version,  Up: Implementation Defined Attributes

4.10 Attribute Constrained
==========================

In addition to the usage of this attribute in the Ada RM, GNAT also
permits the use of the ‘'Constrained’ attribute in a generic template
for any type, including types without discriminants.  The value of this
attribute in the generic instance when applied to a scalar type or a
record type without discriminants is always ‘True’.  This usage is
compatible with older Ada compilers, including notably DEC Ada.


File: gnat_rm.info,  Node: Attribute Default_Bit_Order,  Next: Attribute Default_Scalar_Storage_Order,  Prev: Attribute Constrained,  Up: Implementation Defined Attributes

4.11 Attribute Default_Bit_Order
================================

‘Standard'Default_Bit_Order’ (‘Standard’ is the only allowed prefix),
provides the value ‘System.Default_Bit_Order’ as a ‘Pos’ value (0 for
‘High_Order_First’, 1 for ‘Low_Order_First’).  This is used to construct
the definition of ‘Default_Bit_Order’ in package ‘System’.


File: gnat_rm.info,  Node: Attribute Default_Scalar_Storage_Order,  Next: Attribute Deref,  Prev: Attribute Default_Bit_Order,  Up: Implementation Defined Attributes

4.12 Attribute Default_Scalar_Storage_Order
===========================================

‘Standard'Default_Scalar_Storage_Order’ (‘Standard’ is the only allowed
prefix), provides the current value of the default scalar storage order
(as specified using pragma ‘Default_Scalar_Storage_Order’, or equal to
‘Default_Bit_Order’ if unspecified) as a ‘System.Bit_Order’ value.  This
is a static attribute.


File: gnat_rm.info,  Node: Attribute Deref,  Next: Attribute Descriptor_Size,  Prev: Attribute Default_Scalar_Storage_Order,  Up: Implementation Defined Attributes

4.13 Attribute Deref
====================

The attribute ‘typ'Deref(expr)’ where ‘expr’ is of type ‘System.Address’
yields the variable of type ‘typ’ that is located at the given address.
It is similar to ‘(totyp (expr).all)’, where ‘totyp’ is an unchecked
conversion from address to a named access-to-‘typ’ type, except that it
yields a variable, so it can be used on the left side of an assignment.


File: gnat_rm.info,  Node: Attribute Descriptor_Size,  Next: Attribute Elaborated,  Prev: Attribute Deref,  Up: Implementation Defined Attributes

4.14 Attribute Descriptor_Size
==============================

Nonstatic attribute ‘Descriptor_Size’ returns the size in bits of the
descriptor allocated for a type.  The result is non-zero only for
unconstrained array types and the returned value is of type universal
integer.  In GNAT, an array descriptor contains bounds information and
is located immediately before the first element of the array.

     type Unconstr_Array is array (Short_Short_Integer range <>) of Positive;
     Put_Line ("Descriptor size = " & Unconstr_Array'Descriptor_Size'Img);

The attribute takes into account any padding due to the alignment of the
component type.  In the example above, the descriptor contains two
values of type ‘Short_Short_Integer’ representing the low and high
bound.  But, since ‘Positive’ has an alignment of 4, the size of the
descriptor is ‘2 * Short_Short_Integer'Size’ rounded up to the next
multiple of 32, which yields a size of 32 bits, i.e.  including 16 bits
of padding.


File: gnat_rm.info,  Node: Attribute Elaborated,  Next: Attribute Elab_Body,  Prev: Attribute Descriptor_Size,  Up: Implementation Defined Attributes

4.15 Attribute Elaborated
=========================

The prefix of the ‘'Elaborated’ attribute must be a unit name.  The
value is a Boolean which indicates whether or not the given unit has
been elaborated.  This attribute is primarily intended for internal use
by the generated code for dynamic elaboration checking, but it can also
be used in user programs.  The value will always be True once
elaboration of all units has been completed.  An exception is for units
which need no elaboration, the value is always False for such units.


File: gnat_rm.info,  Node: Attribute Elab_Body,  Next: Attribute Elab_Spec,  Prev: Attribute Elaborated,  Up: Implementation Defined Attributes

4.16 Attribute Elab_Body
========================

This attribute can only be applied to a program unit name.  It returns
the entity for the corresponding elaboration procedure for elaborating
the body of the referenced unit.  This is used in the main generated
elaboration procedure by the binder and is not normally used in any
other context.  However, there may be specialized situations in which it
is useful to be able to call this elaboration procedure from Ada code,
e.g., if it is necessary to do selective re-elaboration to fix some
error.


File: gnat_rm.info,  Node: Attribute Elab_Spec,  Next: Attribute Elab_Subp_Body,  Prev: Attribute Elab_Body,  Up: Implementation Defined Attributes

4.17 Attribute Elab_Spec
========================

This attribute can only be applied to a program unit name.  It returns
the entity for the corresponding elaboration procedure for elaborating
the spec of the referenced unit.  This is used in the main generated
elaboration procedure by the binder and is not normally used in any
other context.  However, there may be specialized situations in which it
is useful to be able to call this elaboration procedure from Ada code,
e.g., if it is necessary to do selective re-elaboration to fix some
error.


File: gnat_rm.info,  Node: Attribute Elab_Subp_Body,  Next: Attribute Emax,  Prev: Attribute Elab_Spec,  Up: Implementation Defined Attributes

4.18 Attribute Elab_Subp_Body
=============================

This attribute can only be applied to a library level subprogram name
and is only allowed in CodePeer mode.  It returns the entity for the
corresponding elaboration procedure for elaborating the body of the
referenced subprogram unit.  This is used in the main generated
elaboration procedure by the binder in CodePeer mode only and is
unrecognized otherwise.


File: gnat_rm.info,  Node: Attribute Emax,  Next: Attribute Enabled,  Prev: Attribute Elab_Subp_Body,  Up: Implementation Defined Attributes

4.19 Attribute Emax
===================

The ‘Emax’ attribute is provided for compatibility with Ada 83.  See the
Ada 83 reference manual for an exact description of the semantics of
this attribute.


File: gnat_rm.info,  Node: Attribute Enabled,  Next: Attribute Enum_Rep,  Prev: Attribute Emax,  Up: Implementation Defined Attributes

4.20 Attribute Enabled
======================

The ‘Enabled’ attribute allows an application program to check at
compile time to see if the designated check is currently enabled.  The
prefix is a simple identifier, referencing any predefined check name
(other than ‘All_Checks’) or a check name introduced by pragma
Check_Name.  If no argument is given for the attribute, the check is for
the general state of the check, if an argument is given, then it is an
entity name, and the check indicates whether an ‘Suppress’ or
‘Unsuppress’ has been given naming the entity (if not, then the argument
is ignored).

Note that instantiations inherit the check status at the point of the
instantiation, so a useful idiom is to have a library package that
introduces a check name with ‘pragma Check_Name’, and then contains
generic packages or subprograms which use the ‘Enabled’ attribute to see
if the check is enabled.  A user of this package can then issue a
‘pragma Suppress’ or ‘pragma Unsuppress’ before instantiating the
package or subprogram, controlling whether the check will be present.


File: gnat_rm.info,  Node: Attribute Enum_Rep,  Next: Attribute Enum_Val,  Prev: Attribute Enabled,  Up: Implementation Defined Attributes

4.21 Attribute Enum_Rep
=======================

Note that this attribute is now standard in Ada 202x and is available as
an implementation defined attribute for earlier Ada versions.

For every enumeration subtype ‘S’, ‘S'Enum_Rep’ denotes a function with
the following spec:

     function S'Enum_Rep (Arg : S'Base) return <Universal_Integer>;

It is also allowable to apply ‘Enum_Rep’ directly to an object of an
enumeration type or to a non-overloaded enumeration literal.  In this
case ‘S'Enum_Rep’ is equivalent to ‘typ'Enum_Rep(S)’ where ‘typ’ is the
type of the enumeration literal or object.

The function returns the representation value for the given enumeration
value.  This will be equal to value of the ‘Pos’ attribute in the
absence of an enumeration representation clause.  This is a static
attribute (i.e., the result is static if the argument is static).

‘S'Enum_Rep’ can also be used with integer types and objects, in which
case it simply returns the integer value.  The reason for this is to
allow it to be used for ‘(<>)’ discrete formal arguments in a generic
unit that can be instantiated with either enumeration types or integer
types.  Note that if ‘Enum_Rep’ is used on a modular type whose upper
bound exceeds the upper bound of the largest signed integer type, and
the argument is a variable, so that the universal integer calculation is
done at run time, then the call to ‘Enum_Rep’ may raise
‘Constraint_Error’.


File: gnat_rm.info,  Node: Attribute Enum_Val,  Next: Attribute Epsilon,  Prev: Attribute Enum_Rep,  Up: Implementation Defined Attributes

4.22 Attribute Enum_Val
=======================

Note that this attribute is now standard in Ada 202x and is available as
an implementation defined attribute for earlier Ada versions.

For every enumeration subtype ‘S’, ‘S'Enum_Val’ denotes a function with
the following spec:

     function S'Enum_Val (Arg : <Universal_Integer>) return S'Base;

The function returns the enumeration value whose representation matches
the argument, or raises Constraint_Error if no enumeration literal of
the type has the matching value.  This will be equal to value of the
‘Val’ attribute in the absence of an enumeration representation clause.
This is a static attribute (i.e., the result is static if the argument
is static).


File: gnat_rm.info,  Node: Attribute Epsilon,  Next: Attribute Fast_Math,  Prev: Attribute Enum_Val,  Up: Implementation Defined Attributes

4.23 Attribute Epsilon
======================

The ‘Epsilon’ attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.


File: gnat_rm.info,  Node: Attribute Fast_Math,  Next: Attribute Finalization_Size,  Prev: Attribute Epsilon,  Up: Implementation Defined Attributes

4.24 Attribute Fast_Math
========================

‘Standard'Fast_Math’ (‘Standard’ is the only allowed prefix) yields a
static Boolean value that is True if pragma ‘Fast_Math’ is active, and
False otherwise.


File: gnat_rm.info,  Node: Attribute Finalization_Size,  Next: Attribute Fixed_Value,  Prev: Attribute Fast_Math,  Up: Implementation Defined Attributes

4.25 Attribute Finalization_Size
================================

The prefix of attribute ‘Finalization_Size’ must be an object or a
non-class-wide type.  This attribute returns the size of any hidden data
reserved by the compiler to handle finalization-related actions.  The
type of the attribute is `universal_integer'.

‘Finalization_Size’ yields a value of zero for a type with no controlled
parts, an object whose type has no controlled parts, or an object of a
class-wide type whose tag denotes a type with no controlled parts.

Note that only heap-allocated objects contain finalization data.


File: gnat_rm.info,  Node: Attribute Fixed_Value,  Next: Attribute From_Any,  Prev: Attribute Finalization_Size,  Up: Implementation Defined Attributes

4.26 Attribute Fixed_Value
==========================

For every fixed-point type ‘S’, ‘S'Fixed_Value’ denotes a function with
the following specification:

     function S'Fixed_Value (Arg : <Universal_Integer>) return S;

The value returned is the fixed-point value ‘V’ such that:

     V = Arg * S'Small

The effect is thus similar to first converting the argument to the
integer type used to represent ‘S’, and then doing an unchecked
conversion to the fixed-point type.  The difference is that there are
full range checks, to ensure that the result is in range.  This
attribute is primarily intended for use in implementation of the
input-output functions for fixed-point values.


File: gnat_rm.info,  Node: Attribute From_Any,  Next: Attribute Has_Access_Values,  Prev: Attribute Fixed_Value,  Up: Implementation Defined Attributes

4.27 Attribute From_Any
=======================

This internal attribute is used for the generation of remote subprogram
stubs in the context of the Distributed Systems Annex.


File: gnat_rm.info,  Node: Attribute Has_Access_Values,  Next: Attribute Has_Discriminants,  Prev: Attribute From_Any,  Up: Implementation Defined Attributes

4.28 Attribute Has_Access_Values
================================

The prefix of the ‘Has_Access_Values’ attribute is a type.  The result
is a Boolean value which is True if the is an access type, or is a
composite type with a component (at any nesting depth) that is an access
type, and is False otherwise.  The intended use of this attribute is in
conjunction with generic definitions.  If the attribute is applied to a
generic private type, it indicates whether or not the corresponding
actual type has access values.


File: gnat_rm.info,  Node: Attribute Has_Discriminants,  Next: Attribute Has_Tagged_Values,  Prev: Attribute Has_Access_Values,  Up: Implementation Defined Attributes

4.29 Attribute Has_Discriminants
================================

The prefix of the ‘Has_Discriminants’ attribute is a type.  The result
is a Boolean value which is True if the type has discriminants, and
False otherwise.  The intended use of this attribute is in conjunction
with generic definitions.  If the attribute is applied to a generic
private type, it indicates whether or not the corresponding actual type
has discriminants.


File: gnat_rm.info,  Node: Attribute Has_Tagged_Values,  Next: Attribute Img,  Prev: Attribute Has_Discriminants,  Up: Implementation Defined Attributes

4.30 Attribute Has_Tagged_Values
================================

The prefix of the ‘Has_Tagged_Values’ attribute is a type.  The result
is a Boolean value which is True if the type is a composite type (array
or record) that is either a tagged type or has a subcomponent that is
tagged, and is False otherwise.  The intended use of this attribute is
in conjunction with generic definitions.  If the attribute is applied to
a generic private type, it indicates whether or not the corresponding
actual type has access values.


File: gnat_rm.info,  Node: Attribute Img,  Next: Attribute Initialized,  Prev: Attribute Has_Tagged_Values,  Up: Implementation Defined Attributes

4.31 Attribute Img
==================

The ‘Img’ attribute differs from ‘Image’ in that, while both can be
applied directly to an object, ‘Img’ cannot be applied to types.

Example usage of the attribute:

     Put_Line ("X = " & X'Img);

which has the same meaning as the more verbose:

     Put_Line ("X = " & T'Image (X));

where ‘T’ is the (sub)type of the object ‘X’.

Note that technically, in analogy to ‘Image’, ‘X'Img’ returns a
parameterless function that returns the appropriate string when called.
This means that ‘X'Img’ can be renamed as a function-returning-string,
or used in an instantiation as a function parameter.


File: gnat_rm.info,  Node: Attribute Initialized,  Next: Attribute Integer_Value,  Prev: Attribute Img,  Up: Implementation Defined Attributes

4.32 Attribute Initialized
==========================

For the syntax and semantics of this attribute, see the SPARK 2014
Reference Manual, section 6.10.


File: gnat_rm.info,  Node: Attribute Integer_Value,  Next: Attribute Invalid_Value,  Prev: Attribute Initialized,  Up: Implementation Defined Attributes

4.33 Attribute Integer_Value
============================

For every integer type ‘S’, ‘S'Integer_Value’ denotes a function with
the following spec:

     function S'Integer_Value (Arg : <Universal_Fixed>) return S;

The value returned is the integer value ‘V’, such that:

     Arg = V * T'Small

where ‘T’ is the type of ‘Arg’.  The effect is thus similar to first
doing an unchecked conversion from the fixed-point type to its
corresponding implementation type, and then converting the result to the
target integer type.  The difference is that there are full range
checks, to ensure that the result is in range.  This attribute is
primarily intended for use in implementation of the standard
input-output functions for fixed-point values.


File: gnat_rm.info,  Node: Attribute Invalid_Value,  Next: Attribute Iterable,  Prev: Attribute Integer_Value,  Up: Implementation Defined Attributes

4.34 Attribute Invalid_Value
============================

For every scalar type S, S’Invalid_Value returns an undefined value of
the type.  If possible this value is an invalid representation for the
type.  The value returned is identical to the value used to initialize
an otherwise uninitialized value of the type if pragma
Initialize_Scalars is used, including the ability to modify the value
with the binder -Sxx flag and relevant environment variables at run
time.


File: gnat_rm.info,  Node: Attribute Iterable,  Next: Attribute Large,  Prev: Attribute Invalid_Value,  Up: Implementation Defined Attributes

4.35 Attribute Iterable
=======================

Equivalent to Aspect Iterable.


File: gnat_rm.info,  Node: Attribute Large,  Next: Attribute Library_Level,  Prev: Attribute Iterable,  Up: Implementation Defined Attributes

4.36 Attribute Large
====================

The ‘Large’ attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.


File: gnat_rm.info,  Node: Attribute Library_Level,  Next: Attribute Lock_Free,  Prev: Attribute Large,  Up: Implementation Defined Attributes

4.37 Attribute Library_Level
============================

‘P'Library_Level’, where P is an entity name, returns a Boolean value
which is True if the entity is declared at the library level, and False
otherwise.  Note that within a generic instantition, the name of the
generic unit denotes the instance, which means that this attribute can
be used to test if a generic is instantiated at the library level, as
shown in this example:

     generic
       ...
     package Gen is
       pragma Compile_Time_Error
         (not Gen'Library_Level,
          "Gen can only be instantiated at library level");
       ...
     end Gen;


File: gnat_rm.info,  Node: Attribute Lock_Free,  Next: Attribute Loop_Entry,  Prev: Attribute Library_Level,  Up: Implementation Defined Attributes

4.38 Attribute Lock_Free
========================

‘P'Lock_Free’, where P is a protected object, returns True if a pragma
‘Lock_Free’ applies to P.


File: gnat_rm.info,  Node: Attribute Loop_Entry,  Next: Attribute Machine_Size,  Prev: Attribute Lock_Free,  Up: Implementation Defined Attributes

4.39 Attribute Loop_Entry
=========================

Syntax:

     X'Loop_Entry [(loop_name)]

The ‘Loop_Entry’ attribute is used to refer to the value that an
expression had upon entry to a given loop in much the same way that the
‘Old’ attribute in a subprogram postcondition can be used to refer to
the value an expression had upon entry to the subprogram.  The relevant
loop is either identified by the given loop name, or it is the innermost
enclosing loop when no loop name is given.

A ‘Loop_Entry’ attribute can only occur within a ‘Loop_Variant’ or
‘Loop_Invariant’ pragma.  A common use of ‘Loop_Entry’ is to compare the
current value of objects with their initial value at loop entry, in a
‘Loop_Invariant’ pragma.

The effect of using ‘X'Loop_Entry’ is the same as declaring a constant
initialized with the initial value of ‘X’ at loop entry.  This copy is
not performed if the loop is not entered, or if the corresponding
pragmas are ignored or disabled.


File: gnat_rm.info,  Node: Attribute Machine_Size,  Next: Attribute Mantissa,  Prev: Attribute Loop_Entry,  Up: Implementation Defined Attributes

4.40 Attribute Machine_Size
===========================

This attribute is identical to the ‘Object_Size’ attribute.  It is
provided for compatibility with the DEC Ada 83 attribute of this name.


File: gnat_rm.info,  Node: Attribute Mantissa,  Next: Attribute Maximum_Alignment,  Prev: Attribute Machine_Size,  Up: Implementation Defined Attributes

4.41 Attribute Mantissa
=======================

The ‘Mantissa’ attribute is provided for compatibility with Ada 83.  See
the Ada 83 reference manual for an exact description of the semantics of
this attribute.


File: gnat_rm.info,  Node: Attribute Maximum_Alignment,  Next: Attribute Max_Integer_Size,  Prev: Attribute Mantissa,  Up: Implementation Defined Attributes

4.42 Attribute Maximum_Alignment
================================

‘Standard'Maximum_Alignment’ (‘Standard’ is the only allowed prefix)
provides the maximum useful alignment value for the target.  This is a
static value that can be used to specify the alignment for an object,
guaranteeing that it is properly aligned in all cases.


File: gnat_rm.info,  Node: Attribute Max_Integer_Size,  Next: Attribute Mechanism_Code,  Prev: Attribute Maximum_Alignment,  Up: Implementation Defined Attributes

4.43 Attribute Max_Integer_Size
===============================

‘Standard'Max_Integer_Size’ (‘Standard’ is the only allowed prefix)
provides the size of the largest supported integer type for the target.
The result is a static constant.


File: gnat_rm.info,  Node: Attribute Mechanism_Code,  Next: Attribute Null_Parameter,  Prev: Attribute Max_Integer_Size,  Up: Implementation Defined Attributes

4.44 Attribute Mechanism_Code
=============================

‘func'Mechanism_Code’ yields an integer code for the mechanism used for
the result of function ‘func’, and ‘subprog'Mechanism_Code (n)’ yields
the mechanism used for formal parameter number `n' (a static integer
value, with 1 meaning the first parameter) of subprogram ‘subprog’.  The
code returned is:

`1'

     by copy (value)

`2'

     by reference


File: gnat_rm.info,  Node: Attribute Null_Parameter,  Next: Attribute Object_Size,  Prev: Attribute Mechanism_Code,  Up: Implementation Defined Attributes

4.45 Attribute Null_Parameter
=============================

A reference ‘T'Null_Parameter’ denotes an imaginary object of type or
subtype ‘T’ allocated at machine address zero.  The attribute is allowed
only as the default expression of a formal parameter, or as an actual
expression of a subprogram call.  In either case, the subprogram must be
imported.

The identity of the object is represented by the address zero in the
argument list, independent of the passing mechanism (explicit or
default).

This capability is needed to specify that a zero address should be
passed for a record or other composite object passed by reference.
There is no way of indicating this without the ‘Null_Parameter’
attribute.


File: gnat_rm.info,  Node: Attribute Object_Size,  Next: Attribute Old,  Prev: Attribute Null_Parameter,  Up: Implementation Defined Attributes

4.46 Attribute Object_Size
==========================

The size of an object is not necessarily the same as the size of the
type of an object.  This is because by default object sizes are
increased to be a multiple of the alignment of the object.  For example,
‘Natural'Size’ is 31, but by default objects of type ‘Natural’ will have
a size of 32 bits.  Similarly, a record containing an integer and a
character:

     type Rec is record
        I : Integer;
        C : Character;
     end record;

will have a size of 40 (that is ‘Rec'Size’ will be 40).  The alignment
will be 4, because of the integer field, and so the default size of
record objects for this type will be 64 (8 bytes).

If the alignment of the above record is specified to be 1, then the
object size will be 40 (5 bytes).  This is true by default, and also an
object size of 40 can be explicitly specified in this case.

A consequence of this capability is that different object sizes can be
given to subtypes that would otherwise be considered in Ada to be
statically matching.  But it makes no sense to consider such subtypes as
statically matching.  Consequently, GNAT adds a rule to the static
matching rules that requires object sizes to match.  Consider this
example:

      1. procedure BadAVConvert is
      2.    type R is new Integer;
      3.    subtype R1 is R range 1 .. 10;
      4.    subtype R2 is R range 1 .. 10;
      5.    for R1'Object_Size use 8;
      6.    for R2'Object_Size use 16;
      7.    type R1P is access all R1;
      8.    type R2P is access all R2;
      9.    R1PV : R1P := new R1'(4);
     10.    R2PV : R2P;
     11. begin
     12.    R2PV := R2P (R1PV);
                    |
            >>> target designated subtype not compatible with
                type "R1" defined at line 3

     13. end;

In the absence of lines 5 and 6, types ‘R1’ and ‘R2’ statically match
and hence the conversion on line 12 is legal.  But since lines 5 and 6
cause the object sizes to differ, GNAT considers that types ‘R1’ and
‘R2’ are not statically matching, and line 12 generates the diagnostic
shown above.

Similar additional checks are performed in other contexts requiring
statically matching subtypes.


File: gnat_rm.info,  Node: Attribute Old,  Next: Attribute Passed_By_Reference,  Prev: Attribute Object_Size,  Up: Implementation Defined Attributes

4.47 Attribute Old
==================

In addition to the usage of ‘Old’ defined in the Ada 2012 RM (usage
within ‘Post’ aspect), GNAT also permits the use of this attribute in
implementation defined pragmas ‘Postcondition’, ‘Contract_Cases’ and
‘Test_Case’.  Also usages of ‘Old’ which would be illegal according to
the Ada 2012 RM definition are allowed under control of implementation
defined pragma ‘Unevaluated_Use_Of_Old’.


File: gnat_rm.info,  Node: Attribute Passed_By_Reference,  Next: Attribute Pool_Address,  Prev: Attribute Old,  Up: Implementation Defined Attributes

4.48 Attribute Passed_By_Reference
==================================

‘typ'Passed_By_Reference’ for any subtype ‘typ’ returns a value of type
‘Boolean’ value that is ‘True’ if the type is normally passed by
reference and ‘False’ if the type is normally passed by copy in calls.
For scalar types, the result is always ‘False’ and is static.  For
non-scalar types, the result is nonstatic.


File: gnat_rm.info,  Node: Attribute Pool_Address,  Next: Attribute Range_Length,  Prev: Attribute Passed_By_Reference,  Up: Implementation Defined Attributes

4.49 Attribute Pool_Address
===========================

‘X'Pool_Address’ for any object ‘X’ returns the address of X within its
storage pool.  This is the same as ‘X'Address’, except that for an
unconstrained array whose bounds are allocated just before the first
component, ‘X'Pool_Address’ returns the address of those bounds, whereas
‘X'Address’ returns the address of the first component.

Here, we are interpreting ‘storage pool’ broadly to mean ‘wherever the
object is allocated’, which could be a user-defined storage pool, the
global heap, on the stack, or in a static memory area.  For an object
created by ‘new’, ‘Ptr.all'Pool_Address’ is what is passed to ‘Allocate’
and returned from ‘Deallocate’.


File: gnat_rm.info,  Node: Attribute Range_Length,  Next: Attribute Restriction_Set,  Prev: Attribute Pool_Address,  Up: Implementation Defined Attributes

4.50 Attribute Range_Length
===========================

‘typ'Range_Length’ for any discrete type ‘typ’ yields the number of
values represented by the subtype (zero for a null range).  The result
is static for static subtypes.  ‘Range_Length’ applied to the index
subtype of a one dimensional array always gives the same result as
‘Length’ applied to the array itself.


File: gnat_rm.info,  Node: Attribute Restriction_Set,  Next: Attribute Result,  Prev: Attribute Range_Length,  Up: Implementation Defined Attributes

4.51 Attribute Restriction_Set
==============================

This attribute allows compile time testing of restrictions that are
currently in effect.  It is primarily intended for specializing code in
the run-time based on restrictions that are active (e.g.  don’t need to
save fpt registers if restriction No_Floating_Point is known to be in
effect), but can be used anywhere.

There are two forms:

     System'Restriction_Set (partition_boolean_restriction_NAME)
     System'Restriction_Set (No_Dependence => library_unit_NAME);

In the case of the first form, the only restriction names allowed are
parameterless restrictions that are checked for consistency at bind
time.  For a complete list see the subtype
‘System.Rident.Partition_Boolean_Restrictions’.

The result returned is True if the restriction is known to be in effect,
and False if the restriction is known not to be in effect.  An important
guarantee is that the value of a Restriction_Set attribute is known to
be consistent throughout all the code of a partition.

This is trivially achieved if the entire partition is compiled with a
consistent set of restriction pragmas.  However, the compilation model
does not require this.  It is possible to compile one set of units with
one set of pragmas, and another set of units with another set of
pragmas.  It is even possible to compile a spec with one set of pragmas,
and then WITH the same spec with a different set of pragmas.
Inconsistencies in the actual use of the restriction are checked at bind
time.

In order to achieve the guarantee of consistency for the Restriction_Set
pragma, we consider that a use of the pragma that yields False is
equivalent to a violation of the restriction.

So for example if you write

     if System'Restriction_Set (No_Floating_Point) then
        ...
     else
        ...
     end if;

And the result is False, so that the else branch is executed, you can
assume that this restriction is not set for any unit in the partition.
This is checked by considering this use of the restriction pragma to be
a violation of the restriction No_Floating_Point.  This means that no
other unit can attempt to set this restriction (if some unit does
attempt to set it, the binder will refuse to bind the partition).

Technical note: The restriction name and the unit name are intepreted
entirely syntactically, as in the corresponding Restrictions pragma,
they are not analyzed semantically, so they do not have a type.


File: gnat_rm.info,  Node: Attribute Result,  Next: Attribute Safe_Emax,  Prev: Attribute Restriction_Set,  Up: Implementation Defined Attributes

4.52 Attribute Result
=====================

‘function'Result’ can only be used with in a Postcondition pragma for a
function.  The prefix must be the name of the corresponding function.
This is used to refer to the result of the function in the postcondition
expression.  For a further discussion of the use of this attribute and
examples of its use, see the description of pragma Postcondition.


File: gnat_rm.info,  Node: Attribute Safe_Emax,  Next: Attribute Safe_Large,  Prev: Attribute Result,  Up: Implementation Defined Attributes

4.53 Attribute Safe_Emax
========================

The ‘Safe_Emax’ attribute is provided for compatibility with Ada 83.
See the Ada 83 reference manual for an exact description of the
semantics of this attribute.


File: gnat_rm.info,  Node: Attribute Safe_Large,  Next: Attribute Safe_Small,  Prev: Attribute Safe_Emax,  Up: Implementation Defined Attributes

4.54 Attribute Safe_Large
=========================

The ‘Safe_Large’ attribute is provided for compatibility with Ada 83.
See the Ada 83 reference manual for an exact description of the
semantics of this attribute.


File: gnat_rm.info,  Node: Attribute Safe_Small,  Next: Attribute Scalar_Storage_Order,  Prev: Attribute Safe_Large,  Up: Implementation Defined Attributes

4.55 Attribute Safe_Small
=========================

The ‘Safe_Small’ attribute is provided for compatibility with Ada 83.
See the Ada 83 reference manual for an exact description of the
semantics of this attribute.


File: gnat_rm.info,  Node: Attribute Scalar_Storage_Order,  Next: Attribute Simple_Storage_Pool,  Prev: Attribute Safe_Small,  Up: Implementation Defined Attributes

4.56 Attribute Scalar_Storage_Order
===================================

For every array or record type ‘S’, the representation attribute
‘Scalar_Storage_Order’ denotes the order in which storage elements that
make up scalar components are ordered within S. The value given must be
a static expression of type System.Bit_Order.  The following is an
example of the use of this feature:

     --  Component type definitions

     subtype Yr_Type is Natural range 0 .. 127;
     subtype Mo_Type is Natural range 1 .. 12;
     subtype Da_Type is Natural range 1 .. 31;

     --  Record declaration

     type Date is record
        Years_Since_1980 : Yr_Type;
        Month            : Mo_Type;
        Day_Of_Month     : Da_Type;
     end record;

     --  Record representation clause

     for Date use record
        Years_Since_1980 at 0 range 0  ..  6;
        Month            at 0 range 7  .. 10;
        Day_Of_Month     at 0 range 11 .. 15;
     end record;

     --  Attribute definition clauses

     for Date'Bit_Order use System.High_Order_First;
     for Date'Scalar_Storage_Order use System.High_Order_First;
     --  If Scalar_Storage_Order is specified, it must be consistent with
     --  Bit_Order, so it's best to always define the latter explicitly if
     --  the former is used.

Other properties are as for the standard representation attribute
‘Bit_Order’ defined by Ada RM 13.5.3(4).  The default is
‘System.Default_Bit_Order’.

For a record type ‘T’, if ‘T'Scalar_Storage_Order’ is specified
explicitly, it shall be equal to ‘T'Bit_Order’.  Note: this means that
if a ‘Scalar_Storage_Order’ attribute definition clause is not
confirming, then the type’s ‘Bit_Order’ shall be specified explicitly
and set to the same value.

Derived types inherit an explicitly set scalar storage order from their
parent types.  This may be overridden for the derived type by giving an
explicit scalar storage order for it.  However, for a record extension,
the derived type must have the same scalar storage order as the parent
type.

A component of a record type that is itself a record or an array and
that does not start and end on a byte boundary must have have the same
scalar storage order as the record type.  A component of a bit-packed
array type that is itself a record or an array must have the same scalar
storage order as the array type.

No component of a type that has an explicit ‘Scalar_Storage_Order’
attribute definition may be aliased.

A confirming ‘Scalar_Storage_Order’ attribute definition clause (i.e.
with a value equal to ‘System.Default_Bit_Order’) has no effect.

If the opposite storage order is specified, then whenever the value of a
scalar component of an object of type ‘S’ is read, the storage elements
of the enclosing machine scalar are first reversed (before retrieving
the component value, possibly applying some shift and mask operatings on
the enclosing machine scalar), and the opposite operation is done for
writes.

In that case, the restrictions set forth in 13.5.1(10.3/2) for scalar
components are relaxed.  Instead, the following rules apply:

   * the underlying storage elements are those at positions ‘(position +
     first_bit / storage_element_size) .. (position + (last_bit +
     storage_element_size - 1) / storage_element_size)’

   * the sequence of underlying storage elements shall have a size no
     greater than the largest machine scalar

   * the enclosing machine scalar is defined as the smallest machine
     scalar starting at a position no greater than ‘position + first_bit
     / storage_element_size’ and covering storage elements at least up
     to ‘position + (last_bit + storage_element_size - 1) /
     storage_element_size`’

   * the position of the component is interpreted relative to that
     machine scalar.

If no scalar storage order is specified for a type (either directly, or
by inheritance in the case of a derived type), then the default is
normally the native ordering of the target, but this default can be
overridden using pragma ‘Default_Scalar_Storage_Order’.

If a component of ‘T’ is itself of a record or array type, the specfied
‘Scalar_Storage_Order’ does `not' apply to that nested type: an explicit
attribute definition clause must be provided for the component type as
well if desired.

Representation changes that explicitly or implicitly toggle the scalar
storage order are not supported and may result in erroneous execution of
the program, except when performed by means of an instance of
‘Ada.Unchecked_Conversion’.

In particular, overlays are not supported and a warning is given for
them:

     type Rec_LE is record
        I : Integer;
     end record;

     for Rec_LE use record
        I at 0 range 0 .. 31;
     end record;

     for Rec_LE'Bit_Order use System.Low_Order_First;
     for Rec_LE'Scalar_Storage_Order use System.Low_Order_First;

     type Rec_BE is record
        I : Integer;
     end record;

     for Rec_BE use record
        I at 0 range 0 .. 31;
     end record;

     for Rec_BE'Bit_Order use System.High_Order_First;
     for Rec_BE'Scalar_Storage_Order use System.High_Order_First;

     R_LE : Rec_LE;

     R_BE : Rec_BE;
     for R_BE'Address use R_LE'Address;

‘warning: overlay changes scalar storage order [enabled by default]’

In most cases, such representation changes ought to be replaced by an
instantiation of a function or procedure provided by
‘GNAT.Byte_Swapping’.

Note that the scalar storage order only affects the in-memory data
representation.  It has no effect on the representation used by stream
attributes.

Note that debuggers may be unable to display the correct value of scalar
components of a type for which the opposite storage order is specified.


File: gnat_rm.info,  Node: Attribute Simple_Storage_Pool,  Next: Attribute Small,  Prev: Attribute Scalar_Storage_Order,  Up: Implementation Defined Attributes

4.57 Attribute Simple_Storage_Pool
==================================

For every nonformal, nonderived access-to-object type ‘Acc’, the
representation attribute ‘Simple_Storage_Pool’ may be specified via an
attribute_definition_clause (or by specifying the equivalent aspect):

     My_Pool : My_Simple_Storage_Pool_Type;

     type Acc is access My_Data_Type;

     for Acc'Simple_Storage_Pool use My_Pool;

The name given in an attribute_definition_clause for the
‘Simple_Storage_Pool’ attribute shall denote a variable of a ‘simple
storage pool type’ (see pragma ‘Simple_Storage_Pool_Type’).

The use of this attribute is only allowed for a prefix denoting a type
for which it has been specified.  The type of the attribute is the type
of the variable specified as the simple storage pool of the access type,
and the attribute denotes that variable.

It is illegal to specify both ‘Storage_Pool’ and ‘Simple_Storage_Pool’
for the same access type.

If the ‘Simple_Storage_Pool’ attribute has been specified for an access
type, then applying the ‘Storage_Pool’ attribute to the type is flagged
with a warning and its evaluation raises the exception ‘Program_Error’.

If the Simple_Storage_Pool attribute has been specified for an access
type ‘S’, then the evaluation of the attribute ‘S'Storage_Size’ returns
the result of calling ‘Storage_Size (S'Simple_Storage_Pool)’, which is
intended to indicate the number of storage elements reserved for the
simple storage pool.  If the Storage_Size function has not been defined
for the simple storage pool type, then this attribute returns zero.

If an access type ‘S’ has a specified simple storage pool of type ‘SSP’,
then the evaluation of an allocator for that access type calls the
primitive ‘Allocate’ procedure for type ‘SSP’, passing
‘S'Simple_Storage_Pool’ as the pool parameter.  The detailed semantics
of such allocators is the same as those defined for allocators in
section 13.11 of the ‘Ada Reference Manual’, with the term `simple
storage pool' substituted for `storage pool'.

If an access type ‘S’ has a specified simple storage pool of type ‘SSP’,
then a call to an instance of the ‘Ada.Unchecked_Deallocation’ for that
access type invokes the primitive ‘Deallocate’ procedure for type ‘SSP’,
passing ‘S'Simple_Storage_Pool’ as the pool parameter.  The detailed
semantics of such unchecked deallocations is the same as defined in
section 13.11.2 of the Ada Reference Manual, except that the term
`simple storage pool' is substituted for `storage pool'.


File: gnat_rm.info,  Node: Attribute Small,  Next: Attribute Small_Denominator,  Prev: Attribute Simple_Storage_Pool,  Up: Implementation Defined Attributes

4.58 Attribute Small
====================

The ‘Small’ attribute is defined in Ada 95 (and Ada 2005) only for
fixed-point types.  GNAT also allows this attribute to be applied to
floating-point types for compatibility with Ada 83.  See the Ada 83
reference manual for an exact description of the semantics of this
attribute when applied to floating-point types.


File: gnat_rm.info,  Node: Attribute Small_Denominator,  Next: Attribute Small_Numerator,  Prev: Attribute Small,  Up: Implementation Defined Attributes

4.59 Attribute Small_Denominator
================================

‘typ'Small_Denominator’ for any fixed-point subtype ‘typ’ yields the
denominator in the representation of ‘typ'Small’ as a rational number
with coprime factors (i.e.  as an irreducible fraction).


File: gnat_rm.info,  Node: Attribute Small_Numerator,  Next: Attribute Storage_Unit,  Prev: Attribute Small_Denominator,  Up: Implementation Defined Attributes

4.60 Attribute Small_Numerator
==============================

‘typ'Small_Numerator’ for any fixed-point subtype ‘typ’ yields the
numerator in the representation of ‘typ'Small’ as a rational number with
coprime factors (i.e.  as an irreducible fraction).


File: gnat_rm.info,  Node: Attribute Storage_Unit,  Next: Attribute Stub_Type,  Prev: Attribute Small_Numerator,  Up: Implementation Defined Attributes

4.61 Attribute Storage_Unit
===========================

‘Standard'Storage_Unit’ (‘Standard’ is the only allowed prefix) provides
the same value as ‘System.Storage_Unit’.


File: gnat_rm.info,  Node: Attribute Stub_Type,  Next: Attribute System_Allocator_Alignment,  Prev: Attribute Storage_Unit,  Up: Implementation Defined Attributes

4.62 Attribute Stub_Type
========================

The GNAT implementation of remote access-to-classwide types is organized
as described in AARM section E.4 (20.t): a value of an RACW type
(designating a remote object) is represented as a normal access value,
pointing to a “stub” object which in turn contains the necessary
information to contact the designated remote object.  A call on any
dispatching operation of such a stub object does the remote call, if
necessary, using the information in the stub object to locate the target
partition, etc.

For a prefix ‘T’ that denotes a remote access-to-classwide type,
‘T'Stub_Type’ denotes the type of the corresponding stub objects.

By construction, the layout of ‘T'Stub_Type’ is identical to that of
type ‘RACW_Stub_Type’ declared in the internal implementation-defined
unit ‘System.Partition_Interface’.  Use of this attribute will create an
implicit dependency on this unit.


File: gnat_rm.info,  Node: Attribute System_Allocator_Alignment,  Next: Attribute Target_Name,  Prev: Attribute Stub_Type,  Up: Implementation Defined Attributes

4.63 Attribute System_Allocator_Alignment
=========================================

‘Standard'System_Allocator_Alignment’ (‘Standard’ is the only allowed
prefix) provides the observable guaranted to be honored by the system
allocator (malloc).  This is a static value that can be used in user
storage pools based on malloc either to reject allocation with alignment
too large or to enable a realignment circuitry if the alignment request
is larger than this value.


File: gnat_rm.info,  Node: Attribute Target_Name,  Next: Attribute To_Address,  Prev: Attribute System_Allocator_Alignment,  Up: Implementation Defined Attributes

4.64 Attribute Target_Name
==========================

‘Standard'Target_Name’ (‘Standard’ is the only allowed prefix) provides
a static string value that identifies the target for the current
compilation.  For GCC implementations, this is the standard gcc target
name without the terminating slash (for example, GNAT 5.0 on windows
yields “i586-pc-mingw32msv”).


File: gnat_rm.info,  Node: Attribute To_Address,  Next: Attribute To_Any,  Prev: Attribute Target_Name,  Up: Implementation Defined Attributes

4.65 Attribute To_Address
=========================

The ‘System'To_Address’ (‘System’ is the only allowed prefix) denotes a
function identical to ‘System.Storage_Elements.To_Address’ except that
it is a static attribute.  This means that if its argument is a static
expression, then the result of the attribute is a static expression.
This means that such an expression can be used in contexts (e.g.,
preelaborable packages) which require a static expression and where the
function call could not be used (since the function call is always
nonstatic, even if its argument is static).  The argument must be in the
range -(2**(m-1)) ..  2**m-1, where m is the memory size (typically 32
or 64).  Negative values are intepreted in a modular manner (e.g., -1
means the same as 16#FFFF_FFFF# on a 32 bits machine).


File: gnat_rm.info,  Node: Attribute To_Any,  Next: Attribute Type_Class,  Prev: Attribute To_Address,  Up: Implementation Defined Attributes

4.66 Attribute To_Any
=====================

This internal attribute is used for the generation of remote subprogram
stubs in the context of the Distributed Systems Annex.


File: gnat_rm.info,  Node: Attribute Type_Class,  Next: Attribute Type_Key,  Prev: Attribute To_Any,  Up: Implementation Defined Attributes

4.67 Attribute Type_Class
=========================

‘typ'Type_Class’ for any type or subtype ‘typ’ yields the value of the
type class for the full type of ‘typ’.  If ‘typ’ is a generic formal
type, the value is the value for the corresponding actual subtype.  The
value of this attribute is of type ‘System.Aux_DEC.Type_Class’, which
has the following definition:

     type Type_Class is
       (Type_Class_Enumeration,
        Type_Class_Integer,
        Type_Class_Fixed_Point,
        Type_Class_Floating_Point,
        Type_Class_Array,
        Type_Class_Record,
        Type_Class_Access,
        Type_Class_Task,
        Type_Class_Address);

Protected types yield the value ‘Type_Class_Task’, which thus applies to
all concurrent types.  This attribute is designed to be compatible with
the DEC Ada 83 attribute of the same name.


File: gnat_rm.info,  Node: Attribute Type_Key,  Next: Attribute TypeCode,  Prev: Attribute Type_Class,  Up: Implementation Defined Attributes

4.68 Attribute Type_Key
=======================

The ‘Type_Key’ attribute is applicable to a type or subtype and yields a
value of type Standard.String containing encoded information about the
type or subtype.  This provides improved compatibility with other
implementations that support this attribute.


File: gnat_rm.info,  Node: Attribute TypeCode,  Next: Attribute Unconstrained_Array,  Prev: Attribute Type_Key,  Up: Implementation Defined Attributes

4.69 Attribute TypeCode
=======================

This internal attribute is used for the generation of remote subprogram
stubs in the context of the Distributed Systems Annex.


File: gnat_rm.info,  Node: Attribute Unconstrained_Array,  Next: Attribute Universal_Literal_String,  Prev: Attribute TypeCode,  Up: Implementation Defined Attributes

4.70 Attribute Unconstrained_Array
==================================

The ‘Unconstrained_Array’ attribute can be used with a prefix that
denotes any type or subtype.  It is a static attribute that yields
‘True’ if the prefix designates an unconstrained array, and ‘False’
otherwise.  In a generic instance, the result is still static, and
yields the result of applying this test to the generic actual.


File: gnat_rm.info,  Node: Attribute Universal_Literal_String,  Next: Attribute Unrestricted_Access,  Prev: Attribute Unconstrained_Array,  Up: Implementation Defined Attributes

4.71 Attribute Universal_Literal_String
=======================================

The prefix of ‘Universal_Literal_String’ must be a named number.  The
static result is the string consisting of the characters of the number
as defined in the original source.  This allows the user program to
access the actual text of named numbers without intermediate conversions
and without the need to enclose the strings in quotes (which would
preclude their use as numbers).

For example, the following program prints the first 50 digits of pi:

     with Text_IO; use Text_IO;
     with Ada.Numerics;
     procedure Pi is
     begin
        Put (Ada.Numerics.Pi'Universal_Literal_String);
     end;


File: gnat_rm.info,  Node: Attribute Unrestricted_Access,  Next: Attribute Update,  Prev: Attribute Universal_Literal_String,  Up: Implementation Defined Attributes

4.72 Attribute Unrestricted_Access
==================================

The ‘Unrestricted_Access’ attribute is similar to ‘Access’ except that
all accessibility and aliased view checks are omitted.  This is a
user-beware attribute.

For objects, it is similar to ‘Address’, for which it is a desirable
replacement where the value desired is an access type.  In other words,
its effect is similar to first applying the ‘Address’ attribute and then
doing an unchecked conversion to a desired access type.

For subprograms, ‘P'Unrestricted_Access’ may be used where ‘P'Access’
would be illegal, to construct a value of a less-nested named access
type that designates a more-nested subprogram.  This value may be used
in indirect calls, so long as the more-nested subprogram still exists;
once the subprogram containing it has returned, such calls are
erroneous.  For example:

     package body P is

        type Less_Nested is not null access procedure;
        Global : Less_Nested;

        procedure P1 is
        begin
           Global.all;
        end P1;

        procedure P2 is
           Local_Var : Integer;

           procedure More_Nested is
           begin
              ... Local_Var ...
           end More_Nested;
        begin
           Global := More_Nested'Unrestricted_Access;
           P1;
        end P2;

     end P;

When P1 is called from P2, the call via Global is OK, but if P1 were
called after P2 returns, it would be an erroneous use of a dangling
pointer.

For objects, it is possible to use ‘Unrestricted_Access’ for any type.
However, if the result is of an access-to-unconstrained array subtype,
then the resulting pointer has the same scope as the context of the
attribute, and must not be returned to some enclosing scope.  For
instance, if a function uses ‘Unrestricted_Access’ to create an
access-to-unconstrained-array and returns that value to the caller, the
result will involve dangling pointers.  In addition, it is only valid to
create pointers to unconstrained arrays using this attribute if the
pointer has the normal default ‘fat’ representation where a pointer has
two components, one points to the array and one points to the bounds.
If a size clause is used to force ‘thin’ representation for a pointer to
unconstrained where there is only space for a single pointer, then the
resulting pointer is not usable.

In the simple case where a direct use of Unrestricted_Access attempts to
make a thin pointer for a non-aliased object, the compiler will reject
the use as illegal, as shown in the following example:

     with System; use System;
     procedure SliceUA2 is
        type A is access all String;
        for A'Size use Standard'Address_Size;

        procedure P (Arg : A) is
        begin
           null;
        end P;

        X : String := "hello world!";
        X2 : aliased String := "hello world!";

        AV : A := X'Unrestricted_Access;    -- ERROR
                  |
     >>> illegal use of Unrestricted_Access attribute
     >>> attempt to generate thin pointer to unaliased object

     begin
        P (X'Unrestricted_Access);          -- ERROR
           |
     >>> illegal use of Unrestricted_Access attribute
     >>> attempt to generate thin pointer to unaliased object

        P (X(7 .. 12)'Unrestricted_Access); -- ERROR
           |
     >>> illegal use of Unrestricted_Access attribute
     >>> attempt to generate thin pointer to unaliased object

        P (X2'Unrestricted_Access);         -- OK
     end;

but other cases cannot be detected by the compiler, and are considered
to be erroneous.  Consider the following example:

     with System; use System;
     with System; use System;
     procedure SliceUA is
        type AF is access all String;

        type A is access all String;
        for A'Size use Standard'Address_Size;

        procedure P (Arg : A) is
        begin
           if Arg'Length /= 6 then
              raise Program_Error;
           end if;
        end P;

        X : String := "hello world!";
        Y : AF := X (7 .. 12)'Unrestricted_Access;

     begin
        P (A (Y));
     end;

A normal unconstrained array value or a constrained array object marked
as aliased has the bounds in memory just before the array, so a thin
pointer can retrieve both the data and the bounds.  But in this case,
the non-aliased object ‘X’ does not have the bounds before the string.
If the size clause for type ‘A’ were not present, then the pointer would
be a fat pointer, where one component is a pointer to the bounds, and
all would be well.  But with the size clause present, the conversion
from fat pointer to thin pointer in the call loses the bounds, and so
this is erroneous, and the program likely raises a ‘Program_Error’
exception.

In general, it is advisable to completely avoid mixing the use of thin
pointers and the use of ‘Unrestricted_Access’ where the designated type
is an unconstrained array.  The use of thin pointers should be
restricted to cases of porting legacy code that implicitly assumes the
size of pointers, and such code should not in any case be using this
attribute.

Another erroneous situation arises if the attribute is applied to a
constant.  The resulting pointer can be used to access the constant, but
the effect of trying to modify a constant in this manner is not
well-defined.  Consider this example:

     P : constant Integer := 4;
     type R is access all Integer;
     RV : R := P'Unrestricted_Access;
     ..
     RV.all := 3;

Here we attempt to modify the constant P from 4 to 3, but the compiler
may or may not notice this attempt, and subsequent references to P may
yield either the value 3 or the value 4 or the assignment may blow up if
the compiler decides to put P in read-only memory.  One particular case
where ‘Unrestricted_Access’ can be used in this way is to modify the
value of an ‘in’ parameter:

     procedure K (S : in String) is
        type R is access all Character;
        RV : R := S (3)'Unrestricted_Access;
     begin
        RV.all := 'a';
     end;

In general this is a risky approach.  It may appear to “work” but such
uses of ‘Unrestricted_Access’ are potentially non-portable, even from
one version of GNAT to another, so are best avoided if possible.


File: gnat_rm.info,  Node: Attribute Update,  Next: Attribute Valid_Image,  Prev: Attribute Unrestricted_Access,  Up: Implementation Defined Attributes

4.73 Attribute Update
=====================

The ‘Update’ attribute creates a copy of an array or record value with
one or more modified components.  The syntax is:

     PREFIX'Update ( RECORD_COMPONENT_ASSOCIATION_LIST )
     PREFIX'Update ( ARRAY_COMPONENT_ASSOCIATION {, ARRAY_COMPONENT_ASSOCIATION } )
     PREFIX'Update ( MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION
                     {, MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION } )

     MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION ::= INDEX_EXPRESSION_LIST_LIST => EXPRESSION
     INDEX_EXPRESSION_LIST_LIST                   ::= INDEX_EXPRESSION_LIST {| INDEX_EXPRESSION_LIST }
     INDEX_EXPRESSION_LIST                        ::= ( EXPRESSION {, EXPRESSION } )

where ‘PREFIX’ is the name of an array or record object, the association
list in parentheses does not contain an ‘others’ choice and the box
symbol ‘<>’ may not appear in any expression.  The effect is to yield a
copy of the array or record value which is unchanged apart from the
components mentioned in the association list, which are changed to the
indicated value.  The original value of the array or record value is not
affected.  For example:

     type Arr is Array (1 .. 5) of Integer;
     ...
     Avar1 : Arr := (1,2,3,4,5);
     Avar2 : Arr := Avar1'Update (2 => 10, 3 .. 4 => 20);

yields a value for ‘Avar2’ of 1,10,20,20,5 with ‘Avar1’ begin
unmodified.  Similarly:

     type Rec is A, B, C : Integer;
     ...
     Rvar1 : Rec := (A => 1, B => 2, C => 3);
     Rvar2 : Rec := Rvar1'Update (B => 20);

yields a value for ‘Rvar2’ of (A => 1, B => 20, C => 3), with ‘Rvar1’
being unmodifed.  Note that the value of the attribute reference is
computed completely before it is used.  This means that if you write:

     Avar1 := Avar1'Update (1 => 10, 2 => Function_Call);

then the value of ‘Avar1’ is not modified if ‘Function_Call’ raises an
exception, unlike the effect of a series of direct assignments to
elements of ‘Avar1’.  In general this requires that two extra complete
copies of the object are required, which should be kept in mind when
considering efficiency.

The ‘Update’ attribute cannot be applied to prefixes of a limited type,
and cannot reference discriminants in the case of a record type.  The
accessibility level of an Update attribute result object is defined as
for an aggregate.

In the record case, no component can be mentioned more than once.  In
the array case, two overlapping ranges can appear in the association
list, in which case the modifications are processed left to right.

Multi-dimensional arrays can be modified, as shown by this example:

     A : array (1 .. 10, 1 .. 10) of Integer;
     ..
     A := A'Update ((1, 2) => 20, (3, 4) => 30);

which changes element (1,2) to 20 and (3,4) to 30.


File: gnat_rm.info,  Node: Attribute Valid_Image,  Next: Attribute Valid_Scalars,  Prev: Attribute Update,  Up: Implementation Defined Attributes

4.74 Attribute Valid_Image
==========================

The ‘'Valid_Image’ attribute is defined for enumeration types other than
those in package Standard.  This attribute is a function that takes a
String, and returns Boolean.  ‘T'Valid_Image (S)’ returns True if and
only if ‘T'Value (S)’ would not raise Constraint_Error.


File: gnat_rm.info,  Node: Attribute Valid_Scalars,  Next: Attribute VADS_Size,  Prev: Attribute Valid_Image,  Up: Implementation Defined Attributes

4.75 Attribute Valid_Scalars
============================

The ‘'Valid_Scalars’ attribute is intended to make it easier to check
the validity of scalar subcomponents of composite objects.  The
attribute is defined for any prefix ‘P’ which denotes an object.  Prefix
‘P’ can be any type except for tagged private or ‘Unchecked_Union’
types.  The value of the attribute is of type ‘Boolean’.

‘P'Valid_Scalars’ yields ‘True’ if and only if the evaluation of
‘C'Valid’ yields ‘True’ for every scalar subcomponent ‘C’ of ‘P’, or if
‘P’ has no scalar subcomponents.  Attribute ‘'Valid_Scalars’ is
equivalent to attribute ‘'Valid’ for scalar types.

It is not specified in what order the subcomponents are checked, nor
whether any more are checked after any one of them is determined to be
invalid.  If the prefix ‘P’ is of a class-wide type ‘T'Class’ (where ‘T’
is the associated specific type), or if the prefix ‘P’ is of a specific
tagged type ‘T’, then only the subcomponents of ‘T’ are checked; in
other words, components of extensions of ‘T’ are not checked even if
‘T'Class (P)'Tag /= T'Tag’.

The compiler will issue a warning if it can be determined at compile
time that the prefix of the attribute has no scalar subcomponents.

Note: ‘Valid_Scalars’ can generate a lot of code, especially in the case
of a large variant record.  If the attribute is called in many places in
the same program applied to objects of the same type, it can reduce
program size to write a function with a single use of the attribute, and
then call that function from multiple places.


File: gnat_rm.info,  Node: Attribute VADS_Size,  Next: Attribute Value_Size,  Prev: Attribute Valid_Scalars,  Up: Implementation Defined Attributes

4.76 Attribute VADS_Size
========================

The ‘'VADS_Size’ attribute is intended to make it easier to port legacy
code which relies on the semantics of ‘'Size’ as implemented by the VADS
Ada 83 compiler.  GNAT makes a best effort at duplicating the same
semantic interpretation.  In particular, ‘'VADS_Size’ applied to a
predefined or other primitive type with no Size clause yields the
Object_Size (for example, ‘Natural'Size’ is 32 rather than 31 on typical
machines).  In addition ‘'VADS_Size’ applied to an object gives the
result that would be obtained by applying the attribute to the
corresponding type.


File: gnat_rm.info,  Node: Attribute Value_Size,  Next: Attribute Wchar_T_Size,  Prev: Attribute VADS_Size,  Up: Implementation Defined Attributes

4.77 Attribute Value_Size
=========================

‘type'Value_Size’ is the number of bits required to represent a value of
the given subtype.  It is the same as ‘type'Size’, but, unlike ‘Size’,
may be set for non-first subtypes.


File: gnat_rm.info,  Node: Attribute Wchar_T_Size,  Next: Attribute Word_Size,  Prev: Attribute Value_Size,  Up: Implementation Defined Attributes

4.78 Attribute Wchar_T_Size
===========================

‘Standard'Wchar_T_Size’ (‘Standard’ is the only allowed prefix) provides
the size in bits of the C ‘wchar_t’ type primarily for constructing the
definition of this type in package ‘Interfaces.C’.  The result is a
static constant.


File: gnat_rm.info,  Node: Attribute Word_Size,  Prev: Attribute Wchar_T_Size,  Up: Implementation Defined Attributes

4.79 Attribute Word_Size
========================

‘Standard'Word_Size’ (‘Standard’ is the only allowed prefix) provides
the value ‘System.Word_Size’.  The result is a static constant.


File: gnat_rm.info,  Node: Standard and Implementation Defined Restrictions,  Next: Implementation Advice,  Prev: Implementation Defined Attributes,  Up: Top

5 Standard and Implementation Defined Restrictions
**************************************************

All Ada Reference Manual-defined Restriction identifiers are
implemented:

   * language-defined restrictions (see 13.12.1)

   * tasking restrictions (see D.7)

   * high integrity restrictions (see H.4)

GNAT implements additional restriction identifiers.  All restrictions,
whether language defined or GNAT-specific, are listed in the following.

* Menu:

* Partition-Wide Restrictions::
* Program Unit Level Restrictions::


File: gnat_rm.info,  Node: Partition-Wide Restrictions,  Next: Program Unit Level Restrictions,  Up: Standard and Implementation Defined Restrictions

5.1 Partition-Wide Restrictions
===============================

There are two separate lists of restriction identifiers.  The first set
requires consistency throughout a partition (in other words, if the
restriction identifier is used for any compilation unit in the
partition, then all compilation units in the partition must obey the
restriction).

* Menu:

* Immediate_Reclamation::
* Max_Asynchronous_Select_Nesting::
* Max_Entry_Queue_Length::
* Max_Protected_Entries::
* Max_Select_Alternatives::
* Max_Storage_At_Blocking::
* Max_Task_Entries::
* Max_Tasks::
* No_Abort_Statements::
* No_Access_Parameter_Allocators::
* No_Access_Subprograms::
* No_Allocators::
* No_Anonymous_Allocators::
* No_Asynchronous_Control::
* No_Calendar::
* No_Coextensions::
* No_Default_Initialization::
* No_Delay::
* No_Dependence::
* No_Direct_Boolean_Operators::
* No_Dispatch::
* No_Dispatching_Calls::
* No_Dynamic_Attachment::
* No_Dynamic_Priorities::
* No_Entry_Calls_In_Elaboration_Code::
* No_Enumeration_Maps::
* No_Exception_Handlers::
* No_Exception_Propagation::
* No_Exception_Registration::
* No_Exceptions::
* No_Finalization::
* No_Fixed_Point::
* No_Floating_Point::
* No_Implicit_Conditionals::
* No_Implicit_Dynamic_Code::
* No_Implicit_Heap_Allocations::
* No_Implicit_Protected_Object_Allocations::
* No_Implicit_Task_Allocations::
* No_Initialize_Scalars::
* No_IO::
* No_Local_Allocators::
* No_Local_Protected_Objects::
* No_Local_Timing_Events::
* No_Long_Long_Integers::
* No_Multiple_Elaboration::
* No_Nested_Finalization::
* No_Protected_Type_Allocators::
* No_Protected_Types::
* No_Recursion::
* No_Reentrancy::
* No_Relative_Delay::
* No_Requeue_Statements::
* No_Secondary_Stack::
* No_Select_Statements::
* No_Specific_Termination_Handlers::
* No_Specification_of_Aspect::
* No_Standard_Allocators_After_Elaboration::
* No_Standard_Storage_Pools::
* No_Stream_Optimizations::
* No_Streams::
* No_Tagged_Type_Registration::
* No_Task_Allocators::
* No_Task_At_Interrupt_Priority::
* No_Task_Attributes_Package::
* No_Task_Hierarchy::
* No_Task_Termination::
* No_Tasking::
* No_Terminate_Alternatives::
* No_Unchecked_Access::
* No_Unchecked_Conversion::
* No_Unchecked_Deallocation::
* No_Use_Of_Entity::
* Pure_Barriers::
* Simple_Barriers::
* Static_Priorities::
* Static_Storage_Size::


File: gnat_rm.info,  Node: Immediate_Reclamation,  Next: Max_Asynchronous_Select_Nesting,  Up: Partition-Wide Restrictions

5.1.1 Immediate_Reclamation
---------------------------

[RM H.4] This restriction ensures that, except for storage occupied by
objects created by allocators and not deallocated via unchecked
deallocation, any storage reserved at run time for an object is
immediately reclaimed when the object no longer exists.


File: gnat_rm.info,  Node: Max_Asynchronous_Select_Nesting,  Next: Max_Entry_Queue_Length,  Prev: Immediate_Reclamation,  Up: Partition-Wide Restrictions

5.1.2 Max_Asynchronous_Select_Nesting
-------------------------------------

[RM D.7] Specifies the maximum dynamic nesting level of asynchronous
selects.  Violations of this restriction with a value of zero are
detected at compile time.  Violations of this restriction with values
other than zero cause Storage_Error to be raised.


File: gnat_rm.info,  Node: Max_Entry_Queue_Length,  Next: Max_Protected_Entries,  Prev: Max_Asynchronous_Select_Nesting,  Up: Partition-Wide Restrictions

5.1.3 Max_Entry_Queue_Length
----------------------------

[RM D.7] This restriction is a declaration that any protected entry
compiled in the scope of the restriction has at most the specified
number of tasks waiting on the entry at any one time, and so no queue is
required.  Note that this restriction is checked at run time.  Violation
of this restriction results in the raising of Program_Error exception at
the point of the call.

The restriction ‘Max_Entry_Queue_Depth’ is recognized as a synonym for
‘Max_Entry_Queue_Length’.  This is retained for historical compatibility
purposes (and a warning will be generated for its use if warnings on
obsolescent features are activated).


File: gnat_rm.info,  Node: Max_Protected_Entries,  Next: Max_Select_Alternatives,  Prev: Max_Entry_Queue_Length,  Up: Partition-Wide Restrictions

5.1.4 Max_Protected_Entries
---------------------------

[RM D.7] Specifies the maximum number of entries per protected type.
The bounds of every entry family of a protected unit shall be static, or
shall be defined by a discriminant of a subtype whose corresponding
bound is static.


File: gnat_rm.info,  Node: Max_Select_Alternatives,  Next: Max_Storage_At_Blocking,  Prev: Max_Protected_Entries,  Up: Partition-Wide Restrictions

5.1.5 Max_Select_Alternatives
-----------------------------

[RM D.7] Specifies the maximum number of alternatives in a selective
accept.


File: gnat_rm.info,  Node: Max_Storage_At_Blocking,  Next: Max_Task_Entries,  Prev: Max_Select_Alternatives,  Up: Partition-Wide Restrictions

5.1.6 Max_Storage_At_Blocking
-----------------------------

[RM D.7] Specifies the maximum portion (in storage elements) of a task’s
Storage_Size that can be retained by a blocked task.  A violation of
this restriction causes Storage_Error to be raised.


File: gnat_rm.info,  Node: Max_Task_Entries,  Next: Max_Tasks,  Prev: Max_Storage_At_Blocking,  Up: Partition-Wide Restrictions

5.1.7 Max_Task_Entries
----------------------

[RM D.7] Specifies the maximum number of entries per task.  The bounds
of every entry family of a task unit shall be static, or shall be
defined by a discriminant of a subtype whose corresponding bound is
static.


File: gnat_rm.info,  Node: Max_Tasks,  Next: No_Abort_Statements,  Prev: Max_Task_Entries,  Up: Partition-Wide Restrictions

5.1.8 Max_Tasks
---------------

[RM D.7] Specifies the maximum number of task that may be created, not
counting the creation of the environment task.  Violations of this
restriction with a value of zero are detected at compile time.
Violations of this restriction with values other than zero cause
Storage_Error to be raised.


File: gnat_rm.info,  Node: No_Abort_Statements,  Next: No_Access_Parameter_Allocators,  Prev: Max_Tasks,  Up: Partition-Wide Restrictions

5.1.9 No_Abort_Statements
-------------------------

[RM D.7] There are no abort_statements, and there are no calls to
Task_Identification.Abort_Task.


File: gnat_rm.info,  Node: No_Access_Parameter_Allocators,  Next: No_Access_Subprograms,  Prev: No_Abort_Statements,  Up: Partition-Wide Restrictions

5.1.10 No_Access_Parameter_Allocators
-------------------------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of an allocator as the actual parameter to an access
parameter.


File: gnat_rm.info,  Node: No_Access_Subprograms,  Next: No_Allocators,  Prev: No_Access_Parameter_Allocators,  Up: Partition-Wide Restrictions

5.1.11 No_Access_Subprograms
----------------------------

[RM H.4] This restriction ensures at compile time that there are no
declarations of access-to-subprogram types.


File: gnat_rm.info,  Node: No_Allocators,  Next: No_Anonymous_Allocators,  Prev: No_Access_Subprograms,  Up: Partition-Wide Restrictions

5.1.12 No_Allocators
--------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of an allocator.


File: gnat_rm.info,  Node: No_Anonymous_Allocators,  Next: No_Asynchronous_Control,  Prev: No_Allocators,  Up: Partition-Wide Restrictions

5.1.13 No_Anonymous_Allocators
------------------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of an allocator of anonymous access type.


File: gnat_rm.info,  Node: No_Asynchronous_Control,  Next: No_Calendar,  Prev: No_Anonymous_Allocators,  Up: Partition-Wide Restrictions

5.1.14 No_Asynchronous_Control
------------------------------

[RM J.13] This restriction ensures at compile time that there are no
semantic dependences on the predefined package
Asynchronous_Task_Control.


File: gnat_rm.info,  Node: No_Calendar,  Next: No_Coextensions,  Prev: No_Asynchronous_Control,  Up: Partition-Wide Restrictions

5.1.15 No_Calendar
------------------

[GNAT] This restriction ensures at compile time that there are no
semantic dependences on package Calendar.


File: gnat_rm.info,  Node: No_Coextensions,  Next: No_Default_Initialization,  Prev: No_Calendar,  Up: Partition-Wide Restrictions

5.1.16 No_Coextensions
----------------------

[RM H.4] This restriction ensures at compile time that there are no
coextensions.  See 3.10.2.


File: gnat_rm.info,  Node: No_Default_Initialization,  Next: No_Delay,  Prev: No_Coextensions,  Up: Partition-Wide Restrictions

5.1.17 No_Default_Initialization
--------------------------------

[GNAT] This restriction prohibits any instance of default initialization
of variables.  The binder implements a consistency rule which prevents
any unit compiled without the restriction from with’ing a unit with the
restriction (this allows the generation of initialization procedures to
be skipped, since you can be sure that no call is ever generated to an
initialization procedure in a unit with the restriction active).  If
used in conjunction with Initialize_Scalars or Normalize_Scalars, the
effect is to prohibit all cases of variables declared without a specific
initializer (including the case of OUT scalar parameters).


File: gnat_rm.info,  Node: No_Delay,  Next: No_Dependence,  Prev: No_Default_Initialization,  Up: Partition-Wide Restrictions

5.1.18 No_Delay
---------------

[RM H.4] This restriction ensures at compile time that there are no
delay statements and no semantic dependences on package Calendar.


File: gnat_rm.info,  Node: No_Dependence,  Next: No_Direct_Boolean_Operators,  Prev: No_Delay,  Up: Partition-Wide Restrictions

5.1.19 No_Dependence
--------------------

[RM 13.12.1] This restriction ensures at compile time that there are no
dependences on a library unit.


File: gnat_rm.info,  Node: No_Direct_Boolean_Operators,  Next: No_Dispatch,  Prev: No_Dependence,  Up: Partition-Wide Restrictions

5.1.20 No_Direct_Boolean_Operators
----------------------------------

[GNAT] This restriction ensures that no logical operators (and/or/xor)
are used on operands of type Boolean (or any type derived from Boolean).
This is intended for use in safety critical programs where the
certification protocol requires the use of short-circuit (and then, or
else) forms for all composite boolean operations.


File: gnat_rm.info,  Node: No_Dispatch,  Next: No_Dispatching_Calls,  Prev: No_Direct_Boolean_Operators,  Up: Partition-Wide Restrictions

5.1.21 No_Dispatch
------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of ‘T'Class’, for any (tagged) subtype ‘T’.


File: gnat_rm.info,  Node: No_Dispatching_Calls,  Next: No_Dynamic_Attachment,  Prev: No_Dispatch,  Up: Partition-Wide Restrictions

5.1.22 No_Dispatching_Calls
---------------------------

[GNAT] This restriction ensures at compile time that the code generated
by the compiler involves no dispatching calls.  The use of this
restriction allows the safe use of record extensions, classwide
membership tests and other classwide features not involving implicit
dispatching.  This restriction ensures that the code contains no
indirect calls through a dispatching mechanism.  Note that this includes
internally-generated calls created by the compiler, for example in the
implementation of class-wide objects assignments.  The membership test
is allowed in the presence of this restriction, because its
implementation requires no dispatching.  This restriction is comparable
to the official Ada restriction ‘No_Dispatch’ except that it is a bit
less restrictive in that it allows all classwide constructs that do not
imply dispatching.  The following example indicates constructs that
violate this restriction.

     package Pkg is
       type T is tagged record
         Data : Natural;
       end record;
       procedure P (X : T);

       type DT is new T with record
         More_Data : Natural;
       end record;
       procedure Q (X : DT);
     end Pkg;

     with Pkg; use Pkg;
     procedure Example is
       procedure Test (O : T'Class) is
         N : Natural := O'Size; --  Error: Dispatching call
         C : T'Class := O;      --  Error: implicit Dispatching Call
       begin
         if O in DT'Class then  --  OK   : Membership test
            Q (DT (O));         --  OK   : Type conversion plus direct call
         else
            P (O);              --  Error: Dispatching call
         end if;
       end Test;

       Obj : DT;
     begin
       P (Obj);                 --  OK   : Direct call
       P (T (Obj));             --  OK   : Type conversion plus direct call
       P (T'Class (Obj));       --  Error: Dispatching call

       Test (Obj);              --  OK   : Type conversion

       if Obj in T'Class then   --  OK   : Membership test
          null;
       end if;
     end Example;


File: gnat_rm.info,  Node: No_Dynamic_Attachment,  Next: No_Dynamic_Priorities,  Prev: No_Dispatching_Calls,  Up: Partition-Wide Restrictions

5.1.23 No_Dynamic_Attachment
----------------------------

[RM D.7] This restriction ensures that there is no call to any of the
operations defined in package Ada.Interrupts (Is_Reserved, Is_Attached,
Current_Handler, Attach_Handler, Exchange_Handler, Detach_Handler, and
Reference).

The restriction ‘No_Dynamic_Interrupts’ is recognized as a synonym for
‘No_Dynamic_Attachment’.  This is retained for historical compatibility
purposes (and a warning will be generated for its use if warnings on
obsolescent features are activated).


File: gnat_rm.info,  Node: No_Dynamic_Priorities,  Next: No_Entry_Calls_In_Elaboration_Code,  Prev: No_Dynamic_Attachment,  Up: Partition-Wide Restrictions

5.1.24 No_Dynamic_Priorities
----------------------------

[RM D.7] There are no semantic dependencies on the package
Dynamic_Priorities.


File: gnat_rm.info,  Node: No_Entry_Calls_In_Elaboration_Code,  Next: No_Enumeration_Maps,  Prev: No_Dynamic_Priorities,  Up: Partition-Wide Restrictions

5.1.25 No_Entry_Calls_In_Elaboration_Code
-----------------------------------------

[GNAT] This restriction ensures at compile time that no task or
protected entry calls are made during elaboration code.  As a result of
the use of this restriction, the compiler can assume that no code past
an accept statement in a task can be executed at elaboration time.


File: gnat_rm.info,  Node: No_Enumeration_Maps,  Next: No_Exception_Handlers,  Prev: No_Entry_Calls_In_Elaboration_Code,  Up: Partition-Wide Restrictions

5.1.26 No_Enumeration_Maps
--------------------------

[GNAT] This restriction ensures at compile time that no operations
requiring enumeration maps are used (that is Image and Value attributes
applied to enumeration types).


File: gnat_rm.info,  Node: No_Exception_Handlers,  Next: No_Exception_Propagation,  Prev: No_Enumeration_Maps,  Up: Partition-Wide Restrictions

5.1.27 No_Exception_Handlers
----------------------------

[GNAT] This restriction ensures at compile time that there are no
explicit exception handlers.  It also indicates that no exception
propagation will be provided.  In this mode, exceptions may be raised
but will result in an immediate call to the last chance handler, a
routine that the user must define with the following profile:

     procedure Last_Chance_Handler
       (Source_Location : System.Address; Line : Integer);
     pragma Export (C, Last_Chance_Handler,
                    "__gnat_last_chance_handler");

The parameter is a C null-terminated string representing a message to be
associated with the exception (typically the source location of the
raise statement generated by the compiler).  The Line parameter when
nonzero represents the line number in the source program where the raise
occurs.


File: gnat_rm.info,  Node: No_Exception_Propagation,  Next: No_Exception_Registration,  Prev: No_Exception_Handlers,  Up: Partition-Wide Restrictions

5.1.28 No_Exception_Propagation
-------------------------------

[GNAT] This restriction guarantees that exceptions are never propagated
to an outer subprogram scope.  The only case in which an exception may
be raised is when the handler is statically in the same subprogram, so
that the effect of a raise is essentially like a goto statement.  Any
other raise statement (implicit or explicit) will be considered
unhandled.  Exception handlers are allowed, but may not contain an
exception occurrence identifier (exception choice).  In addition, use of
the package GNAT.Current_Exception is not permitted, and reraise
statements (raise with no operand) are not permitted.


File: gnat_rm.info,  Node: No_Exception_Registration,  Next: No_Exceptions,  Prev: No_Exception_Propagation,  Up: Partition-Wide Restrictions

5.1.29 No_Exception_Registration
--------------------------------

[GNAT] This restriction ensures at compile time that no stream
operations for types Exception_Id or Exception_Occurrence are used.
This also makes it impossible to pass exceptions to or from a partition
with this restriction in a distributed environment.  If this restriction
is active, the generated code is simplified by omitting the
otherwise-required global registration of exceptions when they are
declared.


File: gnat_rm.info,  Node: No_Exceptions,  Next: No_Finalization,  Prev: No_Exception_Registration,  Up: Partition-Wide Restrictions

5.1.30 No_Exceptions
--------------------

[RM H.4] This restriction ensures at compile time that there are no
raise statements and no exception handlers and also suppresses the
generation of language-defined run-time checks.


File: gnat_rm.info,  Node: No_Finalization,  Next: No_Fixed_Point,  Prev: No_Exceptions,  Up: Partition-Wide Restrictions

5.1.31 No_Finalization
----------------------

[GNAT] This restriction disables the language features described in
chapter 7.6 of the Ada 2005 RM as well as all form of code generation
performed by the compiler to support these features.  The following
types are no longer considered controlled when this restriction is in
effect:

   * ‘Ada.Finalization.Controlled’

   * ‘Ada.Finalization.Limited_Controlled’

   * Derivations from ‘Controlled’ or ‘Limited_Controlled’

   * Class-wide types

   * Protected types

   * Task types

   * Array and record types with controlled components

The compiler no longer generates code to initialize, finalize or adjust
an object or a nested component, either declared on the stack or on the
heap.  The deallocation of a controlled object no longer finalizes its
contents.


File: gnat_rm.info,  Node: No_Fixed_Point,  Next: No_Floating_Point,  Prev: No_Finalization,  Up: Partition-Wide Restrictions

5.1.32 No_Fixed_Point
---------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of fixed point types and operations.


File: gnat_rm.info,  Node: No_Floating_Point,  Next: No_Implicit_Conditionals,  Prev: No_Fixed_Point,  Up: Partition-Wide Restrictions

5.1.33 No_Floating_Point
------------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of floating point types and operations.


File: gnat_rm.info,  Node: No_Implicit_Conditionals,  Next: No_Implicit_Dynamic_Code,  Prev: No_Floating_Point,  Up: Partition-Wide Restrictions

5.1.34 No_Implicit_Conditionals
-------------------------------

[GNAT] This restriction ensures that the generated code does not contain
any implicit conditionals, either by modifying the generated code where
possible, or by rejecting any construct that would otherwise generate an
implicit conditional.  Note that this check does not include run time
constraint checks, which on some targets may generate implicit
conditionals as well.  To control the latter, constraint checks can be
suppressed in the normal manner.  Constructs generating implicit
conditionals include comparisons of composite objects and the Max/Min
attributes.


File: gnat_rm.info,  Node: No_Implicit_Dynamic_Code,  Next: No_Implicit_Heap_Allocations,  Prev: No_Implicit_Conditionals,  Up: Partition-Wide Restrictions

5.1.35 No_Implicit_Dynamic_Code
-------------------------------

[GNAT] This restriction prevents the compiler from building
‘trampolines’.  This is a structure that is built on the stack and
contains dynamic code to be executed at run time.  On some targets, a
trampoline is built for the following features: ‘Access’,
‘Unrestricted_Access’, or ‘Address’ of a nested subprogram; nested task
bodies; primitive operations of nested tagged types.  Trampolines do not
work on machines that prevent execution of stack data.  For example, on
windows systems, enabling DEP (data execution protection) will cause
trampolines to raise an exception.  Trampolines are also quite slow at
run time.

On many targets, trampolines have been largely eliminated.  Look at the
version of system.ads for your target — if it has Always_Compatible_Rep
equal to False, then trampolines are largely eliminated.  In particular,
a trampoline is built for the following features: ‘Address’ of a nested
subprogram; ‘Access’ or ‘Unrestricted_Access’ of a nested subprogram,
but only if pragma Favor_Top_Level applies, or the access type has a
foreign-language convention; primitive operations of nested tagged
types.


File: gnat_rm.info,  Node: No_Implicit_Heap_Allocations,  Next: No_Implicit_Protected_Object_Allocations,  Prev: No_Implicit_Dynamic_Code,  Up: Partition-Wide Restrictions

5.1.36 No_Implicit_Heap_Allocations
-----------------------------------

[RM D.7] No constructs are allowed to cause implicit heap allocation.


File: gnat_rm.info,  Node: No_Implicit_Protected_Object_Allocations,  Next: No_Implicit_Task_Allocations,  Prev: No_Implicit_Heap_Allocations,  Up: Partition-Wide Restrictions

5.1.37 No_Implicit_Protected_Object_Allocations
-----------------------------------------------

[GNAT] No constructs are allowed to cause implicit heap allocation of a
protected object.


File: gnat_rm.info,  Node: No_Implicit_Task_Allocations,  Next: No_Initialize_Scalars,  Prev: No_Implicit_Protected_Object_Allocations,  Up: Partition-Wide Restrictions

5.1.38 No_Implicit_Task_Allocations
-----------------------------------

[GNAT] No constructs are allowed to cause implicit heap allocation of a
task.


File: gnat_rm.info,  Node: No_Initialize_Scalars,  Next: No_IO,  Prev: No_Implicit_Task_Allocations,  Up: Partition-Wide Restrictions

5.1.39 No_Initialize_Scalars
----------------------------

[GNAT] This restriction ensures that no unit in the partition is
compiled with pragma Initialize_Scalars.  This allows the generation of
more efficient code, and in particular eliminates dummy null
initialization routines that are otherwise generated for some record and
array types.


File: gnat_rm.info,  Node: No_IO,  Next: No_Local_Allocators,  Prev: No_Initialize_Scalars,  Up: Partition-Wide Restrictions

5.1.40 No_IO
------------

[RM H.4] This restriction ensures at compile time that there are no
dependences on any of the library units Sequential_IO, Direct_IO,
Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, or Stream_IO.


File: gnat_rm.info,  Node: No_Local_Allocators,  Next: No_Local_Protected_Objects,  Prev: No_IO,  Up: Partition-Wide Restrictions

5.1.41 No_Local_Allocators
--------------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of an allocator in subprograms, generic subprograms, tasks,
and entry bodies.


File: gnat_rm.info,  Node: No_Local_Protected_Objects,  Next: No_Local_Timing_Events,  Prev: No_Local_Allocators,  Up: Partition-Wide Restrictions

5.1.42 No_Local_Protected_Objects
---------------------------------

[RM D.7] This restriction ensures at compile time that protected objects
are only declared at the library level.


File: gnat_rm.info,  Node: No_Local_Timing_Events,  Next: No_Long_Long_Integers,  Prev: No_Local_Protected_Objects,  Up: Partition-Wide Restrictions

5.1.43 No_Local_Timing_Events
-----------------------------

[RM D.7] All objects of type Ada.Real_Time.Timing_Events.Timing_Event
are declared at the library level.


File: gnat_rm.info,  Node: No_Long_Long_Integers,  Next: No_Multiple_Elaboration,  Prev: No_Local_Timing_Events,  Up: Partition-Wide Restrictions

5.1.44 No_Long_Long_Integers
----------------------------

[GNAT] This partition-wide restriction forbids any explicit reference to
type Standard.Long_Long_Integer, and also forbids declaring range types
whose implicit base type is Long_Long_Integer, and modular types whose
size exceeds Long_Integer’Size.


File: gnat_rm.info,  Node: No_Multiple_Elaboration,  Next: No_Nested_Finalization,  Prev: No_Long_Long_Integers,  Up: Partition-Wide Restrictions

5.1.45 No_Multiple_Elaboration
------------------------------

[GNAT] When this restriction is active and the static elaboration model
is used, and -fpreserve-control-flow is not used, the compiler is
allowed to suppress the elaboration counter normally associated with the
unit, even if the unit has elaboration code.  This counter is typically
used to check for access before elaboration and to control multiple
elaboration attempts.  If the restriction is used, then the situations
in which multiple elaboration is possible, including non-Ada main
programs and Stand Alone libraries, are not permitted and will be
diagnosed by the binder.


File: gnat_rm.info,  Node: No_Nested_Finalization,  Next: No_Protected_Type_Allocators,  Prev: No_Multiple_Elaboration,  Up: Partition-Wide Restrictions

5.1.46 No_Nested_Finalization
-----------------------------

[RM D.7] All objects requiring finalization are declared at the library
level.


File: gnat_rm.info,  Node: No_Protected_Type_Allocators,  Next: No_Protected_Types,  Prev: No_Nested_Finalization,  Up: Partition-Wide Restrictions

5.1.47 No_Protected_Type_Allocators
-----------------------------------

[RM D.7] This restriction ensures at compile time that there are no
allocator expressions that attempt to allocate protected objects.


File: gnat_rm.info,  Node: No_Protected_Types,  Next: No_Recursion,  Prev: No_Protected_Type_Allocators,  Up: Partition-Wide Restrictions

5.1.48 No_Protected_Types
-------------------------

[RM H.4] This restriction ensures at compile time that there are no
declarations of protected types or protected objects.


File: gnat_rm.info,  Node: No_Recursion,  Next: No_Reentrancy,  Prev: No_Protected_Types,  Up: Partition-Wide Restrictions

5.1.49 No_Recursion
-------------------

[RM H.4] A program execution is erroneous if a subprogram is invoked as
part of its execution.


File: gnat_rm.info,  Node: No_Reentrancy,  Next: No_Relative_Delay,  Prev: No_Recursion,  Up: Partition-Wide Restrictions

5.1.50 No_Reentrancy
--------------------

[RM H.4] A program execution is erroneous if a subprogram is executed by
two tasks at the same time.


File: gnat_rm.info,  Node: No_Relative_Delay,  Next: No_Requeue_Statements,  Prev: No_Reentrancy,  Up: Partition-Wide Restrictions

5.1.51 No_Relative_Delay
------------------------

[RM D.7] This restriction ensures at compile time that there are no
delay relative statements and prevents expressions such as ‘delay 1.23;’
from appearing in source code.


File: gnat_rm.info,  Node: No_Requeue_Statements,  Next: No_Secondary_Stack,  Prev: No_Relative_Delay,  Up: Partition-Wide Restrictions

5.1.52 No_Requeue_Statements
----------------------------

[RM D.7] This restriction ensures at compile time that no requeue
statements are permitted and prevents keyword ‘requeue’ from being used
in source code.

The restriction ‘No_Requeue’ is recognized as a synonym for
‘No_Requeue_Statements’.  This is retained for historical compatibility
purposes (and a warning will be generated for its use if warnings on
oNobsolescent features are activated).


File: gnat_rm.info,  Node: No_Secondary_Stack,  Next: No_Select_Statements,  Prev: No_Requeue_Statements,  Up: Partition-Wide Restrictions

5.1.53 No_Secondary_Stack
-------------------------

[GNAT] This restriction ensures at compile time that the generated code
does not contain any reference to the secondary stack.  The secondary
stack is used to implement functions returning unconstrained objects
(arrays or records) on some targets.  Suppresses the allocation of
secondary stacks for tasks (excluding the environment task) at run time.


File: gnat_rm.info,  Node: No_Select_Statements,  Next: No_Specific_Termination_Handlers,  Prev: No_Secondary_Stack,  Up: Partition-Wide Restrictions

5.1.54 No_Select_Statements
---------------------------

[RM D.7] This restriction ensures at compile time no select statements
of any kind are permitted, that is the keyword ‘select’ may not appear.


File: gnat_rm.info,  Node: No_Specific_Termination_Handlers,  Next: No_Specification_of_Aspect,  Prev: No_Select_Statements,  Up: Partition-Wide Restrictions

5.1.55 No_Specific_Termination_Handlers
---------------------------------------

[RM D.7] There are no calls to Ada.Task_Termination.Set_Specific_Handler
or to Ada.Task_Termination.Specific_Handler.


File: gnat_rm.info,  Node: No_Specification_of_Aspect,  Next: No_Standard_Allocators_After_Elaboration,  Prev: No_Specific_Termination_Handlers,  Up: Partition-Wide Restrictions

5.1.56 No_Specification_of_Aspect
---------------------------------

[RM 13.12.1] This restriction checks at compile time that no aspect
specification, attribute definition clause, or pragma is given for a
given aspect.


File: gnat_rm.info,  Node: No_Standard_Allocators_After_Elaboration,  Next: No_Standard_Storage_Pools,  Prev: No_Specification_of_Aspect,  Up: Partition-Wide Restrictions

5.1.57 No_Standard_Allocators_After_Elaboration
-----------------------------------------------

[RM D.7] Specifies that an allocator using a standard storage pool
should never be evaluated at run time after the elaboration of the
library items of the partition has completed.  Otherwise, Storage_Error
is raised.


File: gnat_rm.info,  Node: No_Standard_Storage_Pools,  Next: No_Stream_Optimizations,  Prev: No_Standard_Allocators_After_Elaboration,  Up: Partition-Wide Restrictions

5.1.58 No_Standard_Storage_Pools
--------------------------------

[GNAT] This restriction ensures at compile time that no access types use
the standard default storage pool.  Any access type declared must have
an explicit Storage_Pool attribute defined specifying a user-defined
storage pool.


File: gnat_rm.info,  Node: No_Stream_Optimizations,  Next: No_Streams,  Prev: No_Standard_Storage_Pools,  Up: Partition-Wide Restrictions

5.1.59 No_Stream_Optimizations
------------------------------

[GNAT] This restriction affects the performance of stream operations on
types ‘String’, ‘Wide_String’ and ‘Wide_Wide_String’.  By default, the
compiler uses block reads and writes when manipulating ‘String’ objects
due to their superior performance.  When this restriction is in effect,
the compiler performs all IO operations on a per-character basis.


File: gnat_rm.info,  Node: No_Streams,  Next: No_Tagged_Type_Registration,  Prev: No_Stream_Optimizations,  Up: Partition-Wide Restrictions

5.1.60 No_Streams
-----------------

[GNAT] This restriction ensures at compile/bind time that there are no
stream objects created and no use of stream attributes.  This
restriction does not forbid dependences on the package ‘Ada.Streams’.
So it is permissible to with ‘Ada.Streams’ (or another package that does
so itself) as long as no actual stream objects are created and no stream
attributes are used.

Note that the use of restriction allows optimization of tagged types,
since they do not need to worry about dispatching stream operations.  To
take maximum advantage of this space-saving optimization, any unit
declaring a tagged type should be compiled with the restriction, though
this is not required.


File: gnat_rm.info,  Node: No_Tagged_Type_Registration,  Next: No_Task_Allocators,  Prev: No_Streams,  Up: Partition-Wide Restrictions

5.1.61 No_Tagged_Type_Registration
----------------------------------

[GNAT] If this restriction is active, then class-wide streaming
attributes are not supported.  In addition, the subprograms in Ada.Tags
are not supported.  If this restriction is active, the generated code is
simplified by omitting the otherwise-required global registration of
tagged types when they are declared.  This restriction may be necessary
in order to also apply the No_Elaboration_Code restriction.


File: gnat_rm.info,  Node: No_Task_Allocators,  Next: No_Task_At_Interrupt_Priority,  Prev: No_Tagged_Type_Registration,  Up: Partition-Wide Restrictions

5.1.62 No_Task_Allocators
-------------------------

[RM D.7] There are no allocators for task types or types containing task
subcomponents.


File: gnat_rm.info,  Node: No_Task_At_Interrupt_Priority,  Next: No_Task_Attributes_Package,  Prev: No_Task_Allocators,  Up: Partition-Wide Restrictions

5.1.63 No_Task_At_Interrupt_Priority
------------------------------------

[GNAT] This restriction ensures at compile time that there is no
Interrupt_Priority aspect or pragma for a task or a task type.  As a
consequence, the tasks are always created with a priority below that an
interrupt priority.


File: gnat_rm.info,  Node: No_Task_Attributes_Package,  Next: No_Task_Hierarchy,  Prev: No_Task_At_Interrupt_Priority,  Up: Partition-Wide Restrictions

5.1.64 No_Task_Attributes_Package
---------------------------------

[GNAT] This restriction ensures at compile time that there are no
implicit or explicit dependencies on the package ‘Ada.Task_Attributes’.

The restriction ‘No_Task_Attributes’ is recognized as a synonym for
‘No_Task_Attributes_Package’.  This is retained for historical
compatibility purposes (and a warning will be generated for its use if
warnings on obsolescent features are activated).


File: gnat_rm.info,  Node: No_Task_Hierarchy,  Next: No_Task_Termination,  Prev: No_Task_Attributes_Package,  Up: Partition-Wide Restrictions

5.1.65 No_Task_Hierarchy
------------------------

[RM D.7] All (non-environment) tasks depend directly on the environment
task of the partition.


File: gnat_rm.info,  Node: No_Task_Termination,  Next: No_Tasking,  Prev: No_Task_Hierarchy,  Up: Partition-Wide Restrictions

5.1.66 No_Task_Termination
--------------------------

[RM D.7] Tasks that terminate are erroneous.


File: gnat_rm.info,  Node: No_Tasking,  Next: No_Terminate_Alternatives,  Prev: No_Task_Termination,  Up: Partition-Wide Restrictions

5.1.67 No_Tasking
-----------------

[GNAT] This restriction prevents the declaration of tasks or task types
throughout the partition.  It is similar in effect to the use of
‘Max_Tasks => 0’ except that violations are caught at compile time and
cause an error message to be output either by the compiler or binder.


File: gnat_rm.info,  Node: No_Terminate_Alternatives,  Next: No_Unchecked_Access,  Prev: No_Tasking,  Up: Partition-Wide Restrictions

5.1.68 No_Terminate_Alternatives
--------------------------------

[RM D.7] There are no selective accepts with terminate alternatives.


File: gnat_rm.info,  Node: No_Unchecked_Access,  Next: No_Unchecked_Conversion,  Prev: No_Terminate_Alternatives,  Up: Partition-Wide Restrictions

5.1.69 No_Unchecked_Access
--------------------------

[RM H.4] This restriction ensures at compile time that there are no
occurrences of the Unchecked_Access attribute.


File: gnat_rm.info,  Node: No_Unchecked_Conversion,  Next: No_Unchecked_Deallocation,  Prev: No_Unchecked_Access,  Up: Partition-Wide Restrictions

5.1.70 No_Unchecked_Conversion
------------------------------

[RM J.13] This restriction ensures at compile time that there are no
semantic dependences on the predefined generic function
Unchecked_Conversion.


File: gnat_rm.info,  Node: No_Unchecked_Deallocation,  Next: No_Use_Of_Entity,  Prev: No_Unchecked_Conversion,  Up: Partition-Wide Restrictions

5.1.71 No_Unchecked_Deallocation
--------------------------------

[RM J.13] This restriction ensures at compile time that there are no
semantic dependences on the predefined generic procedure
Unchecked_Deallocation.


File: gnat_rm.info,  Node: No_Use_Of_Entity,  Next: Pure_Barriers,  Prev: No_Unchecked_Deallocation,  Up: Partition-Wide Restrictions

5.1.72 No_Use_Of_Entity
-----------------------

[GNAT] This restriction ensures at compile time that there are no
references to the entity given in the form

     No_Use_Of_Entity => Name

where ‘Name’ is the fully qualified entity, for example

     No_Use_Of_Entity => Ada.Text_IO.Put_Line


File: gnat_rm.info,  Node: Pure_Barriers,  Next: Simple_Barriers,  Prev: No_Use_Of_Entity,  Up: Partition-Wide Restrictions

5.1.73 Pure_Barriers
--------------------

[GNAT] This restriction ensures at compile time that protected entry
barriers are restricted to:

   * components of the protected object (excluding selection from
     dereferences),

   * constant declarations,

   * named numbers,

   * enumeration literals,

   * integer literals,

   * real literals,

   * character literals,

   * implicitly defined comparison operators,

   * uses of the Standard.”not” operator,

   * short-circuit operator,

   * the Count attribute

This restriction is a relaxation of the Simple_Barriers restriction, but
still ensures absence of side effects, exceptions, and recursion during
the evaluation of the barriers.


File: gnat_rm.info,  Node: Simple_Barriers,  Next: Static_Priorities,  Prev: Pure_Barriers,  Up: Partition-Wide Restrictions

5.1.74 Simple_Barriers
----------------------

[RM D.7] This restriction ensures at compile time that barriers in entry
declarations for protected types are restricted to either static boolean
expressions or references to simple boolean variables defined in the
private part of the protected type.  No other form of entry barriers is
permitted.

The restriction ‘Boolean_Entry_Barriers’ is recognized as a synonym for
‘Simple_Barriers’.  This is retained for historical compatibility
purposes (and a warning will be generated for its use if warnings on
obsolescent features are activated).


File: gnat_rm.info,  Node: Static_Priorities,  Next: Static_Storage_Size,  Prev: Simple_Barriers,  Up: Partition-Wide Restrictions

5.1.75 Static_Priorities
------------------------

[GNAT] This restriction ensures at compile time that all priority
expressions are static, and that there are no dependences on the package
‘Ada.Dynamic_Priorities’.


File: gnat_rm.info,  Node: Static_Storage_Size,  Prev: Static_Priorities,  Up: Partition-Wide Restrictions

5.1.76 Static_Storage_Size
--------------------------

[GNAT] This restriction ensures at compile time that any expression
appearing in a Storage_Size pragma or attribute definition clause is
static.


File: gnat_rm.info,  Node: Program Unit Level Restrictions,  Prev: Partition-Wide Restrictions,  Up: Standard and Implementation Defined Restrictions

5.2 Program Unit Level Restrictions
===================================

The second set of restriction identifiers does not require
partition-wide consistency.  The restriction may be enforced for a
single compilation unit without any effect on any of the other
compilation units in the partition.

* Menu:

* No_Elaboration_Code::
* No_Dynamic_Accessibility_Checks::
* No_Dynamic_Sized_Objects::
* No_Entry_Queue::
* No_Implementation_Aspect_Specifications::
* No_Implementation_Attributes::
* No_Implementation_Identifiers::
* No_Implementation_Pragmas::
* No_Implementation_Restrictions::
* No_Implementation_Units::
* No_Implicit_Aliasing::
* No_Implicit_Loops::
* No_Obsolescent_Features::
* No_Wide_Characters::
* Static_Dispatch_Tables::
* SPARK_05::


File: gnat_rm.info,  Node: No_Elaboration_Code,  Next: No_Dynamic_Accessibility_Checks,  Up: Program Unit Level Restrictions

5.2.1 No_Elaboration_Code
-------------------------

[GNAT] This restriction ensures at compile time that no elaboration code
is generated.  Note that this is not the same condition as is enforced
by pragma ‘Preelaborate’.  There are cases in which pragma
‘Preelaborate’ still permits code to be generated (e.g., code to
initialize a large array to all zeroes), and there are cases of units
which do not meet the requirements for pragma ‘Preelaborate’, but for
which no elaboration code is generated.  Generally, it is the case that
preelaborable units will meet the restrictions, with the exception of
large aggregates initialized with an others_clause, and exception
declarations (which generate calls to a run-time registry procedure).
This restriction is enforced on a unit by unit basis, it need not be
obeyed consistently throughout a partition.

In the case of aggregates with others, if the aggregate has a dynamic
size, there is no way to eliminate the elaboration code (such dynamic
bounds would be incompatible with ‘Preelaborate’ in any case).  If the
bounds are static, then use of this restriction actually modifies the
code choice of the compiler to avoid generating a loop, and instead
generate the aggregate statically if possible, no matter how many times
the data for the others clause must be repeatedly generated.

It is not possible to precisely document the constructs which are
compatible with this restriction, since, unlike most other restrictions,
this is not a restriction on the source code, but a restriction on the
generated object code.  For example, if the source contains a
declaration:

     Val : constant Integer := X;

where X is not a static constant, it may be possible, depending on
complex optimization circuitry, for the compiler to figure out the value
of X at compile time, in which case this initialization can be done by
the loader, and requires no initialization code.  It is not possible to
document the precise conditions under which the optimizer can figure
this out.

Note that this the implementation of this restriction requires full code
generation.  If it is used in conjunction with “semantics only”
checking, then some cases of violations may be missed.

When this restriction is active, we are not requesting control-flow
preservation with -fpreserve-control-flow, and the static elaboration
model is used, the compiler is allowed to suppress the elaboration
counter normally associated with the unit.  This counter is typically
used to check for access before elaboration and to control multiple
elaboration attempts.


File: gnat_rm.info,  Node: No_Dynamic_Accessibility_Checks,  Next: No_Dynamic_Sized_Objects,  Prev: No_Elaboration_Code,  Up: Program Unit Level Restrictions

5.2.2 No_Dynamic_Accessibility_Checks
-------------------------------------

[GNAT] No dynamic accessibility checks are generated when this
restriction is in effect.  Instead, dangling references are prevented
via more conservative compile-time checking.  More specifically,
existing compile-time checks are enforced but with more conservative
assumptions about the accessibility levels of the relevant entities.
These conservative assumptions eliminate the need for dynamic
accessibility checks.

These new rules for computing (at compile-time) the accessibility level
of an anonymous access type T are as follows:

   * If T is a function result type then, from the caller’s perspective,
     its level is that of the innermost master enclosing the function
     call.  From the callee’s perspective, the level of parameters and
     local variables of the callee is statically deeper than the level
     of T.

     For any other accessibility level L such that the level of
     parameters and local variables of the callee is statically deeper
     than L, the level of T (from the callee’s perspective) is also
     statically deeper than L.

   * If T is the type of a formal parameter then, from the caller’s
     perspective, its level is at least as deep as that of the type of
     the corresponding actual parameter (whatever that actual parameter
     might be).  From the callee’s perspective, the level of parameters
     and local variables of the callee is statically deeper than the
     level of T.

   * If T is the type of a discriminant then its level is that of the
     discriminated type.

   * If T is the type of a stand-alone object then its level is the
     level of the object.

   * In all other cases, the level of T is as defined by the existing
     rules of Ada.


File: gnat_rm.info,  Node: No_Dynamic_Sized_Objects,  Next: No_Entry_Queue,  Prev: No_Dynamic_Accessibility_Checks,  Up: Program Unit Level Restrictions

5.2.3 No_Dynamic_Sized_Objects
------------------------------

[GNAT] This restriction disallows certain constructs that might lead to
the creation of dynamic-sized composite objects (or array or
discriminated type).  An array subtype indication is illegal if the
bounds are not static or references to discriminants of an enclosing
type.  A discriminated subtype indication is illegal if the type has
discriminant-dependent array components or a variant part, and the
discriminants are not static.  In addition, array and record aggregates
are illegal in corresponding cases.  Note that this restriction does not
forbid access discriminants.  It is often a good idea to combine this
restriction with No_Secondary_Stack.


File: gnat_rm.info,  Node: No_Entry_Queue,  Next: No_Implementation_Aspect_Specifications,  Prev: No_Dynamic_Sized_Objects,  Up: Program Unit Level Restrictions

5.2.4 No_Entry_Queue
--------------------

[GNAT] This restriction is a declaration that any protected entry
compiled in the scope of the restriction has at most one task waiting on
the entry at any one time, and so no queue is required.  This
restriction is not checked at compile time.  A program execution is
erroneous if an attempt is made to queue a second task on such an entry.


File: gnat_rm.info,  Node: No_Implementation_Aspect_Specifications,  Next: No_Implementation_Attributes,  Prev: No_Entry_Queue,  Up: Program Unit Level Restrictions

5.2.5 No_Implementation_Aspect_Specifications
---------------------------------------------

[RM 13.12.1] This restriction checks at compile time that no
GNAT-defined aspects are present.  With this restriction, the only
aspects that can be used are those defined in the Ada Reference Manual.


File: gnat_rm.info,  Node: No_Implementation_Attributes,  Next: No_Implementation_Identifiers,  Prev: No_Implementation_Aspect_Specifications,  Up: Program Unit Level Restrictions

5.2.6 No_Implementation_Attributes
----------------------------------

[RM 13.12.1] This restriction checks at compile time that no
GNAT-defined attributes are present.  With this restriction, the only
attributes that can be used are those defined in the Ada Reference
Manual.


File: gnat_rm.info,  Node: No_Implementation_Identifiers,  Next: No_Implementation_Pragmas,  Prev: No_Implementation_Attributes,  Up: Program Unit Level Restrictions

5.2.7 No_Implementation_Identifiers
-----------------------------------

[RM 13.12.1] This restriction checks at compile time that no
implementation-defined identifiers (marked with pragma
Implementation_Defined) occur within language-defined packages.


File: gnat_rm.info,  Node: No_Implementation_Pragmas,  Next: No_Implementation_Restrictions,  Prev: No_Implementation_Identifiers,  Up: Program Unit Level Restrictions

5.2.8 No_Implementation_Pragmas
-------------------------------

[RM 13.12.1] This restriction checks at compile time that no
GNAT-defined pragmas are present.  With this restriction, the only
pragmas that can be used are those defined in the Ada Reference Manual.


File: gnat_rm.info,  Node: No_Implementation_Restrictions,  Next: No_Implementation_Units,  Prev: No_Implementation_Pragmas,  Up: Program Unit Level Restrictions

5.2.9 No_Implementation_Restrictions
------------------------------------

[GNAT] This restriction checks at compile time that no GNAT-defined
restriction identifiers (other than ‘No_Implementation_Restrictions’
itself) are present.  With this restriction, the only other restriction
identifiers that can be used are those defined in the Ada Reference
Manual.


File: gnat_rm.info,  Node: No_Implementation_Units,  Next: No_Implicit_Aliasing,  Prev: No_Implementation_Restrictions,  Up: Program Unit Level Restrictions

5.2.10 No_Implementation_Units
------------------------------

[RM 13.12.1] This restriction checks at compile time that there is no
mention in the context clause of any implementation-defined descendants
of packages Ada, Interfaces, or System.


File: gnat_rm.info,  Node: No_Implicit_Aliasing,  Next: No_Implicit_Loops,  Prev: No_Implementation_Units,  Up: Program Unit Level Restrictions

5.2.11 No_Implicit_Aliasing
---------------------------

[GNAT] This restriction, which is not required to be partition-wide
consistent, requires an explicit aliased keyword for an object to which
‘Access, ‘Unchecked_Access, or ‘Address is applied, and forbids entirely
the use of the ‘Unrestricted_Access attribute for objects.  Note: the
reason that Unrestricted_Access is forbidden is that it would require
the prefix to be aliased, and in such cases, it can always be replaced
by the standard attribute Unchecked_Access which is preferable.


File: gnat_rm.info,  Node: No_Implicit_Loops,  Next: No_Obsolescent_Features,  Prev: No_Implicit_Aliasing,  Up: Program Unit Level Restrictions

5.2.12 No_Implicit_Loops
------------------------

[GNAT] This restriction ensures that the generated code of the unit
marked with this restriction does not contain any implicit ‘for’ loops,
either by modifying the generated code where possible, or by rejecting
any construct that would otherwise generate an implicit ‘for’ loop.  If
this restriction is active, it is possible to build large array
aggregates with all static components without generating an intermediate
temporary, and without generating a loop to initialize individual
components.  Otherwise, a loop is created for arrays larger than about
5000 scalar components.  Note that if this restriction is set in the
spec of a package, it will not apply to its body.


File: gnat_rm.info,  Node: No_Obsolescent_Features,  Next: No_Wide_Characters,  Prev: No_Implicit_Loops,  Up: Program Unit Level Restrictions

5.2.13 No_Obsolescent_Features
------------------------------

[RM 13.12.1] This restriction checks at compile time that no obsolescent
features are used, as defined in Annex J of the Ada Reference Manual.


File: gnat_rm.info,  Node: No_Wide_Characters,  Next: Static_Dispatch_Tables,  Prev: No_Obsolescent_Features,  Up: Program Unit Level Restrictions

5.2.14 No_Wide_Characters
-------------------------

[GNAT] This restriction ensures at compile time that no uses of the
types ‘Wide_Character’ or ‘Wide_String’ or corresponding wide wide types
appear, and that no wide or wide wide string or character literals
appear in the program (that is literals representing characters not in
type ‘Character’).


File: gnat_rm.info,  Node: Static_Dispatch_Tables,  Next: SPARK_05,  Prev: No_Wide_Characters,  Up: Program Unit Level Restrictions

5.2.15 Static_Dispatch_Tables
-----------------------------

[GNAT] This restriction checks at compile time that all the artifacts
associated with dispatch tables can be placed in read-only memory.


File: gnat_rm.info,  Node: SPARK_05,  Prev: Static_Dispatch_Tables,  Up: Program Unit Level Restrictions

5.2.16 SPARK_05
---------------

[GNAT] This restriction no longer has any effect and is superseded by
SPARK 2014, whose restrictions are checked by the tool GNATprove.  To
check that a codebase respects SPARK 2014 restrictions, mark the code
with pragma or aspect ‘SPARK_Mode’, and run the tool GNATprove at Stone
assurance level, as follows:

     gnatprove -P project.gpr --mode=stone

or equivalently:

     gnatprove -P project.gpr --mode=check_all


File: gnat_rm.info,  Node: Implementation Advice,  Next: Implementation Defined Characteristics,  Prev: Standard and Implementation Defined Restrictions,  Up: Top

6 Implementation Advice
***********************

The main text of the Ada Reference Manual describes the required
behavior of all Ada compilers, and the GNAT compiler conforms to these
requirements.

In addition, there are sections throughout the Ada Reference Manual
headed by the phrase ‘Implementation advice’.  These sections are not
normative, i.e., they do not specify requirements that all compilers
must follow.  Rather they provide advice on generally desirable
behavior.  They are not requirements, because they describe behavior
that cannot be provided on all systems, or may be undesirable on some
systems.

As far as practical, GNAT follows the implementation advice in the Ada
Reference Manual.  Each such RM section corresponds to a section in this
chapter whose title specifies the RM section number and paragraph number
and the subject of the advice.  The contents of each section consists of
the RM text within quotation marks, followed by the GNAT interpretation
of the advice.  Most often, this simply says ‘followed’, which means
that GNAT follows the advice.  However, in a number of cases, GNAT
deliberately deviates from this advice, in which case the text describes
what GNAT does and why.

* Menu:

* RM 1.1.3(20); Error Detection: RM 1 1 3 20 Error Detection.
* RM 1.1.3(31); Child Units: RM 1 1 3 31 Child Units.
* RM 1.1.5(12); Bounded Errors: RM 1 1 5 12 Bounded Errors.
* RM 2.8(16); Pragmas: RM 2 8 16 Pragmas.
* RM 2.8(17-19); Pragmas: RM 2 8 17-19 Pragmas.
* RM 3.5.2(5); Alternative Character Sets: RM 3 5 2 5 Alternative Character Sets.
* RM 3.5.4(28); Integer Types: RM 3 5 4 28 Integer Types.
* RM 3.5.4(29); Integer Types: RM 3 5 4 29 Integer Types.
* RM 3.5.5(8); Enumeration Values: RM 3 5 5 8 Enumeration Values.
* RM 3.5.7(17); Float Types: RM 3 5 7 17 Float Types.
* RM 3.6.2(11); Multidimensional Arrays: RM 3 6 2 11 Multidimensional Arrays.
* RM 9.6(30-31); Duration’Small: RM 9 6 30-31 Duration’Small.
* RM 10.2.1(12); Consistent Representation: RM 10 2 1 12 Consistent Representation.
* RM 11.4.1(19); Exception Information: RM 11 4 1 19 Exception Information.
* RM 11.5(28); Suppression of Checks: RM 11 5 28 Suppression of Checks.
* RM 13.1 (21-24); Representation Clauses: RM 13 1 21-24 Representation Clauses.
* RM 13.2(6-8); Packed Types: RM 13 2 6-8 Packed Types.
* RM 13.3(14-19); Address Clauses: RM 13 3 14-19 Address Clauses.
* RM 13.3(29-35); Alignment Clauses: RM 13 3 29-35 Alignment Clauses.
* RM 13.3(42-43); Size Clauses: RM 13 3 42-43 Size Clauses.
* RM 13.3(50-56); Size Clauses: RM 13 3 50-56 Size Clauses.
* RM 13.3(71-73); Component Size Clauses: RM 13 3 71-73 Component Size Clauses.
* RM 13.4(9-10); Enumeration Representation Clauses: RM 13 4 9-10 Enumeration Representation Clauses.
* RM 13.5.1(17-22); Record Representation Clauses: RM 13 5 1 17-22 Record Representation Clauses.
* RM 13.5.2(5); Storage Place Attributes: RM 13 5 2 5 Storage Place Attributes.
* RM 13.5.3(7-8); Bit Ordering: RM 13 5 3 7-8 Bit Ordering.
* RM 13.7(37); Address as Private: RM 13 7 37 Address as Private.
* RM 13.7.1(16); Address Operations: RM 13 7 1 16 Address Operations.
* RM 13.9(14-17); Unchecked Conversion: RM 13 9 14-17 Unchecked Conversion.
* RM 13.11(23-25); Implicit Heap Usage: RM 13 11 23-25 Implicit Heap Usage.
* RM 13.11.2(17); Unchecked Deallocation: RM 13 11 2 17 Unchecked Deallocation.
* RM 13.13.2(1.6); Stream Oriented Attributes: RM 13 13 2 1 6 Stream Oriented Attributes.
* RM A.1(52); Names of Predefined Numeric Types: RM A 1 52 Names of Predefined Numeric Types.
* RM A.3.2(49); Ada.Characters.Handling: RM A 3 2 49 Ada Characters Handling.
* RM A.4.4(106); Bounded-Length String Handling: RM A 4 4 106 Bounded-Length String Handling.
* RM A.5.2(46-47); Random Number Generation: RM A 5 2 46-47 Random Number Generation.
* RM A.10.7(23); Get_Immediate: RM A 10 7 23 Get_Immediate.
* RM A.18; Containers: RM A 18 Containers.
* RM B.1(39-41); Pragma Export: RM B 1 39-41 Pragma Export.
* RM B.2(12-13); Package Interfaces: RM B 2 12-13 Package Interfaces.
* RM B.3(63-71); Interfacing with C: RM B 3 63-71 Interfacing with C.
* RM B.4(95-98); Interfacing with COBOL: RM B 4 95-98 Interfacing with COBOL.
* RM B.5(22-26); Interfacing with Fortran: RM B 5 22-26 Interfacing with Fortran.
* RM C.1(3-5); Access to Machine Operations: RM C 1 3-5 Access to Machine Operations.
* RM C.1(10-16); Access to Machine Operations: RM C 1 10-16 Access to Machine Operations.
* RM C.3(28); Interrupt Support: RM C 3 28 Interrupt Support.
* RM C.3.1(20-21); Protected Procedure Handlers: RM C 3 1 20-21 Protected Procedure Handlers.
* RM C.3.2(25); Package Interrupts: RM C 3 2 25 Package Interrupts.
* RM C.4(14); Pre-elaboration Requirements: RM C 4 14 Pre-elaboration Requirements.
* RM C.5(8); Pragma Discard_Names: RM C 5 8 Pragma Discard_Names.
* RM C.7.2(30); The Package Task_Attributes: RM C 7 2 30 The Package Task_Attributes.
* RM D.3(17); Locking Policies: RM D 3 17 Locking Policies.
* RM D.4(16); Entry Queuing Policies: RM D 4 16 Entry Queuing Policies.
* RM D.6(9-10); Preemptive Abort: RM D 6 9-10 Preemptive Abort.
* RM D.7(21); Tasking Restrictions: RM D 7 21 Tasking Restrictions.
* RM D.8(47-49); Monotonic Time: RM D 8 47-49 Monotonic Time.
* RM E.5(28-29); Partition Communication Subsystem: RM E 5 28-29 Partition Communication Subsystem.
* RM F(7); COBOL Support: RM F 7 COBOL Support.
* RM F.1(2); Decimal Radix Support: RM F 1 2 Decimal Radix Support.
* RM G; Numerics: RM G Numerics.
* RM G.1.1(56-58); Complex Types: RM G 1 1 56-58 Complex Types.
* RM G.1.2(49); Complex Elementary Functions: RM G 1 2 49 Complex Elementary Functions.
* RM G.2.4(19); Accuracy Requirements: RM G 2 4 19 Accuracy Requirements.
* RM G.2.6(15); Complex Arithmetic Accuracy: RM G 2 6 15 Complex Arithmetic Accuracy.
* RM H.6(15/2); Pragma Partition_Elaboration_Policy: RM H 6 15/2 Pragma Partition_Elaboration_Policy.


File: gnat_rm.info,  Node: RM 1 1 3 20 Error Detection,  Next: RM 1 1 3 31 Child Units,  Up: Implementation Advice

6.1 RM 1.1.3(20): Error Detection
=================================

     “If an implementation detects the use of an unsupported Specialized
     Needs Annex feature at run time, it should raise ‘Program_Error’ if
     feasible.”

Not relevant.  All specialized needs annex features are either
supported, or diagnosed at compile time.


File: gnat_rm.info,  Node: RM 1 1 3 31 Child Units,  Next: RM 1 1 5 12 Bounded Errors,  Prev: RM 1 1 3 20 Error Detection,  Up: Implementation Advice

6.2 RM 1.1.3(31): Child Units
=============================

     “If an implementation wishes to provide implementation-defined
     extensions to the functionality of a language-defined library unit,
     it should normally do so by adding children to the library unit.”

Followed.


File: gnat_rm.info,  Node: RM 1 1 5 12 Bounded Errors,  Next: RM 2 8 16 Pragmas,  Prev: RM 1 1 3 31 Child Units,  Up: Implementation Advice

6.3 RM 1.1.5(12): Bounded Errors
================================

     “If an implementation detects a bounded error or erroneous
     execution, it should raise ‘Program_Error’.”

Followed in all cases in which the implementation detects a bounded
error or erroneous execution.  Not all such situations are detected at
runtime.


File: gnat_rm.info,  Node: RM 2 8 16 Pragmas,  Next: RM 2 8 17-19 Pragmas,  Prev: RM 1 1 5 12 Bounded Errors,  Up: Implementation Advice

6.4 RM 2.8(16): Pragmas
=======================

     “Normally, implementation-defined pragmas should have no semantic
     effect for error-free programs; that is, if the
     implementation-defined pragmas are removed from a working program,
     the program should still be legal, and should still have the same
     semantics.”

The following implementation defined pragmas are exceptions to this
rule:

Pragma                   Explanation
                         
-------------------------------------------------
                         
`Abort_Defer'            Affects semantics
                         
                         
`Ada_83'                 Affects legality
                         
                         
`Assert'                 Affects semantics
                         
                         
`CPP_Class'              Affects semantics
                         
                         
`CPP_Constructor'        Affects semantics
                         
                         
`Debug'                  Affects semantics
                         
                         
`Interface_Name'         Affects semantics
                         
                         
`Machine_Attribute'      Affects semantics
                         
                         
`Unimplemented_Unit'     Affects legality
                         
                         
`Unchecked_Union'        Affects semantics
                         

In each of the above cases, it is essential to the purpose of the pragma
that this advice not be followed.  For details see *note Implementation
Defined Pragmas: 7.


File: gnat_rm.info,  Node: RM 2 8 17-19 Pragmas,  Next: RM 3 5 2 5 Alternative Character Sets,  Prev: RM 2 8 16 Pragmas,  Up: Implementation Advice

6.5 RM 2.8(17-19): Pragmas
==========================

     “Normally, an implementation should not define pragmas that can
     make an illegal program legal, except as follows:

        * A pragma used to complete a declaration, such as a pragma
          ‘Import’;

        * A pragma used to configure the environment by adding,
          removing, or replacing ‘library_items’.”

See *note RM 2.8(16); Pragmas: 21b.


File: gnat_rm.info,  Node: RM 3 5 2 5 Alternative Character Sets,  Next: RM 3 5 4 28 Integer Types,  Prev: RM 2 8 17-19 Pragmas,  Up: Implementation Advice

6.6 RM 3.5.2(5): Alternative Character Sets
===========================================

     “If an implementation supports a mode with alternative
     interpretations for ‘Character’ and ‘Wide_Character’, the set of
     graphic characters of ‘Character’ should nevertheless remain a
     proper subset of the set of graphic characters of ‘Wide_Character’.
     Any character set ‘localizations’ should be reflected in the
     results of the subprograms defined in the language-defined package
     ‘Characters.Handling’ (see A.3) available in such a mode.  In a
     mode with an alternative interpretation of ‘Character’, the
     implementation should also support a corresponding change in what
     is a legal ‘identifier_letter’.”

Not all wide character modes follow this advice, in particular the JIS
and IEC modes reflect standard usage in Japan, and in these encoding,
the upper half of the Latin-1 set is not part of the wide-character
subset, since the most significant bit is used for wide character
encoding.  However, this only applies to the external forms.  Internally
there is no such restriction.


File: gnat_rm.info,  Node: RM 3 5 4 28 Integer Types,  Next: RM 3 5 4 29 Integer Types,  Prev: RM 3 5 2 5 Alternative Character Sets,  Up: Implementation Advice

6.7 RM 3.5.4(28): Integer Types
===============================

     “An implementation should support ‘Long_Integer’ in addition to
     ‘Integer’ if the target machine supports 32-bit (or longer)
     arithmetic.  No other named integer subtypes are recommended for
     package ‘Standard’.  Instead, appropriate named integer subtypes
     should be provided in the library package ‘Interfaces’ (see B.2).”

‘Long_Integer’ is supported.  Other standard integer types are supported
so this advice is not fully followed.  These types are supported for
convenient interface to C, and so that all hardware types of the machine
are easily available.


File: gnat_rm.info,  Node: RM 3 5 4 29 Integer Types,  Next: RM 3 5 5 8 Enumeration Values,  Prev: RM 3 5 4 28 Integer Types,  Up: Implementation Advice

6.8 RM 3.5.4(29): Integer Types
===============================

     “An implementation for a two’s complement machine should support
     modular types with a binary modulus up to ‘System.Max_Int*2+2’.  An
     implementation should support a non-binary modules up to
     ‘Integer'Last’.”

Followed.


File: gnat_rm.info,  Node: RM 3 5 5 8 Enumeration Values,  Next: RM 3 5 7 17 Float Types,  Prev: RM 3 5 4 29 Integer Types,  Up: Implementation Advice

6.9 RM 3.5.5(8): Enumeration Values
===================================

     “For the evaluation of a call on ‘S'Pos’ for an enumeration
     subtype, if the value of the operand does not correspond to the
     internal code for any enumeration literal of its type (perhaps due
     to an un-initialized variable), then the implementation should
     raise ‘Program_Error’.  This is particularly important for
     enumeration types with noncontiguous internal codes specified by an
     enumeration_representation_clause.”

Followed.


File: gnat_rm.info,  Node: RM 3 5 7 17 Float Types,  Next: RM 3 6 2 11 Multidimensional Arrays,  Prev: RM 3 5 5 8 Enumeration Values,  Up: Implementation Advice

6.10 RM 3.5.7(17): Float Types
==============================

     “An implementation should support ‘Long_Float’ in addition to
     ‘Float’ if the target machine supports 11 or more digits of
     precision.  No other named floating point subtypes are recommended
     for package ‘Standard’.  Instead, appropriate named floating point
     subtypes should be provided in the library package ‘Interfaces’
     (see B.2).”

‘Short_Float’ and ‘Long_Long_Float’ are also provided.  The former
provides improved compatibility with other implementations supporting
this type.  The latter corresponds to the highest precision
floating-point type supported by the hardware.  On most machines, this
will be the same as ‘Long_Float’, but on some machines, it will
correspond to the IEEE extended form.  The notable case is all x86
implementations, where ‘Long_Long_Float’ corresponds to the 80-bit
extended precision format supported in hardware on this processor.  Note
that the 128-bit format on SPARC is not supported, since this is a
software rather than a hardware format.


File: gnat_rm.info,  Node: RM 3 6 2 11 Multidimensional Arrays,  Next: RM 9 6 30-31 Duration’Small,  Prev: RM 3 5 7 17 Float Types,  Up: Implementation Advice

6.11 RM 3.6.2(11): Multidimensional Arrays
==========================================

     “An implementation should normally represent multidimensional
     arrays in row-major order, consistent with the notation used for
     multidimensional array aggregates (see 4.3.3).  However, if a
     pragma ‘Convention’ (‘Fortran’, …) applies to a multidimensional
     array type, then column-major order should be used instead (see
     B.5, `Interfacing with Fortran').”

Followed.


File: gnat_rm.info,  Node: RM 9 6 30-31 Duration’Small,  Next: RM 10 2 1 12 Consistent Representation,  Prev: RM 3 6 2 11 Multidimensional Arrays,  Up: Implementation Advice

6.12 RM 9.6(30-31): Duration’Small
==================================

     “Whenever possible in an implementation, the value of
     ‘Duration'Small’ should be no greater than 100 microseconds.”

Followed.  (‘Duration'Small’ = 10**(-9)).

     “The time base for ‘delay_relative_statements’ should be monotonic;
     it need not be the same time base as used for ‘Calendar.Clock’.”

Followed.


File: gnat_rm.info,  Node: RM 10 2 1 12 Consistent Representation,  Next: RM 11 4 1 19 Exception Information,  Prev: RM 9 6 30-31 Duration’Small,  Up: Implementation Advice

6.13 RM 10.2.1(12): Consistent Representation
=============================================

     “In an implementation, a type declared in a pre-elaborated package
     should have the same representation in every elaboration of a given
     version of the package, whether the elaborations occur in distinct
     executions of the same program, or in executions of distinct
     programs or partitions that include the given version.”

Followed, except in the case of tagged types.  Tagged types involve
implicit pointers to a local copy of a dispatch table, and these
pointers have representations which thus depend on a particular
elaboration of the package.  It is not easy to see how it would be
possible to follow this advice without severely impacting efficiency of
execution.


File: gnat_rm.info,  Node: RM 11 4 1 19 Exception Information,  Next: RM 11 5 28 Suppression of Checks,  Prev: RM 10 2 1 12 Consistent Representation,  Up: Implementation Advice

6.14 RM 11.4.1(19): Exception Information
=========================================

     “‘Exception_Message’ by default and ‘Exception_Information’ should
     produce information useful for debugging.  ‘Exception_Message’
     should be short, about one line.  ‘Exception_Information’ can be
     long.  ‘Exception_Message’ should not include the ‘Exception_Name’.
     ‘Exception_Information’ should include both the ‘Exception_Name’
     and the ‘Exception_Message’.”

Followed.  For each exception that doesn’t have a specified
‘Exception_Message’, the compiler generates one containing the location
of the raise statement.  This location has the form ‘file_name:line’,
where file_name is the short file name (without path information) and
line is the line number in the file.  Note that in the case of the Zero
Cost Exception mechanism, these messages become redundant with the
Exception_Information that contains a full backtrace of the calling
sequence, so they are disabled.  To disable explicitly the generation of
the source location message, use the Pragma ‘Discard_Names’.


File: gnat_rm.info,  Node: RM 11 5 28 Suppression of Checks,  Next: RM 13 1 21-24 Representation Clauses,  Prev: RM 11 4 1 19 Exception Information,  Up: Implementation Advice

6.15 RM 11.5(28): Suppression of Checks
=======================================

     “The implementation should minimize the code executed for checks
     that have been suppressed.”

Followed.


File: gnat_rm.info,  Node: RM 13 1 21-24 Representation Clauses,  Next: RM 13 2 6-8 Packed Types,  Prev: RM 11 5 28 Suppression of Checks,  Up: Implementation Advice

6.16 RM 13.1 (21-24): Representation Clauses
============================================

     “The recommended level of support for all representation items is
     qualified as follows:

     An implementation need not support representation items containing
     nonstatic expressions, except that an implementation should support
     a representation item for a given entity if each nonstatic
     expression in the representation item is a name that statically
     denotes a constant declared before the entity.”

Followed.  In fact, GNAT goes beyond the recommended level of support by
allowing nonstatic expressions in some representation clauses even
without the need to declare constants initialized with the values of
such expressions.  For example:

       X : Integer;
       Y : Float;
       for Y'Address use X'Address;>>


     "An implementation need not support a specification for the ``Size``
     for a given composite subtype, nor the size or storage place for an
     object (including a component) of a given composite subtype, unless the
     constraints on the subtype and its composite subcomponents (if any) are
     all static constraints."

Followed.  Size Clauses are not permitted on nonstatic components, as
described above.

     “An aliased component, or a component whose type is by-reference,
     should always be allocated at an addressable location.”

Followed.


File: gnat_rm.info,  Node: RM 13 2 6-8 Packed Types,  Next: RM 13 3 14-19 Address Clauses,  Prev: RM 13 1 21-24 Representation Clauses,  Up: Implementation Advice

6.17 RM 13.2(6-8): Packed Types
===============================

     “If a type is packed, then the implementation should try to
     minimize storage allocated to objects of the type, possibly at the
     expense of speed of accessing components, subject to reasonable
     complexity in addressing calculations.

     The recommended level of support pragma ‘Pack’ is:

     For a packed record type, the components should be packed as
     tightly as possible subject to the Sizes of the component subtypes,
     and subject to any `record_representation_clause' that applies to
     the type; the implementation may, but need not, reorder components
     or cross aligned word boundaries to improve the packing.  A
     component whose ‘Size’ is greater than the word size may be
     allocated an integral number of words.”

Followed.  Tight packing of arrays is supported for all component sizes
up to 64-bits.  If the array component size is 1 (that is to say, if the
component is a boolean type or an enumeration type with two values) then
values of the type are implicitly initialized to zero.  This happens
both for objects of the packed type, and for objects that have a
subcomponent of the packed type.

     “An implementation should support Address clauses for imported
     subprograms.”

Followed.


File: gnat_rm.info,  Node: RM 13 3 14-19 Address Clauses,  Next: RM 13 3 29-35 Alignment Clauses,  Prev: RM 13 2 6-8 Packed Types,  Up: Implementation Advice

6.18 RM 13.3(14-19): Address Clauses
====================================

     “For an array ‘X’, ‘X'Address’ should point at the first component
     of the array, and not at the array bounds.”

Followed.

     “The recommended level of support for the ‘Address’ attribute is:

     ‘X'Address’ should produce a useful result if ‘X’ is an object that
     is aliased or of a by-reference type, or is an entity whose
     ‘Address’ has been specified.”

Followed.  A valid address will be produced even if none of those
conditions have been met.  If necessary, the object is forced into
memory to ensure the address is valid.

     “An implementation should support ‘Address’ clauses for imported
     subprograms.”

Followed.

     “Objects (including subcomponents) that are aliased or of a
     by-reference type should be allocated on storage element
     boundaries.”

Followed.

     “If the ‘Address’ of an object is specified, or it is imported or
     exported, then the implementation should not perform optimizations
     based on assumptions of no aliases.”

Followed.


File: gnat_rm.info,  Node: RM 13 3 29-35 Alignment Clauses,  Next: RM 13 3 42-43 Size Clauses,  Prev: RM 13 3 14-19 Address Clauses,  Up: Implementation Advice

6.19 RM 13.3(29-35): Alignment Clauses
======================================

     “The recommended level of support for the ‘Alignment’ attribute for
     subtypes is:

     An implementation should support specified Alignments that are
     factors and multiples of the number of storage elements per word,
     subject to the following:”

Followed.

     “An implementation need not support specified Alignments for
     combinations of Sizes and Alignments that cannot be easily loaded
     and stored by available machine instructions.”

Followed.

     “An implementation need not support specified Alignments that are
     greater than the maximum ‘Alignment’ the implementation ever
     returns by default.”

Followed.

     “The recommended level of support for the ‘Alignment’ attribute for
     objects is:

     Same as above, for subtypes, but in addition:”

Followed.

     “For stand-alone library-level objects of statically constrained
     subtypes, the implementation should support all alignments
     supported by the target linker.  For example, page alignment is
     likely to be supported for such objects, but not for subtypes.”

Followed.


File: gnat_rm.info,  Node: RM 13 3 42-43 Size Clauses,  Next: RM 13 3 50-56 Size Clauses,  Prev: RM 13 3 29-35 Alignment Clauses,  Up: Implementation Advice

6.20 RM 13.3(42-43): Size Clauses
=================================

     “The recommended level of support for the ‘Size’ attribute of
     objects is:

     A ‘Size’ clause should be supported for an object if the specified
     ‘Size’ is at least as large as its subtype’s ‘Size’, and
     corresponds to a size in storage elements that is a multiple of the
     object’s ‘Alignment’ (if the ‘Alignment’ is nonzero).”

Followed.


File: gnat_rm.info,  Node: RM 13 3 50-56 Size Clauses,  Next: RM 13 3 71-73 Component Size Clauses,  Prev: RM 13 3 42-43 Size Clauses,  Up: Implementation Advice

6.21 RM 13.3(50-56): Size Clauses
=================================

     “If the ‘Size’ of a subtype is specified, and allows for efficient
     independent addressability (see 9.10) on the target architecture,
     then the ‘Size’ of the following objects of the subtype should
     equal the ‘Size’ of the subtype:

     Aliased objects (including components).”

Followed.

     “‘Size’ clause on a composite subtype should not affect the
     internal layout of components.”

Followed.  But note that this can be overridden by use of the
implementation pragma Implicit_Packing in the case of packed arrays.

     “The recommended level of support for the ‘Size’ attribute of
     subtypes is:

     The ‘Size’ (if not specified) of a static discrete or fixed point
     subtype should be the number of bits needed to represent each value
     belonging to the subtype using an unbiased representation, leaving
     space for a sign bit only if the subtype contains negative values.
     If such a subtype is a first subtype, then an implementation should
     support a specified ‘Size’ for it that reflects this
     representation.”

Followed.

     “For a subtype implemented with levels of indirection, the ‘Size’
     should include the size of the pointers, but not the size of what
     they point at.”

Followed.


File: gnat_rm.info,  Node: RM 13 3 71-73 Component Size Clauses,  Next: RM 13 4 9-10 Enumeration Representation Clauses,  Prev: RM 13 3 50-56 Size Clauses,  Up: Implementation Advice

6.22 RM 13.3(71-73): Component Size Clauses
===========================================

     “The recommended level of support for the ‘Component_Size’
     attribute is:

     An implementation need not support specified ‘Component_Sizes’ that
     are less than the ‘Size’ of the component subtype.”

Followed.

     “An implementation should support specified Component_Sizes that
     are factors and multiples of the word size.  For such
     Component_Sizes, the array should contain no gaps between
     components.  For other Component_Sizes (if supported), the array
     should contain no gaps between components when packing is also
     specified; the implementation should forbid this combination in
     cases where it cannot support a no-gaps representation.”

Followed.


File: gnat_rm.info,  Node: RM 13 4 9-10 Enumeration Representation Clauses,  Next: RM 13 5 1 17-22 Record Representation Clauses,  Prev: RM 13 3 71-73 Component Size Clauses,  Up: Implementation Advice

6.23 RM 13.4(9-10): Enumeration Representation Clauses
======================================================

     “The recommended level of support for enumeration representation
     clauses is:

     An implementation need not support enumeration representation
     clauses for boolean types, but should at minimum support the
     internal codes in the range ‘System.Min_Int .. System.Max_Int’.”

Followed.


File: gnat_rm.info,  Node: RM 13 5 1 17-22 Record Representation Clauses,  Next: RM 13 5 2 5 Storage Place Attributes,  Prev: RM 13 4 9-10 Enumeration Representation Clauses,  Up: Implementation Advice

6.24 RM 13.5.1(17-22): Record Representation Clauses
====================================================

     “The recommended level of support for
     `record_representation_clause's is:

     An implementation should support storage places that can be
     extracted with a load, mask, shift sequence of machine code, and
     set with a load, shift, mask, store sequence, given the available
     machine instructions and run-time model.”

Followed.

     “A storage place should be supported if its size is equal to the
     ‘Size’ of the component subtype, and it starts and ends on a
     boundary that obeys the ‘Alignment’ of the component subtype.”

Followed.

     “If the default bit ordering applies to the declaration of a given
     type, then for a component whose subtype’s ‘Size’ is less than the
     word size, any storage place that does not cross an aligned word
     boundary should be supported.”

Followed.

     “An implementation may reserve a storage place for the tag field of
     a tagged type, and disallow other components from overlapping that
     place.”

Followed.  The storage place for the tag field is the beginning of the
tagged record, and its size is Address’Size.  GNAT will reject an
explicit component clause for the tag field.

     “An implementation need not support a `component_clause' for a
     component of an extension part if the storage place is not after
     the storage places of all components of the parent type, whether or
     not those storage places had been specified.”

Followed.  The above advice on record representation clauses is
followed, and all mentioned features are implemented.


File: gnat_rm.info,  Node: RM 13 5 2 5 Storage Place Attributes,  Next: RM 13 5 3 7-8 Bit Ordering,  Prev: RM 13 5 1 17-22 Record Representation Clauses,  Up: Implementation Advice

6.25 RM 13.5.2(5): Storage Place Attributes
===========================================

     “If a component is represented using some form of pointer (such as
     an offset) to the actual data of the component, and this data is
     contiguous with the rest of the object, then the storage place
     attributes should reflect the place of the actual data, not the
     pointer.  If a component is allocated discontinuously from the rest
     of the object, then a warning should be generated upon reference to
     one of its storage place attributes.”

Followed.  There are no such components in GNAT.


File: gnat_rm.info,  Node: RM 13 5 3 7-8 Bit Ordering,  Next: RM 13 7 37 Address as Private,  Prev: RM 13 5 2 5 Storage Place Attributes,  Up: Implementation Advice

6.26 RM 13.5.3(7-8): Bit Ordering
=================================

     “The recommended level of support for the non-default bit ordering
     is:

     If ‘Word_Size’ = ‘Storage_Unit’, then the implementation should
     support the non-default bit ordering in addition to the default bit
     ordering.”

Followed.  Word size does not equal storage size in this implementation.
Thus non-default bit ordering is not supported.


File: gnat_rm.info,  Node: RM 13 7 37 Address as Private,  Next: RM 13 7 1 16 Address Operations,  Prev: RM 13 5 3 7-8 Bit Ordering,  Up: Implementation Advice

6.27 RM 13.7(37): Address as Private
====================================

     “‘Address’ should be of a private type.”

Followed.


File: gnat_rm.info,  Node: RM 13 7 1 16 Address Operations,  Next: RM 13 9 14-17 Unchecked Conversion,  Prev: RM 13 7 37 Address as Private,  Up: Implementation Advice

6.28 RM 13.7.1(16): Address Operations
======================================

     “Operations in ‘System’ and its children should reflect the target
     environment semantics as closely as is reasonable.  For example, on
     most machines, it makes sense for address arithmetic to ‘wrap
     around’.  Operations that do not make sense should raise
     ‘Program_Error’.”

Followed.  Address arithmetic is modular arithmetic that wraps around.
No operation raises ‘Program_Error’, since all operations make sense.


File: gnat_rm.info,  Node: RM 13 9 14-17 Unchecked Conversion,  Next: RM 13 11 23-25 Implicit Heap Usage,  Prev: RM 13 7 1 16 Address Operations,  Up: Implementation Advice

6.29 RM 13.9(14-17): Unchecked Conversion
=========================================

     “The ‘Size’ of an array object should not include its bounds;
     hence, the bounds should not be part of the converted data.”

Followed.

     “The implementation should not generate unnecessary run-time checks
     to ensure that the representation of ‘S’ is a representation of the
     target type.  It should take advantage of the permission to return
     by reference when possible.  Restrictions on unchecked conversions
     should be avoided unless required by the target environment.”

Followed.  There are no restrictions on unchecked conversion.  A warning
is generated if the source and target types do not have the same size
since the semantics in this case may be target dependent.

     “The recommended level of support for unchecked conversions is:

     Unchecked conversions should be supported and should be reversible
     in the cases where this clause defines the result.  To enable
     meaningful use of unchecked conversion, a contiguous representation
     should be used for elementary subtypes, for statically constrained
     array subtypes whose component subtype is one of the subtypes
     described in this paragraph, and for record subtypes without
     discriminants whose component subtypes are described in this
     paragraph.”

Followed.


File: gnat_rm.info,  Node: RM 13 11 23-25 Implicit Heap Usage,  Next: RM 13 11 2 17 Unchecked Deallocation,  Prev: RM 13 9 14-17 Unchecked Conversion,  Up: Implementation Advice

6.30 RM 13.11(23-25): Implicit Heap Usage
=========================================

     “An implementation should document any cases in which it
     dynamically allocates heap storage for a purpose other than the
     evaluation of an allocator.”

Followed, the only other points at which heap storage is dynamically
allocated are as follows:

   * At initial elaboration time, to allocate dynamically sized global
     objects.

   * To allocate space for a task when a task is created.

   * To extend the secondary stack dynamically when needed.  The
     secondary stack is used for returning variable length results.

     “A default (implementation-provided) storage pool for an
     access-to-constant type should not have overhead to support
     deallocation of individual objects.”

Followed.

     “A storage pool for an anonymous access type should be created at
     the point of an allocator for the type, and be reclaimed when the
     designated object becomes inaccessible.”

Followed.


File: gnat_rm.info,  Node: RM 13 11 2 17 Unchecked Deallocation,  Next: RM 13 13 2 1 6 Stream Oriented Attributes,  Prev: RM 13 11 23-25 Implicit Heap Usage,  Up: Implementation Advice

6.31 RM 13.11.2(17): Unchecked Deallocation
===========================================

     “For a standard storage pool, ‘Free’ should actually reclaim the
     storage.”

Followed.


File: gnat_rm.info,  Node: RM 13 13 2 1 6 Stream Oriented Attributes,  Next: RM A 1 52 Names of Predefined Numeric Types,  Prev: RM 13 11 2 17 Unchecked Deallocation,  Up: Implementation Advice

6.32 RM 13.13.2(1.6): Stream Oriented Attributes
================================================

     “If not specified, the value of Stream_Size for an elementary type
     should be the number of bits that corresponds to the minimum number
     of stream elements required by the first subtype of the type,
     rounded up to the nearest factor or multiple of the word size that
     is also a multiple of the stream element size.”

Followed, except that the number of stream elements is 1, 2, 3, 4 or 8.
The Stream_Size may be used to override the default choice.

The default implementation is based on direct binary representations and
is therefore target- and endianness-dependent.  To address this issue,
GNAT also supplies an alternate implementation of the stream attributes
‘Read’ and ‘Write’, which uses the target-independent XDR standard
representation for scalar types.  This XDR alternative can be enabled
via the binder switch -xdr.


File: gnat_rm.info,  Node: RM A 1 52 Names of Predefined Numeric Types,  Next: RM A 3 2 49 Ada Characters Handling,  Prev: RM 13 13 2 1 6 Stream Oriented Attributes,  Up: Implementation Advice

6.33 RM A.1(52): Names of Predefined Numeric Types
==================================================

     “If an implementation provides additional named predefined integer
     types, then the names should end with ‘Integer’ as in
     ‘Long_Integer’.  If an implementation provides additional named
     predefined floating point types, then the names should end with
     ‘Float’ as in ‘Long_Float’.”

Followed.


File: gnat_rm.info,  Node: RM A 3 2 49 Ada Characters Handling,  Next: RM A 4 4 106 Bounded-Length String Handling,  Prev: RM A 1 52 Names of Predefined Numeric Types,  Up: Implementation Advice

6.34 RM A.3.2(49): ‘Ada.Characters.Handling’
============================================

     “If an implementation provides a localized definition of
     ‘Character’ or ‘Wide_Character’, then the effects of the
     subprograms in ‘Characters.Handling’ should reflect the
     localizations.  See also 3.5.2.”

Followed.  GNAT provides no such localized definitions.


File: gnat_rm.info,  Node: RM A 4 4 106 Bounded-Length String Handling,  Next: RM A 5 2 46-47 Random Number Generation,  Prev: RM A 3 2 49 Ada Characters Handling,  Up: Implementation Advice

6.35 RM A.4.4(106): Bounded-Length String Handling
==================================================

     “Bounded string objects should not be implemented by implicit
     pointers and dynamic allocation.”

Followed.  No implicit pointers or dynamic allocation are used.


File: gnat_rm.info,  Node: RM A 5 2 46-47 Random Number Generation,  Next: RM A 10 7 23 Get_Immediate,  Prev: RM A 4 4 106 Bounded-Length String Handling,  Up: Implementation Advice

6.36 RM A.5.2(46-47): Random Number Generation
==============================================

     “Any storage associated with an object of type ‘Generator’ should
     be reclaimed on exit from the scope of the object.”

Followed.

     “If the generator period is sufficiently long in relation to the
     number of distinct initiator values, then each possible value of
     ‘Initiator’ passed to ‘Reset’ should initiate a sequence of random
     numbers that does not, in a practical sense, overlap the sequence
     initiated by any other value.  If this is not possible, then the
     mapping between initiator values and generator states should be a
     rapidly varying function of the initiator value.”

Followed.  The generator period is sufficiently long for the first
condition here to hold true.


File: gnat_rm.info,  Node: RM A 10 7 23 Get_Immediate,  Next: RM A 18 Containers,  Prev: RM A 5 2 46-47 Random Number Generation,  Up: Implementation Advice

6.37 RM A.10.7(23): ‘Get_Immediate’
===================================

     “The ‘Get_Immediate’ procedures should be implemented with
     unbuffered input.  For a device such as a keyboard, input should be
     available if a key has already been typed, whereas for a disk file,
     input should always be available except at end of file.  For a file
     associated with a keyboard-like device, any line-editing features
     of the underlying operating system should be disabled during the
     execution of ‘Get_Immediate’.”

Followed on all targets except VxWorks.  For VxWorks, there is no way to
provide this functionality that does not result in the input buffer
being flushed before the ‘Get_Immediate’ call.  A special unit
‘Interfaces.Vxworks.IO’ is provided that contains routines to enable
this functionality.


File: gnat_rm.info,  Node: RM A 18 Containers,  Next: RM B 1 39-41 Pragma Export,  Prev: RM A 10 7 23 Get_Immediate,  Up: Implementation Advice

6.38 RM A.18: ‘Containers’
==========================

All implementation advice pertaining to Ada.Containers and its child
units (that is, all implementation advice occurring within section A.18
and its subsections) is followed except for A.18.24(17):

     “Bounded ordered set objects should be implemented without implicit
     pointers or dynamic allocation.  “

The implementations of the two Reference_Preserving_Key functions of the
generic package Ada.Containers.Bounded_Ordered_Sets each currently make
use of dynamic allocation; other operations on bounded ordered set
objects follow the implementation advice.


File: gnat_rm.info,  Node: RM B 1 39-41 Pragma Export,  Next: RM B 2 12-13 Package Interfaces,  Prev: RM A 18 Containers,  Up: Implementation Advice

6.39 RM B.1(39-41): Pragma ‘Export’
===================================

     “If an implementation supports pragma ‘Export’ to a given language,
     then it should also allow the main subprogram to be written in that
     language.  It should support some mechanism for invoking the
     elaboration of the Ada library units included in the system, and
     for invoking the finalization of the environment task.  On typical
     systems, the recommended mechanism is to provide two subprograms
     whose link names are ‘adainit’ and ‘adafinal’.  ‘adainit’ should
     contain the elaboration code for library units.  ‘adafinal’ should
     contain the finalization code.  These subprograms should have no
     effect the second and subsequent time they are called.”

Followed.

     “Automatic elaboration of pre-elaborated packages should be
     provided when pragma ‘Export’ is supported.”

Followed when the main program is in Ada.  If the main program is in a
foreign language, then ‘adainit’ must be called to elaborate
pre-elaborated packages.

     “For each supported convention `L' other than ‘Intrinsic’, an
     implementation should support ‘Import’ and ‘Export’ pragmas for
     objects of `L'-compatible types and for subprograms, and pragma
     ‘Convention’ for `L'-eligible types and for subprograms, presuming
     the other language has corresponding features.  Pragma ‘Convention’
     need not be supported for scalar types.”

Followed.


File: gnat_rm.info,  Node: RM B 2 12-13 Package Interfaces,  Next: RM B 3 63-71 Interfacing with C,  Prev: RM B 1 39-41 Pragma Export,  Up: Implementation Advice

6.40 RM B.2(12-13): Package ‘Interfaces’
========================================

     “For each implementation-defined convention identifier, there
     should be a child package of package Interfaces with the
     corresponding name.  This package should contain any declarations
     that would be useful for interfacing to the language
     (implementation) represented by the convention.  Any declarations
     useful for interfacing to any language on the given hardware
     architecture should be provided directly in ‘Interfaces’.”

Followed.

     “An implementation supporting an interface to C, COBOL, or Fortran
     should provide the corresponding package or packages described in
     the following clauses.”

Followed.  GNAT provides all the packages described in this section.


File: gnat_rm.info,  Node: RM B 3 63-71 Interfacing with C,  Next: RM B 4 95-98 Interfacing with COBOL,  Prev: RM B 2 12-13 Package Interfaces,  Up: Implementation Advice

6.41 RM B.3(63-71): Interfacing with C
======================================

     “An implementation should support the following interface
     correspondences between Ada and C.”

Followed.

     “An Ada procedure corresponds to a void-returning C function.”

Followed.

     “An Ada function corresponds to a non-void C function.”

Followed.

     “An Ada ‘in’ scalar parameter is passed as a scalar argument to a C
     function.”

Followed.

     “An Ada ‘in’ parameter of an access-to-object type with designated
     type ‘T’ is passed as a ‘t*’ argument to a C function, where ‘t’ is
     the C type corresponding to the Ada type ‘T’.”

Followed.

     “An Ada access ‘T’ parameter, or an Ada ‘out’ or ‘in out’ parameter
     of an elementary type ‘T’, is passed as a ‘t*’ argument to a C
     function, where ‘t’ is the C type corresponding to the Ada type
     ‘T’.  In the case of an elementary ‘out’ or ‘in out’ parameter, a
     pointer to a temporary copy is used to preserve by-copy semantics.”

Followed.

     “An Ada parameter of a record type ‘T’, of any mode, is passed as a
     ‘t*’ argument to a C function, where ‘t’ is the C structure
     corresponding to the Ada type ‘T’.”

Followed.  This convention may be overridden by the use of the
C_Pass_By_Copy pragma, or Convention, or by explicitly specifying the
mechanism for a given call using an extended import or export pragma.

     “An Ada parameter of an array type with component type ‘T’, of any
     mode, is passed as a ‘t*’ argument to a C function, where ‘t’ is
     the C type corresponding to the Ada type ‘T’.”

Followed.

     “An Ada parameter of an access-to-subprogram type is passed as a
     pointer to a C function whose prototype corresponds to the
     designated subprogram’s specification.”

Followed.


File: gnat_rm.info,  Node: RM B 4 95-98 Interfacing with COBOL,  Next: RM B 5 22-26 Interfacing with Fortran,  Prev: RM B 3 63-71 Interfacing with C,  Up: Implementation Advice

6.42 RM B.4(95-98): Interfacing with COBOL
==========================================

     “An Ada implementation should support the following interface
     correspondences between Ada and COBOL.”

Followed.

     “An Ada access ‘T’ parameter is passed as a ‘BY REFERENCE’ data
     item of the COBOL type corresponding to ‘T’.”

Followed.

     “An Ada in scalar parameter is passed as a ‘BY CONTENT’ data item
     of the corresponding COBOL type.”

Followed.

     “Any other Ada parameter is passed as a ‘BY REFERENCE’ data item of
     the COBOL type corresponding to the Ada parameter type; for
     scalars, a local copy is used if necessary to ensure by-copy
     semantics.”

Followed.


File: gnat_rm.info,  Node: RM B 5 22-26 Interfacing with Fortran,  Next: RM C 1 3-5 Access to Machine Operations,  Prev: RM B 4 95-98 Interfacing with COBOL,  Up: Implementation Advice

6.43 RM B.5(22-26): Interfacing with Fortran
============================================

     “An Ada implementation should support the following interface
     correspondences between Ada and Fortran:”

Followed.

     “An Ada procedure corresponds to a Fortran subroutine.”

Followed.

     “An Ada function corresponds to a Fortran function.”

Followed.

     “An Ada parameter of an elementary, array, or record type ‘T’ is
     passed as a ‘T’ argument to a Fortran procedure, where ‘T’ is the
     Fortran type corresponding to the Ada type ‘T’, and where the
     INTENT attribute of the corresponding dummy argument matches the
     Ada formal parameter mode; the Fortran implementation’s parameter
     passing conventions are used.  For elementary types, a local copy
     is used if necessary to ensure by-copy semantics.”

Followed.

     “An Ada parameter of an access-to-subprogram type is passed as a
     reference to a Fortran procedure whose interface corresponds to the
     designated subprogram’s specification.”

Followed.


File: gnat_rm.info,  Node: RM C 1 3-5 Access to Machine Operations,  Next: RM C 1 10-16 Access to Machine Operations,  Prev: RM B 5 22-26 Interfacing with Fortran,  Up: Implementation Advice

6.44 RM C.1(3-5): Access to Machine Operations
==============================================

     “The machine code or intrinsic support should allow access to all
     operations normally available to assembly language programmers for
     the target environment, including privileged instructions, if any.”

Followed.

     “The interfacing pragmas (see Annex B) should support interface to
     assembler; the default assembler should be associated with the
     convention identifier ‘Assembler’.”

Followed.

     “If an entity is exported to assembly language, then the
     implementation should allocate it at an addressable location, and
     should ensure that it is retained by the linking process, even if
     not otherwise referenced from the Ada code.  The implementation
     should assume that any call to a machine code or assembler
     subprogram is allowed to read or update every object that is
     specified as exported.”

Followed.


File: gnat_rm.info,  Node: RM C 1 10-16 Access to Machine Operations,  Next: RM C 3 28 Interrupt Support,  Prev: RM C 1 3-5 Access to Machine Operations,  Up: Implementation Advice

6.45 RM C.1(10-16): Access to Machine Operations
================================================

     “The implementation should ensure that little or no overhead is
     associated with calling intrinsic and machine-code subprograms.”

Followed for both intrinsics and machine-code subprograms.

     “It is recommended that intrinsic subprograms be provided for
     convenient access to any machine operations that provide special
     capabilities or efficiency and that are not otherwise available
     through the language constructs.”

Followed.  A full set of machine operation intrinsic subprograms is
provided.

     “Atomic read-modify-write operations—e.g., test and set, compare
     and swap, decrement and test, enqueue/dequeue.”

Followed on any target supporting such operations.

     “Standard numeric functions—e.g.:, sin, log.”

Followed on any target supporting such operations.

     “String manipulation operations—e.g.:, translate and test.”

Followed on any target supporting such operations.

     “Vector operations—e.g.:, compare vector against thresholds.”

Followed on any target supporting such operations.

     “Direct operations on I/O ports.”

Followed on any target supporting such operations.


File: gnat_rm.info,  Node: RM C 3 28 Interrupt Support,  Next: RM C 3 1 20-21 Protected Procedure Handlers,  Prev: RM C 1 10-16 Access to Machine Operations,  Up: Implementation Advice

6.46 RM C.3(28): Interrupt Support
==================================

     “If the ‘Ceiling_Locking’ policy is not in effect, the
     implementation should provide means for the application to specify
     which interrupts are to be blocked during protected actions, if the
     underlying system allows for a finer-grain control of interrupt
     blocking.”

Followed.  The underlying system does not allow for finer-grain control
of interrupt blocking.


File: gnat_rm.info,  Node: RM C 3 1 20-21 Protected Procedure Handlers,  Next: RM C 3 2 25 Package Interrupts,  Prev: RM C 3 28 Interrupt Support,  Up: Implementation Advice

6.47 RM C.3.1(20-21): Protected Procedure Handlers
==================================================

     “Whenever possible, the implementation should allow interrupt
     handlers to be called directly by the hardware.”

Followed on any target where the underlying operating system permits
such direct calls.

     “Whenever practical, violations of any implementation-defined
     restrictions should be detected before run time.”

Followed.  Compile time warnings are given when possible.


File: gnat_rm.info,  Node: RM C 3 2 25 Package Interrupts,  Next: RM C 4 14 Pre-elaboration Requirements,  Prev: RM C 3 1 20-21 Protected Procedure Handlers,  Up: Implementation Advice

6.48 RM C.3.2(25): Package ‘Interrupts’
=======================================

     “If implementation-defined forms of interrupt handler procedures
     are supported, such as protected procedures with parameters, then
     for each such form of a handler, a type analogous to
     ‘Parameterless_Handler’ should be specified in a child package of
     ‘Interrupts’, with the same operations as in the predefined package
     Interrupts.”

Followed.


File: gnat_rm.info,  Node: RM C 4 14 Pre-elaboration Requirements,  Next: RM C 5 8 Pragma Discard_Names,  Prev: RM C 3 2 25 Package Interrupts,  Up: Implementation Advice

6.49 RM C.4(14): Pre-elaboration Requirements
=============================================

     “It is recommended that pre-elaborated packages be implemented in
     such a way that there should be little or no code executed at run
     time for the elaboration of entities not already covered by the
     Implementation Requirements.”

Followed.  Executable code is generated in some cases, e.g., loops to
initialize large arrays.


File: gnat_rm.info,  Node: RM C 5 8 Pragma Discard_Names,  Next: RM C 7 2 30 The Package Task_Attributes,  Prev: RM C 4 14 Pre-elaboration Requirements,  Up: Implementation Advice

6.50 RM C.5(8): Pragma ‘Discard_Names’
======================================

     “If the pragma applies to an entity, then the implementation should
     reduce the amount of storage used for storing names associated with
     that entity.”

Followed.


File: gnat_rm.info,  Node: RM C 7 2 30 The Package Task_Attributes,  Next: RM D 3 17 Locking Policies,  Prev: RM C 5 8 Pragma Discard_Names,  Up: Implementation Advice

6.51 RM C.7.2(30): The Package Task_Attributes
==============================================

     “Some implementations are targeted to domains in which memory use
     at run time must be completely deterministic.  For such
     implementations, it is recommended that the storage for task
     attributes will be pre-allocated statically and not from the heap.
     This can be accomplished by either placing restrictions on the
     number and the size of the task’s attributes, or by using the
     pre-allocated storage for the first ‘N’ attribute objects, and the
     heap for the others.  In the latter case, ‘N’ should be
     documented.”

Not followed.  This implementation is not targeted to such a domain.


File: gnat_rm.info,  Node: RM D 3 17 Locking Policies,  Next: RM D 4 16 Entry Queuing Policies,  Prev: RM C 7 2 30 The Package Task_Attributes,  Up: Implementation Advice

6.52 RM D.3(17): Locking Policies
=================================

     “The implementation should use names that end with ‘_Locking’ for
     locking policies defined by the implementation.”

Followed.  Two implementation-defined locking policies are defined,
whose names (‘Inheritance_Locking’ and ‘Concurrent_Readers_Locking’)
follow this suggestion.


File: gnat_rm.info,  Node: RM D 4 16 Entry Queuing Policies,  Next: RM D 6 9-10 Preemptive Abort,  Prev: RM D 3 17 Locking Policies,  Up: Implementation Advice

6.53 RM D.4(16): Entry Queuing Policies
=======================================

     “Names that end with ‘_Queuing’ should be used for all
     implementation-defined queuing policies.”

Followed.  No such implementation-defined queuing policies exist.


File: gnat_rm.info,  Node: RM D 6 9-10 Preemptive Abort,  Next: RM D 7 21 Tasking Restrictions,  Prev: RM D 4 16 Entry Queuing Policies,  Up: Implementation Advice

6.54 RM D.6(9-10): Preemptive Abort
===================================

     “Even though the `abort_statement' is included in the list of
     potentially blocking operations (see 9.5.1), it is recommended that
     this statement be implemented in a way that never requires the task
     executing the `abort_statement' to block.”

Followed.

     “On a multi-processor, the delay associated with aborting a task on
     another processor should be bounded; the implementation should use
     periodic polling, if necessary, to achieve this.”

Followed.


File: gnat_rm.info,  Node: RM D 7 21 Tasking Restrictions,  Next: RM D 8 47-49 Monotonic Time,  Prev: RM D 6 9-10 Preemptive Abort,  Up: Implementation Advice

6.55 RM D.7(21): Tasking Restrictions
=====================================

     “When feasible, the implementation should take advantage of the
     specified restrictions to produce a more efficient implementation.”

GNAT currently takes advantage of these restrictions by providing an
optimized run time when the Ravenscar profile and the GNAT restricted
run time set of restrictions are specified.  See pragma ‘Profile
(Ravenscar)’ and pragma ‘Profile (Restricted)’ for more details.


File: gnat_rm.info,  Node: RM D 8 47-49 Monotonic Time,  Next: RM E 5 28-29 Partition Communication Subsystem,  Prev: RM D 7 21 Tasking Restrictions,  Up: Implementation Advice

6.56 RM D.8(47-49): Monotonic Time
==================================

     “When appropriate, implementations should provide configuration
     mechanisms to change the value of ‘Tick’.”

Such configuration mechanisms are not appropriate to this implementation
and are thus not supported.

     “It is recommended that ‘Calendar.Clock’ and ‘Real_Time.Clock’ be
     implemented as transformations of the same time base.”

Followed.

     “It is recommended that the best time base which exists in the
     underlying system be available to the application through ‘Clock’.
     ‘Best’ may mean highest accuracy or largest range.”

Followed.


File: gnat_rm.info,  Node: RM E 5 28-29 Partition Communication Subsystem,  Next: RM F 7 COBOL Support,  Prev: RM D 8 47-49 Monotonic Time,  Up: Implementation Advice

6.57 RM E.5(28-29): Partition Communication Subsystem
=====================================================

     “Whenever possible, the PCS on the called partition should allow
     for multiple tasks to call the RPC-receiver with different messages
     and should allow them to block until the corresponding subprogram
     body returns.”

Followed by GLADE, a separately supplied PCS that can be used with GNAT.

     “The ‘Write’ operation on a stream of type ‘Params_Stream_Type’
     should raise ‘Storage_Error’ if it runs out of space trying to
     write the ‘Item’ into the stream.”

Followed by GLADE, a separately supplied PCS that can be used with GNAT.


File: gnat_rm.info,  Node: RM F 7 COBOL Support,  Next: RM F 1 2 Decimal Radix Support,  Prev: RM E 5 28-29 Partition Communication Subsystem,  Up: Implementation Advice

6.58 RM F(7): COBOL Support
===========================

     “If COBOL (respectively, C) is widely supported in the target
     environment, implementations supporting the Information Systems
     Annex should provide the child package ‘Interfaces.COBOL’
     (respectively, ‘Interfaces.C’) specified in Annex B and should
     support a ‘convention_identifier’ of COBOL (respectively, C) in the
     interfacing pragmas (see Annex B), thus allowing Ada programs to
     interface with programs written in that language.”

Followed.


File: gnat_rm.info,  Node: RM F 1 2 Decimal Radix Support,  Next: RM G Numerics,  Prev: RM F 7 COBOL Support,  Up: Implementation Advice

6.59 RM F.1(2): Decimal Radix Support
=====================================

     “Packed decimal should be used as the internal representation for
     objects of subtype ‘S’ when ‘S’’Machine_Radix = 10.”

Not followed.  GNAT ignores ‘S’’Machine_Radix and always uses binary
representations.


File: gnat_rm.info,  Node: RM G Numerics,  Next: RM G 1 1 56-58 Complex Types,  Prev: RM F 1 2 Decimal Radix Support,  Up: Implementation Advice

6.60 RM G: Numerics
===================

     “If Fortran (respectively, C) is widely supported in the target
     environment, implementations supporting the Numerics Annex should
     provide the child package ‘Interfaces.Fortran’ (respectively,
     ‘Interfaces.C’) specified in Annex B and should support a
     ‘convention_identifier’ of Fortran (respectively, C) in the
     interfacing pragmas (see Annex B), thus allowing Ada programs to
     interface with programs written in that language.”

Followed.


File: gnat_rm.info,  Node: RM G 1 1 56-58 Complex Types,  Next: RM G 1 2 49 Complex Elementary Functions,  Prev: RM G Numerics,  Up: Implementation Advice

6.61 RM G.1.1(56-58): Complex Types
===================================

     “Because the usual mathematical meaning of multiplication of a
     complex operand and a real operand is that of the scaling of both
     components of the former by the latter, an implementation should
     not perform this operation by first promoting the real operand to
     complex type and then performing a full complex multiplication.  In
     systems that, in the future, support an Ada binding to IEC
     559:1989, the latter technique will not generate the required
     result when one of the components of the complex operand is
     infinite.  (Explicit multiplication of the infinite component by
     the zero component obtained during promotion yields a NaN that
     propagates into the final result.)  Analogous advice applies in the
     case of multiplication of a complex operand and a pure-imaginary
     operand, and in the case of division of a complex operand by a real
     or pure-imaginary operand.”

Not followed.

     “Similarly, because the usual mathematical meaning of addition of a
     complex operand and a real operand is that the imaginary operand
     remains unchanged, an implementation should not perform this
     operation by first promoting the real operand to complex type and
     then performing a full complex addition.  In implementations in
     which the ‘Signed_Zeros’ attribute of the component type is ‘True’
     (and which therefore conform to IEC 559:1989 in regard to the
     handling of the sign of zero in predefined arithmetic operations),
     the latter technique will not generate the required result when the
     imaginary component of the complex operand is a negatively signed
     zero.  (Explicit addition of the negative zero to the zero obtained
     during promotion yields a positive zero.)  Analogous advice applies
     in the case of addition of a complex operand and a pure-imaginary
     operand, and in the case of subtraction of a complex operand and a
     real or pure-imaginary operand.”

Not followed.

     “Implementations in which ‘Real'Signed_Zeros’ is ‘True’ should
     attempt to provide a rational treatment of the signs of zero
     results and result components.  As one example, the result of the
     ‘Argument’ function should have the sign of the imaginary component
     of the parameter ‘X’ when the point represented by that parameter
     lies on the positive real axis; as another, the sign of the
     imaginary component of the ‘Compose_From_Polar’ function should be
     the same as (respectively, the opposite of) that of the ‘Argument’
     parameter when that parameter has a value of zero and the ‘Modulus’
     parameter has a nonnegative (respectively, negative) value.”

Followed.


File: gnat_rm.info,  Node: RM G 1 2 49 Complex Elementary Functions,  Next: RM G 2 4 19 Accuracy Requirements,  Prev: RM G 1 1 56-58 Complex Types,  Up: Implementation Advice

6.62 RM G.1.2(49): Complex Elementary Functions
===============================================

     “Implementations in which ‘Complex_Types.Real'Signed_Zeros’ is
     ‘True’ should attempt to provide a rational treatment of the signs
     of zero results and result components.  For example, many of the
     complex elementary functions have components that are odd functions
     of one of the parameter components; in these cases, the result
     component should have the sign of the parameter component at the
     origin.  Other complex elementary functions have zero components
     whose sign is opposite that of a parameter component at the origin,
     or is always positive or always negative.”

Followed.


File: gnat_rm.info,  Node: RM G 2 4 19 Accuracy Requirements,  Next: RM G 2 6 15 Complex Arithmetic Accuracy,  Prev: RM G 1 2 49 Complex Elementary Functions,  Up: Implementation Advice

6.63 RM G.2.4(19): Accuracy Requirements
========================================

     “The versions of the forward trigonometric functions without a
     ‘Cycle’ parameter should not be implemented by calling the
     corresponding version with a ‘Cycle’ parameter of
     ‘2.0*Numerics.Pi’, since this will not provide the required
     accuracy in some portions of the domain.  For the same reason, the
     version of ‘Log’ without a ‘Base’ parameter should not be
     implemented by calling the corresponding version with a ‘Base’
     parameter of ‘Numerics.e’.”

Followed.


File: gnat_rm.info,  Node: RM G 2 6 15 Complex Arithmetic Accuracy,  Next: RM H 6 15/2 Pragma Partition_Elaboration_Policy,  Prev: RM G 2 4 19 Accuracy Requirements,  Up: Implementation Advice

6.64 RM G.2.6(15): Complex Arithmetic Accuracy
==============================================

     “The version of the ‘Compose_From_Polar’ function without a ‘Cycle’
     parameter should not be implemented by calling the corresponding
     version with a ‘Cycle’ parameter of ‘2.0*Numerics.Pi’, since this
     will not provide the required accuracy in some portions of the
     domain.”

Followed.


File: gnat_rm.info,  Node: RM H 6 15/2 Pragma Partition_Elaboration_Policy,  Prev: RM G 2 6 15 Complex Arithmetic Accuracy,  Up: Implementation Advice

6.65 RM H.6(15/2): Pragma Partition_Elaboration_Policy
======================================================

     “If the partition elaboration policy is ‘Sequential’ and the
     Environment task becomes permanently blocked during elaboration
     then the partition is deadlocked and it is recommended that the
     partition be immediately terminated.”

Not followed.


File: gnat_rm.info,  Node: Implementation Defined Characteristics,  Next: Intrinsic Subprograms,  Prev: Implementation Advice,  Up: Top

7 Implementation Defined Characteristics
****************************************

In addition to the implementation dependent pragmas and attributes, and
the implementation advice, there are a number of other Ada features that
are potentially implementation dependent and are designated as
implementation-defined.  These are mentioned throughout the Ada
Reference Manual, and are summarized in Annex M.

A requirement for conforming Ada compilers is that they provide
documentation describing how the implementation deals with each of these
issues.  In this chapter you will find each point in Annex M listed,
followed by a description of how GNAT handles the implementation
dependence.

You can use this chapter as a guide to minimizing implementation
dependent features in your programs if portability to other compilers
and other operating systems is an important consideration.  The numbers
in each entry below correspond to the paragraph numbers in the Ada
Reference Manual.

   * “Whether or not each recommendation given in Implementation Advice
     is followed.  See 1.1.2(37).”

See *note Implementation Advice: a.

   * “Capacity limitations of the implementation.  See 1.1.3(3).”

The complexity of programs that can be processed is limited only by the
total amount of available virtual memory, and disk space for the
generated object files.

   * “Variations from the standard that are impractical to avoid given
     the implementation’s execution environment.  See 1.1.3(6).”

There are no variations from the standard.

   * “Which code_statements cause external interactions.  See
     1.1.3(10).”

Any `code_statement' can potentially cause external interactions.

   * “The coded representation for the text of an Ada program.  See
     2.1(4).”

See separate section on source representation.

   * 
     “The semantics of an Ada program whose text is not in

          Normalization Form C. See 2.1(4).”

See separate section on source representation.

   * “The representation for an end of line.  See 2.2(2).”

See separate section on source representation.

   * “Maximum supported line length and lexical element length.  See
     2.2(15).”

The maximum line length is 255 characters and the maximum length of a
lexical element is also 255 characters.  This is the default setting if
not overridden by the use of compiler switch `-gnaty' (which sets the
maximum to 79) or `-gnatyMnn' which allows the maximum line length to be
specified to be any value up to 32767.  The maximum length of a lexical
element is the same as the maximum line length.

   * “Implementation defined pragmas.  See 2.8(14).”

See *note Implementation Defined Pragmas: 7.

   * “Effect of pragma ‘Optimize’.  See 2.8(27).”

Pragma ‘Optimize’, if given with a ‘Time’ or ‘Space’ parameter, checks
that the optimization flag is set, and aborts if it is not.

   * “The message string associated with the Assertion_Error exception
     raised by the failure of a predicate check if there is no
     applicable Predicate_Failure aspect.  See 3.2.4(31).”

In the case of a Dynamic_Predicate aspect, the string is
“Dynamic_Predicate failed at <source position>”, where “<source
position>” might be something like “foo.adb:123”.  The Static_Predicate
case is handled analogously.

   * “The predefined integer types declared in ‘Standard’.  See
     3.5.4(25).”

Type                          Representation
                              
--------------------------------------------------------------------------
                              
`Short_Short_Integer'         8-bit signed
                              
                              
`Short_Integer'               16-bit signed
                              
                              
`Integer'                     32-bit signed
                              
                              
`Long_Integer'                64-bit signed (on most 64-bit targets,
                              depending on the C definition of long)
                              32-bit signed (on all other targets)
                              
                              
`Long_Long_Integer'           64-bit signed
                              
                              
`Long_Long_Long_Integer'      128-bit signed (on 64-bit targets) 64-bit
                              signed (on 32-bit targets)
                              

   * “Any nonstandard integer types and the operators defined for them.
     See 3.5.4(26).”

There are no nonstandard integer types.

   * “Any nonstandard real types and the operators defined for them.
     See 3.5.6(8).”

There are no nonstandard real types.

   * “What combinations of requested decimal precision and range are
     supported for floating point types.  See 3.5.7(7).”

The precision and range are defined by the IEEE Standard for
Floating-Point Arithmetic (IEEE 754-2019).

   * “The predefined floating point types declared in ‘Standard’.  See
     3.5.7(16).”

Type                       Representation
                           
-------------------------------------------------------------------------------
                           
`Short_Float'              IEEE Binary32 (Single)
                           
                           
`Float'                    IEEE Binary32 (Single)
                           
                           
`Long_Float'               IEEE Binary64 (Double)
                           
                           
`Long_Long_Float'          IEEE Binary64 (Double) on non-x86 architectures
                           IEEE 80-bit Extended on x86 architecture
                           

The default rounding mode specified by the IEEE 754 Standard is assumed
both for static and dynamic computations (that is, round to nearest,
ties to even).  The input routines yield correctly rounded values for
Short_Float, Float, and Long_Float at least.  The output routines can
compute up to twice as many exact digits as the value of ‘T'Digits’ for
any type, for example 30 digits for Long_Float; if more digits are
requested, zeros are printed.

   * “The small of an ordinary fixed point type.  See 3.5.9(8).”

The small is the largest power of two that does not exceed the delta.

   * “What combinations of small, range, and digits are supported for
     fixed point types.  See 3.5.9(10).”

For an ordinary fixed point type, on 32-bit platforms, the small must
lie in 2.0**(-80) ..  2.0**80 and the range in -9.0E+36 ..  9.0E+36; any
combination is permitted that does not result in a mantissa larger than
63 bits.

On 64-bit platforms, the small must lie in 2.0**(-127) ..  2.0**127 and
the range in -1.0E+76 ..  1.0E+76; any combination is permitted that
does not result in a mantissa larger than 63 bits, and any combination
is permitted that results in a mantissa between 64 and 127 bits if the
small is the ratio of two integers that lie in 1 ..  2.0**127.

If the small is the ratio of two integers with 64-bit magnitude on
32-bit platforms and 128-bit magnitude on 64-bit platforms, which is the
case if no ‘small’ clause is provided, then the operations of the fixed
point type are entirely implemented by means of integer instructions.
In the other cases, some operations, in particular input and output, may
be implemented by means of floating-point instructions and may be
affected by accuracy issues on architectures other than x86.

For a decimal fixed point type, on 32-bit platforms, the small must lie
in 1.0E-18 ..  1.0E+18 and the digits in 1 ..  18.  On 64-bit platforms,
the small must lie in 1.0E-38 ..  1.0E+38 and the digits in 1 ..  38.

   * “The result of ‘Tags.Expanded_Name’ for types declared within an
     unnamed `block_statement'.  See 3.9(10).”

Block numbers of the form ‘B`nnn'’, where `nnn' is a decimal integer are
allocated.

   * “The sequence of characters of the value returned by
     Tags.Expanded_Name (respectively, Tags.Wide_Expanded_Name) when
     some of the graphic characters of Tags.Wide_Wide_Expanded_Name are
     not defined in Character (respectively, Wide_Character).  See
     3.9(10.1).”

This is handled in the same way as the implementation-defined behavior
referenced in A.4.12(34).

   * “Implementation-defined attributes.  See 4.1.4(12).”

See *note Implementation Defined Attributes: 8.

   * “The value of the parameter to Empty for some container aggregates.
     See 4.3.5(40).”

As per the suggestion given in the Annotated Ada RM, the default value
of the formal parameter is used if one exists and zero is used
otherwise.

   * “The maximum number of chunks for a parallel reduction expression
     without a chunk_specification.  See 4.5.10(21).”

Feature unimplemented.

   * “Rounding of real static expressions which are exactly half-way
     between two machine numbers.  See 4.9(38).”

Round to even is used in all such cases.

   * 
     “The maximum number of chunks for a parallel generalized iterator without

          a chunk_specification.  See 5.5.2(10).”

Feature unimplemented.

   * “The number of chunks for an array component iterator.  See
     5.5.2(11).”

Feature unimplemented.

   * “Any extensions of the Global aspect.  See 6.1.2(43).”

Feature unimplemented.

   * “The circumstances the implementation passes in the null value for
     a view conversion of an access type used as an out parameter.  See
     6.4.1(19).”

Difficult to characterize.

   * “Any extensions of the Default_Initial_Condition aspect.  See
     7.3.3(11).”

SPARK allows specifying `null' as the Default_Initial_Condition aspect
of a type.  See the SPARK reference manual for further details.

   * “Any implementation-defined time types.  See 9.6(6).”

There are no implementation-defined time types.

   * “The time base associated with relative delays.  See 9.6(20).”

See 9.6(20).  The time base used is that provided by the C library
function ‘gettimeofday’.

   * “The time base of the type ‘Calendar.Time’.  See 9.6(23).”

The time base used is that provided by the C library function
‘gettimeofday’.

   * “The time zone used for package ‘Calendar’ operations.  See
     9.6(24).”

The time zone used by package ‘Calendar’ is the current system time zone
setting for local time, as accessed by the C library function
‘localtime’.

   * “Any limit on `delay_until_statements' of `select_statements'.  See
     9.6(29).”

There are no such limits.

   * 
     “The result of Calendar.Formatting.Image if its argument represents more

          than 100 hours.  See 9.6.1(86).”

Calendar.Time_Error is raised.

   * “Implementation-defined conflict check policies.  See 9.10.1(5).”

There are no implementation-defined conflict check policies.

   * “The representation for a compilation.  See 10.1(2).”

A compilation is represented by a sequence of files presented to the
compiler in a single invocation of the `gcc' command.

   * “Any restrictions on compilations that contain multiple
     compilation_units.  See 10.1(4).”

No single file can contain more than one compilation unit, but any
sequence of files can be presented to the compiler as a single
compilation.

   * “The mechanisms for creating an environment and for adding and
     replacing compilation units.  See 10.1.4(3).”

See separate section on compilation model.

   * “The manner of explicitly assigning library units to a partition.
     See 10.2(2).”

If a unit contains an Ada main program, then the Ada units for the
partition are determined by recursive application of the rules in the
Ada Reference Manual section 10.2(2-6).  In other words, the Ada units
will be those that are needed by the main program, and then this
definition of need is applied recursively to those units, and the
partition contains the transitive closure determined by this
relationship.  In short, all the necessary units are included, with no
need to explicitly specify the list.  If additional units are required,
e.g., by foreign language units, then all units must be mentioned in the
context clause of one of the needed Ada units.

If the partition contains no main program, or if the main program is in
a language other than Ada, then GNAT provides the binder options `-z'
and `-n' respectively, and in this case a list of units can be
explicitly supplied to the binder for inclusion in the partition (all
units needed by these units will also be included automatically).  For
full details on the use of these options, refer to `GNAT Make Program
gnatmake' in the ‘GNAT User’s Guide’.

   * “The implementation-defined means, if any, of specifying which
     compilation units are needed by a given compilation unit.  See
     10.2(2).”

The units needed by a given compilation unit are as defined in the Ada
Reference Manual section 10.2(2-6).  There are no implementation-defined
pragmas or other implementation-defined means for specifying needed
units.

   * “The manner of designating the main subprogram of a partition.  See
     10.2(7).”

The main program is designated by providing the name of the
corresponding ‘ALI’ file as the input parameter to the binder.

   * “The order of elaboration of `library_items'.  See 10.2(18).”

The first constraint on ordering is that it meets the requirements of
Chapter 10 of the Ada Reference Manual.  This still leaves some
implementation-dependent choices, which are resolved by analyzing the
elaboration code of each unit and identifying implicit elaboration-order
dependencies.

   * “Parameter passing and function return for the main subprogram.
     See 10.2(21).”

The main program has no parameters.  It may be a procedure, or a
function returning an integer type.  In the latter case, the returned
integer value is the return code of the program (overriding any value
that may have been set by a call to ‘Ada.Command_Line.Set_Exit_Status’).

   * “The mechanisms for building and running partitions.  See
     10.2(24).”

GNAT itself supports programs with only a single partition.  The
GNATDIST tool provided with the GLADE package (which also includes an
implementation of the PCS) provides a completely flexible method for
building and running programs consisting of multiple partitions.  See
the separate GLADE manual for details.

   * “The details of program execution, including program termination.
     See 10.2(25).”

See separate section on compilation model.

   * “The semantics of any non-active partitions supported by the
     implementation.  See 10.2(28).”

Passive partitions are supported on targets where shared memory is
provided by the operating system.  See the GLADE reference manual for
further details.

   * “The information returned by ‘Exception_Message’.  See 11.4.1(10).”

Exception message returns the null string unless a specific message has
been passed by the program.

   * “The result of ‘Exceptions.Exception_Name’ for types declared
     within an unnamed `block_statement'.  See 11.4.1(12).”

Blocks have implementation defined names of the form ‘B`nnn'’ where
`nnn' is an integer.

   * “The information returned by ‘Exception_Information’.  See
     11.4.1(13).”

‘Exception_Information’ returns a string in the following format:

     *Exception_Name:* nnnnn
     *Message:* mmmmm
     *PID:* ppp
     *Load address:* 0xhhhh
     *Call stack traceback locations:*
     0xhhhh 0xhhhh 0xhhhh ... 0xhhh

where

        * ‘nnnn’ is the fully qualified name of the exception in all
          upper case letters.  This line is always present.

        * ‘mmmm’ is the message (this line present only if message is
          non-null)

        * ‘ppp’ is the Process Id value as a decimal integer (this line
          is present only if the Process Id is nonzero).  Currently we
          are not making use of this field.

        * The Load address line, the Call stack traceback locations line
          and the following values are present only if at least one
          traceback location was recorded.  The Load address indicates
          the address at which the main executable was loaded; this line
          may not be present if operating system hasn’t relocated the
          main executable.  The values are given in C style format, with
          lower case letters for a-f, and only as many digits present as
          are necessary.  The line terminator sequence at the end of
          each line, including the last line is a single ‘LF’ character
          (‘16#0A#’).

   * “The sequence of characters of the value returned by
     Exceptions.Exception_Name (respectively,
     Exceptions.Wide_Exception_Name) when some of the graphic characters
     of Exceptions.Wide_Wide_Exception_Name are not defined in Character
     (respectively, Wide_Character).  See 11.4.1(12.1).”

This is handled in the same way as the implementation-defined behavior
referenced in A.4.12(34).

   * “The information returned by Exception_Information.  See
     11.4.1(13).”

The exception name and the source location at which the exception was
raised are included.

   * “Implementation-defined policy_identifiers and
     assertion_aspect_marks allowed in a pragma Assertion_Policy.  See
     11.4.2(9).”

Implementation-defined assertion_aspect_marks include Assert_And_Cut,
Assume, Contract_Cases, Debug, Ghost, Initial_Condition, Loop_Invariant,
Loop_Variant, Postcondition, Precondition, Predicate, Refined_Post,
Statement_Assertions, and Subprogram_Variant.  Implementation-defined
policy_identifiers include Ignore and Suppressible.

   * “The default assertion policy.  See 11.4.2(10).”

The default assertion policy is Ignore, although this can be overridden
via compiler switches such as “-gnata”.

   * “Implementation-defined check names.  See 11.5(27).”

The implementation defined check names include Alignment_Check,
Atomic_Synchronization, Duplicated_Tag_Check, Container_Checks,
Tampering_Check, Predicate_Check, and Validity_Check.  In addition, a
user program can add implementation-defined check names by means of the
pragma Check_Name.  See the description of pragma ‘Suppress’ for full
details.

   * “Existence and meaning of second parameter of pragma Unsuppress.
     See 11.5(27.1).”

The legality rules for and semantics of the second parameter of pragma
Unsuppress match those for the second argument of pragma Suppress.

   * 
     “The cases that cause conflicts between the representation of the

          ancestors of a type_declaration.  See 13.1(13.1).”

No such cases exist.

   * “The interpretation of each representation aspect.  See 13.1(20).”

See separate section on data representations.

   * “Any restrictions placed upon the specification of representation
     aspects.  See 13.1(20).”

See separate section on data representations.

   * “Implementation-defined aspects, including the syntax for
     specifying such aspects and the legality rules for such aspects.
     See 13.1.1(38).”

See *note Implementation Defined Aspects: 11f.

   * “The set of machine scalars.  See 13.3(8.1).”

See separate section on data representations.

   * “The meaning of ‘Size’ for indefinite subtypes.  See 13.3(48).”

The Size attribute of an indefinite subtype is not less than the Size
attribute of any object of that type.

   * “The meaning of Object_Size for indefinite subtypes.  See
     13.3(58).”

The Object_Size attribute of an indefinite subtype is not less than the
Object_Size attribute of any object of that type.

   * “The default external representation for a type tag.  See
     13.3(75).”

The default external representation for a type tag is the fully expanded
name of the type in upper case letters.

   * “What determines whether a compilation unit is the same in two
     different partitions.  See 13.3(76).”

A compilation unit is the same in two different partitions if and only
if it derives from the same source file.

   * “Implementation-defined components.  See 13.5.1(15).”

The only implementation defined component is the tag for a tagged type,
which contains a pointer to the dispatching table.

   * “If ‘Word_Size’ = ‘Storage_Unit’, the default bit ordering.  See
     13.5.3(5).”

‘Word_Size’ (32) is not the same as ‘Storage_Unit’ (8) for this
implementation, so no non-default bit ordering is supported.  The
default bit ordering corresponds to the natural endianness of the target
architecture.

   * “The contents of the visible part of package ‘System’.  See
     13.7(2).”

See the definition of package System in ‘system.ads’.  Note that two
declarations are added to package System.

     Max_Priority           : constant Positive := Priority'Last;
     Max_Interrupt_Priority : constant Positive := Interrupt_Priority'Last;

   * “The range of Storage_Elements.Storage_Offset, the modulus of
     Storage_Elements.Storage_Element, and the declaration of
     Storage_Elements.Integer_Address.  See 13.7.1(11).”

See the definition of package System.Storage_Elements in ‘s-stoele.ads’.

   * “The contents of the visible part of package ‘System.Machine_Code’,
     and the meaning of `code_statements'.  See 13.8(7).”

See the definition and documentation in file ‘s-maccod.ads’.

   * “The result of unchecked conversion for instances with scalar
     result types whose result is not defined by the language.  See
     13.9(11).”

Unchecked conversion between types of the same size results in an
uninterpreted transmission of the bits from one type to the other.  If
the types are of unequal sizes, then in the case of discrete types, a
shorter source is first zero or sign extended as necessary, and a
shorter target is simply truncated on the left.  For all non-discrete
types, the source is first copied if necessary to ensure that the
alignment requirements of the target are met, then a pointer is
constructed to the source value, and the result is obtained by
dereferencing this pointer after converting it to be a pointer to the
target type.  Unchecked conversions where the target subtype is an
unconstrained array are not permitted.  If the target alignment is
greater than the source alignment, then a copy of the result is made
with appropriate alignment

   * “The result of unchecked conversion for instances with nonscalar
     result types whose result is not defined by the language.  See
     13.9(11).”

See preceding definition for the scalar result case.

   * “Whether or not the implementation provides user-accessible names
     for the standard pool type(s).  See 13.11(17).”

There are 3 different standard pools used by the compiler when
‘Storage_Pool’ is not specified depending whether the type is local to a
subprogram or defined at the library level and whether ‘Storage_Size``is
specified or not. See documentation in the runtime library units
``System.Pool_Global’, ‘System.Pool_Size’ and ‘System.Pool_Local’ in
files ‘s-poosiz.ads’, ‘s-pooglo.ads’ and ‘s-pooloc.ads’ for full details
on the default pools used.  All these pools are accessible by means of
‘with’ing these units.

   * “The meaning of ‘Storage_Size’ when neither the Storage_Size nor
     the Storage_Pool is specified for an access type.  See 13.11(18).”

‘Storage_Size’ is measured in storage units, and refers to the total
space available for an access type collection, or to the primary stack
space for a task.

   * “The effect of specifying aspect Default_Storage_Pool on an
     instance of a language-defined generic unit.  See 13.11.3(5).”

Instances of language-defined generic units are treated the same as
other instances with respect to the Default_Storage_Pool aspect.

   * “Implementation-defined restrictions allowed in a pragma
     ‘Restrictions’.  See 13.12(8.7).”

See *note Standard and Implementation Defined Restrictions: 9.

   * “The consequences of violating limitations on ‘Restrictions’
     pragmas.  See 13.12(9).”

Restrictions that can be checked at compile time are enforced at compile
time; violations are illegal.  For other restrictions, any violation
during program execution results in erroneous execution.

   * “Implementation-defined usage profiles allowed in a pragma Profile.
     See 13.12(15).”

See *note Implementation Defined Pragmas: 7.

   * “The contents of the stream elements read and written by the Read
     and Write attributes of elementary types.  See 13.13.2(9).”

The representation is the in-memory representation of the base type of
the type, using the number of bits corresponding to the ‘type'Size’
value, and the natural ordering of the machine.

   * “The names and characteristics of the numeric subtypes declared in
     the visible part of package ‘Standard’.  See A.1(3).”

See items describing the integer and floating-point types supported.

   * “The values returned by Strings.Hash.  See A.4.9(3).”

This hash function has predictable collisions and is subject to
equivalent substring attacks.  It is not suitable for construction of a
hash table keyed on possibly malicious user input.

   * “The value returned by a call to a Text_Buffer Get procedure if any
     character in the returned sequence is not defined in Character.
     See A.4.12(34).”

The contents of a buffer is represented internally as a UTF_8 string.
The value return by Text_Buffer.Get is the result of passing that UTF_8
string to UTF_Encoding.Strings.Decode.

   * “The value returned by a call to a Text_Buffer Wide_Get procedure
     if any character in the returned sequence is not defined in
     Wide_Character.  See A.4.12(34).”

The contents of a buffer is represented internally as a UTF_8 string.
The value return by Text_Buffer.Wide_Get is the result of passing that
UTF_8 string to UTF_Encoding.Wide_Strings.Decode.

   * “The accuracy actually achieved by the elementary functions.  See
     A.5.1(1).”

The elementary functions correspond to the functions available in the C
library.  Only fast math mode is implemented.

   * “The sign of a zero result from some of the operators or functions
     in ‘Numerics.Generic_Elementary_Functions’, when
     ‘Float_Type'Signed_Zeros’ is ‘True’.  See A.5.1(46).”

The sign of zeroes follows the requirements of the IEEE 754 standard on
floating-point.

   * “The value of ‘Numerics.Float_Random.Max_Image_Width’.  See
     A.5.2(27).”

Maximum image width is 6864, see library file ‘s-rannum.ads’.

   * “The value of ‘Numerics.Discrete_Random.Max_Image_Width’.  See
     A.5.2(27).”

Maximum image width is 6864, see library file ‘s-rannum.ads’.

   * “The string representation of a random number generator’s state.
     See A.5.2(38).”

The value returned by the Image function is the concatenation of the
fixed-width decimal representations of the 624 32-bit integers of the
state vector.

   * “The values of the ‘Model_Mantissa’, ‘Model_Emin’, ‘Model_Epsilon’,
     ‘Model’, ‘Safe_First’, and ‘Safe_Last’ attributes, if the Numerics
     Annex is not supported.  See A.5.3(72).”

Running the compiler with `-gnatS' to produce a listing of package
‘Standard’ displays the values of these attributes.

   * “The value of ‘Buffer_Size’ in ‘Storage_IO’.  See A.9(10).”

All type representations are contiguous, and the ‘Buffer_Size’ is the
value of ‘type'Size’ rounded up to the next storage unit boundary.

   * “External files for standard input, standard output, and standard
     error See A.10(5).”

These files are mapped onto the files provided by the C streams
libraries.  See source file ‘i-cstrea.ads’ for further details.

   * “The accuracy of the value produced by ‘Put’.  See A.10.9(36).”

If more digits are requested in the output than are represented by the
precision of the value, zeroes are output in the corresponding least
significant digit positions.

   * “Current size for a stream file for which positioning is not
     supported.  See A.12.1(1.1).”

Positioning is supported.

   * “The meaning of ‘Argument_Count’, ‘Argument’, and ‘Command_Name’.
     See A.15(1).”

These are mapped onto the ‘argv’ and ‘argc’ parameters of the main
program in the natural manner.

   * “The interpretation of file names and directory names.  See
     A.16(46).”

These names are interpreted consistently with the underlying file
system.

   * “The maxium value for a file size in Directories.  See A.16(87).”

Directories.File_Size’Last is equal to Long_Long_Integer’Last .

   * 
     “The result for Directories.Size for a directory or special file.

          See A.16(93).”

Name_Error is raised.

   * 
     “The result for Directories.Modification_Time for a directory or special file.

          See A.16(93).”

Name_Error is raised.

   * 
     “The interpretation of a nonnull search pattern in Directories.

          See A.16(104).”

When the ‘Pattern’ parameter is not the null string, it is interpreted
according to the syntax of regular expressions as defined in the
‘GNAT.Regexp’ package.

See *note GNAT.Regexp (g-regexp.ads): 25b.

   * 
     “The results of a Directories search if the contents of the directory are

          altered while a search is in progress.  See A.16(110).”

The effect of a call to Get_Next_Entry is determined by the current
state of the directory.

   * “The definition and meaning of an environment variable.  See
     A.17(1).”

This definition is determined by the underlying operating system.

   * “The circumstances where an environment variable cannot be defined.
     See A.17(16).”

     There are no such implementation-defined circumstances.

   * “Environment names for which Set has the effect of Clear.  See
     A.17(17).”

There are no such names.

   * “The value of Containers.Hash_Type’Modulus.  The value of
     Containers.Count_Type’Last.  See A.18.1(7).”

Containers.Hash_Type’Modulus is 2**32.  Containers.Count_Type’Last is
2**31 - 1.

   * “Implementation-defined convention names.  See B.1(11).”

The following convention names are supported

Convention Name             Interpretation
                            
---------------------------------------------------------------------------------------------------------------
                            
`Ada'                       Ada
                            
                            
`Ada_Pass_By_Copy'          Allowed for any types except by-reference types such as limited records.
                            Compatible with convention Ada, but causes any parameters with this convention
                            to be passed by copy.
                            
                            
`Ada_Pass_By_Reference'     Allowed for any types except by-copy types such as scalars.  Compatible with
                            convention Ada, but causes any parameters with this convention to be passed by
                            reference.
                            
                            
`Assembler'                 Assembly language
                            
                            
`Asm'                       Synonym for Assembler
                            
                            
`Assembly'                  Synonym for Assembler
                            
                            
`C'                         C
                            
                            
`C_Pass_By_Copy'            Allowed only for record types, like C, but also notes that record is to be
                            passed by copy rather than reference.
                            
                            
`COBOL'                     COBOL
                            
                            
`C_Plus_Plus (or CPP)'      C++
                            
                            
`Default'                   Treated the same as C
                            
                            
`External'                  Treated the same as C
                            
                            
`Fortran'                   Fortran
                            
                            
`Intrinsic'                 For support of pragma ‘Import’ with convention Intrinsic, see separate section
                            on Intrinsic Subprograms.
                            
                            
`Stdcall'                   Stdcall (used for Windows implementations only).  This convention correspond to
                            the WINAPI (previously called Pascal convention) C/C++ convention under Windows.
                            A routine with this convention cleans the stack before exit.  This pragma cannot
                            be applied to a dispatching call.
                            
                            
`DLL'                       Synonym for Stdcall
                            
                            
`Win32'                     Synonym for Stdcall
                            
                            
`Stubbed'                   Stubbed is a special convention used to indicate that the body of the subprogram
                            will be entirely ignored.  Any call to the subprogram is converted into a raise
                            of the ‘Program_Error’ exception.  If a pragma ‘Import’ specifies convention
                            ‘stubbed’ then no body need be present at all.  This convention is useful during
                            development for the inclusion of subprograms whose body has not yet been
                            written.  In addition, all otherwise unrecognized convention names are also
                            treated as being synonymous with convention C. In all implementations, use of
                            such other names results in a warning.
                            

   * “The meaning of link names.  See B.1(36).”

Link names are the actual names used by the linker.

   * “The manner of choosing link names when neither the link name nor
     the address of an imported or exported entity is specified.  See
     B.1(36).”

The default linker name is that which would be assigned by the relevant
external language, interpreting the Ada name as being in all lower case
letters.

   * “The effect of pragma ‘Linker_Options’.  See B.1(37).”

The string passed to ‘Linker_Options’ is presented uninterpreted as an
argument to the link command, unless it contains ASCII.NUL characters.
NUL characters if they appear act as argument separators, so for example

     pragma Linker_Options ("-labc" & ASCII.NUL & "-ldef");

causes two separate arguments ‘-labc’ and ‘-ldef’ to be passed to the
linker.  The order of linker options is preserved for a given unit.  The
final list of options passed to the linker is in reverse order of the
elaboration order.  For example, linker options for a body always appear
before the options from the corresponding package spec.

   * “The contents of the visible part of package ‘Interfaces’ and its
     language-defined descendants.  See B.2(1).”

See files with prefix ‘i-’ in the distributed library.

   * “Implementation-defined children of package ‘Interfaces’.  The
     contents of the visible part of package ‘Interfaces’.  See
     B.2(11).”

See files with prefix ‘i-’ in the distributed library.

   * “The definitions of certain types and constants in Interfaces.C.
     See B.3(41).”

See source file ‘i-c.ads’.

   * “The types ‘Floating’, ‘Long_Floating’, ‘Binary’, ‘Long_Binary’,
     ‘Decimal_ Element’, and ‘COBOL_Character’; and the initialization
     of the variables ‘Ada_To_COBOL’ and ‘COBOL_To_Ada’, in
     ‘Interfaces.COBOL’.  See B.4(50).”

COBOL                     Ada
                          
-------------------------------------------------------------------
                          
`Floating'                Float
                          
                          
`Long_Floating'           (Floating) Long_Float
                          
                          
`Binary'                  Integer
                          
                          
`Long_Binary'             Long_Long_Integer
                          
                          
`Decimal_Element'         Character
                          
                          
`COBOL_Character'         Character
                          

For initialization, see the file ‘i-cobol.ads’ in the distributed
library.

   * “The types Fortran_Integer, Real, Double_Precision, and
     Character_Set in Interfaces.Fortran.  See B.5(17).”

See source file ‘i-fortra.ads’.  These types are derived, respectively,
from Integer, Float, Long_Float, and Character.

   * “Implementation-defined intrinsic subprograms.  See C.1(1).”

See separate section on Intrinsic Subprograms.

   * “Any restrictions on a protected procedure or its containing type
     when an aspect Attach_handler or Interrupt_Handler is specified.
     See C.3.1(17).”

There are no such restrictions.

   * “Any other forms of interrupt handler supported by the
     Attach_Handler and Interrupt_Handler aspects.  See C.3.1(19).”

There are no such forms.

   * 
     “The semantics of some attributes and functions of an entity for which

          aspect Discard_Names is True.  See C.5(7).”

If Discard_Names is True for an enumeration type, the Image attribute
provides the image of the Pos of the literal, and Value accepts Pos
values.

If both of the aspects‘‘Discard_Names‘‘ and ‘No_Tagged_Streams’ are true
for a tagged type, its Expanded_Name and External_Tag values are empty
strings.  This is useful to avoid exposing entity names at binary level.

   * “The modulus and size of Test_and_Set_Flag.  See C.6.3(8).”

The modulus is 2**8.  The size is 8.

   * “The value used to represent the set value for Atomic_Test_and_Set.
     See C.6.3(10).”

The value is 1.

   * “The result of the ‘Task_Identification.Image’ attribute.  See
     C.7.1(7).”

The result of this attribute is a string that identifies the object or
component that denotes a given task.  If a variable ‘Var’ has a task
type, the image for this task will have the form ‘Var_`XXXXXXXX'’, where
the suffix `XXXXXXXX' is the hexadecimal representation of the virtual
address of the corresponding task control block.  If the variable is an
array of tasks, the image of each task will have the form of an indexed
component indicating the position of a given task in the array, e.g.,
‘Group(5)_`XXXXXXX'’.  If the task is a component of a record, the image
of the task will have the form of a selected component.  These rules are
fully recursive, so that the image of a task that is a subcomponent of a
composite object corresponds to the expression that designates this
task.

If a task is created by an allocator, its image depends on the context.
If the allocator is part of an object declaration, the rules described
above are used to construct its image, and this image is not affected by
subsequent assignments.  If the allocator appears within an expression,
the image includes only the name of the task type.

If the configuration pragma Discard_Names is present, or if the
restriction No_Implicit_Heap_Allocation is in effect, the image reduces
to the numeric suffix, that is to say the hexadecimal representation of
the virtual address of the control block of the task.

   * “The value of ‘Current_Task’ when in a protected entry or interrupt
     handler.  See C.7.1(17).”

Protected entries or interrupt handlers can be executed by any
convenient thread, so the value of ‘Current_Task’ is undefined.

   * “Granularity of locking for Task_Attributes.  See C.7.2(16).”

No locking is needed if the formal type Attribute has the size and
alignment of either Integer or System.Address and the bit representation
of Initial_Value is all zeroes.  Otherwise, locking is performed.

   * “The declarations of ‘Any_Priority’ and ‘Priority’.  See D.1(11).”

See declarations in file ‘system.ads’.

   * “Implementation-defined execution resources.  See D.1(15).”

There are no implementation-defined execution resources.

   * “Whether, on a multiprocessor, a task that is waiting for access to
     a protected object keeps its processor busy.  See D.2.1(3).”

On a multi-processor, a task that is waiting for access to a protected
object does not keep its processor busy.

   * “The affect of implementation defined execution resources on task
     dispatching.  See D.2.1(9).”

Tasks map to threads in the threads package used by GNAT. Where possible
and appropriate, these threads correspond to native threads of the
underlying operating system.

   * “Implementation-defined task dispatching policies.  See D.2.2(3).”

There are no implementation-defined task dispatching policies.

   * “The value of Default_Quantum in Dispatching.Round_Robin.  See
     D.2.5(4).”

The value is 10 milliseconds.

   * “Implementation-defined `policy_identifiers' allowed in a pragma
     ‘Locking_Policy’.  See D.3(4).”

The two implementation defined policies permitted in GNAT are
‘Inheritance_Locking’ and ‘Concurrent_Readers_Locking’.  On targets that
support the ‘Inheritance_Locking’ policy, locking is implemented by
inheritance, i.e., the task owning the lock operates at a priority equal
to the highest priority of any task currently requesting the lock.  On
targets that support the ‘Concurrent_Readers_Locking’ policy, locking is
implemented with a read/write lock allowing multiple protected object
functions to enter concurrently.

   * “Default ceiling priorities.  See D.3(10).”

The ceiling priority of protected objects of the type
‘System.Interrupt_Priority'Last’ as described in the Ada Reference
Manual D.3(10),

   * “The ceiling of any protected object used internally by the
     implementation.  See D.3(16).”

The ceiling priority of internal protected objects is
‘System.Priority'Last’.

   * “Implementation-defined queuing policies.  See D.4(1).”

There are no implementation-defined queuing policies.

   * “Implementation-defined admission policies.  See D.4.1(1).”

There are no implementation-defined admission policies.

   * “Any operations that implicitly require heap storage allocation.
     See D.7(8).”

The only operation that implicitly requires heap storage allocation is
task creation.

   * “When restriction No_Dynamic_CPU_Assignment applies to a partition,
     the processor on which a task with a CPU value of a
     Not_A_Specific_CPU will execute.  See D.7(10).”

Unknown.

   * 
     “When restriction No_Task_Termination applies to a partition, what happens

          when a task terminates.  See D.7(15.1).”

Execution is erroneous in that case.

   * 
     “The behavior when restriction Max_Storage_At_Blocking is violated.

          See D.7(17).”

Execution is erroneous in that case.

   * “The behavior when restriction Max_Asynchronous_Select_Nesting is
     violated.  See D.7(18).”

Execution is erroneous in that case.

   * “The behavior when restriction Max_Tasks is violated.  See
     D.7(19).”

Execution is erroneous in that case.

   * 
     “Whether the use of pragma Restrictions results in a reduction in program

          code or data size or execution time.  See D.7(20).”

          Yes it can, but the precise circumstances and properties of
          such reductions are difficult to characterize.

   * “The value of Barrier_Limit’Last in Synchronous_Barriers.  See
     D.10.1(4).”

Synchronous_Barriers.Barrier_Limit’Last is Integer’Last .

   * “When an aborted task that is waiting on a Synchronous_Barrier is
     aborted.  See D.10.1(13).”

Difficult to characterize.

   * 
     “The value of Min_Handler_Ceiling in Execution_Time.Group_Budgets.

          See D.14.2(7).”

See source file ‘a-etgrbu.ads’.

   * “The value of CPU_Range’Last in System.Multiprocessors.  See
     D.16(4).”

See source file ‘s-multip.ads’.

   * “The processor on which the environment task executes in the
     absence of a value for the aspect CPU. See D.16(13).”

Unknown.

   * “The means for creating and executing distributed programs.  See
     E(5).”

The GLADE package provides a utility GNATDIST for creating and executing
distributed programs.  See the GLADE reference manual for further
details.

   * “Any events that can result in a partition becoming inaccessible.
     See E.1(7).”

See the GLADE reference manual for full details on such events.

   * “The scheduling policies, treatment of priorities, and management
     of shared resources between partitions in certain cases.  See
     E.1(11).”

See the GLADE reference manual for full details on these aspects of
multi-partition execution.

   * “Whether the execution of the remote subprogram is immediately
     aborted as a result of cancellation.  See E.4(13).”

See the GLADE reference manual for details on the effect of abort in a
distributed application.

   * “The range of type System.RPC.Partition_Id.  See E.5(14).”

System.RPC.Partion_ID’Last is Integer’Last.  See source file
‘s-rpc.ads’.

   * “Implementation-defined interfaces in the PCS. See E.5(26).”

See the GLADE reference manual for a full description of all
implementation defined interfaces.

   * “The values of named numbers in the package ‘Decimal’.  See
     F.2(7).”

Named Number             Value
                         
----------------------------------------
                         
`Max_Scale'              +18
                         
                         
`Min_Scale'              -18
                         
                         
`Min_Delta'              1.0E-18
                         
                         
`Max_Delta'              1.0E+18
                         
                         
`Max_Decimal_Digits'     18
                         

   * “The value of ‘Max_Picture_Length’ in the package
     ‘Text_IO.Editing’.  See F.3.3(16).”

64

   * “The value of ‘Max_Picture_Length’ in the package
     ‘Wide_Text_IO.Editing’.  See F.3.4(5).”

64

   * “The accuracy actually achieved by the complex elementary functions
     and by other complex arithmetic operations.  See G.1(1).”

Standard library functions are used for the complex arithmetic
operations.  Only fast math mode is currently supported.

   * “The sign of a zero result (or a component thereof) from any
     operator or function in ‘Numerics.Generic_Complex_Types’, when
     ‘Real'Signed_Zeros’ is True.  See G.1.1(53).”

The signs of zero values are as recommended by the relevant
implementation advice.

   * “The sign of a zero result (or a component thereof) from any
     operator or function in
     ‘Numerics.Generic_Complex_Elementary_Functions’, when
     ‘Real'Signed_Zeros’ is ‘True’.  See G.1.2(45).”

The signs of zero values are as recommended by the relevant
implementation advice.

   * “Whether the strict mode or the relaxed mode is the default.  See
     G.2(2).”

The strict mode is the default.  There is no separate relaxed mode.
GNAT provides a highly efficient implementation of strict mode.

   * “The result interval in certain cases of fixed-to-float conversion.
     See G.2.1(10).”

For cases where the result interval is implementation dependent, the
accuracy is that provided by performing all operations in 64-bit IEEE
floating-point format.

   * “The result of a floating point arithmetic operation in overflow
     situations, when the ‘Machine_Overflows’ attribute of the result
     type is ‘False’.  See G.2.1(13).”

Infinite and NaN values are produced as dictated by the IEEE
floating-point standard.  Note that on machines that are not fully
compliant with the IEEE floating-point standard, such as Alpha, the
`-mieee' compiler flag must be used for achieving IEEE conforming
behavior (although at the cost of a significant performance penalty), so
infinite and NaN values are properly generated.

   * “The result interval for division (or exponentiation by a negative
     exponent), when the floating point hardware implements division as
     multiplication by a reciprocal.  See G.2.1(16).”

Not relevant, division is IEEE exact.

   * “The definition of close result set, which determines the accuracy
     of certain fixed point multiplications and divisions.  See
     G.2.3(5).”

Operations in the close result set are performed using IEEE long format
floating-point arithmetic.  The input operands are converted to
floating-point, the operation is done in floating-point, and the result
is converted to the target type.

   * “Conditions on a `universal_real' operand of a fixed point
     multiplication or division for which the result shall be in the
     perfect result set.  See G.2.3(22).”

The result is only defined to be in the perfect result set if the result
can be computed by a single scaling operation involving a scale factor
representable in 64 bits.

   * “The result of a fixed point arithmetic operation in overflow
     situations, when the ‘Machine_Overflows’ attribute of the result
     type is ‘False’.  See G.2.3(27).”

Not relevant, ‘Machine_Overflows’ is ‘True’ for fixed-point types.

   * “The result of an elementary function reference in overflow
     situations, when the ‘Machine_Overflows’ attribute of the result
     type is ‘False’.  See G.2.4(4).”

IEEE infinite and Nan values are produced as appropriate.

   * “The value of the angle threshold, within which certain elementary
     functions, complex arithmetic operations, and complex elementary
     functions yield results conforming to a maximum relative error
     bound.  See G.2.4(10).”

Information on this subject is not yet available.

   * “The accuracy of certain elementary functions for parameters beyond
     the angle threshold.  See G.2.4(10).”

Information on this subject is not yet available.

   * “The result of a complex arithmetic operation or complex elementary
     function reference in overflow situations, when the
     ‘Machine_Overflows’ attribute of the corresponding real type is
     ‘False’.  See G.2.6(5).”

IEEE infinite and Nan values are produced as appropriate.

   * “The accuracy of certain complex arithmetic operations and certain
     complex elementary functions for parameters (or components thereof)
     beyond the angle threshold.  See G.2.6(8).”

Information on those subjects is not yet available.

   * 
     “The accuracy requirements for the subprograms Solve, Inverse,

          Determinant, Eigenvalues and Eigensystem for type Real_Matrix.
          See G.3.1(81).”

Information on those subjects is not yet available.

   * 
     “The accuracy requirements for the subprograms Solve, Inverse,

          Determinant, Eigenvalues and Eigensystem for type
          Complex_Matrix.  See G.3.2(149).”

Information on those subjects is not yet available.

   * “The consequences of violating No_Hidden_Indirect_Globals.  See
     H.4(23.9).”

Execution is erroneous in that case.


File: gnat_rm.info,  Node: Intrinsic Subprograms,  Next: Representation Clauses and Pragmas,  Prev: Implementation Defined Characteristics,  Up: Top

8 Intrinsic Subprograms
***********************

GNAT allows a user application program to write the declaration:

     pragma Import (Intrinsic, name);

providing that the name corresponds to one of the implemented intrinsic
subprograms in GNAT, and that the parameter profile of the referenced
subprogram meets the requirements.  This chapter describes the set of
implemented intrinsic subprograms, and the requirements on parameter
profiles.  Note that no body is supplied; as with other uses of pragma
Import, the body is supplied elsewhere (in this case by the compiler
itself).  Note that any use of this feature is potentially non-portable,
since the Ada standard does not require Ada compilers to implement this
feature.

* Menu:

* Intrinsic Operators::
* Compilation_ISO_Date::
* Compilation_Date::
* Compilation_Time::
* Enclosing_Entity::
* Exception_Information::
* Exception_Message::
* Exception_Name::
* File::
* Line::
* Shifts and Rotates::
* Source_Location::


File: gnat_rm.info,  Node: Intrinsic Operators,  Next: Compilation_ISO_Date,  Up: Intrinsic Subprograms

8.1 Intrinsic Operators
=======================

All the predefined numeric operators in package Standard in ‘pragma
Import (Intrinsic,..)’ declarations.  In the binary operator case, the
operands must have the same size.  The operand or operands must also be
appropriate for the operator.  For example, for addition, the operands
must both be floating-point or both be fixed-point, and the right
operand for ‘"**"’ must have a root type of ‘Standard.Integer'Base’.
You can use an intrinsic operator declaration as in the following
example:

     type Int1 is new Integer;
     type Int2 is new Integer;

     function "+" (X1 : Int1; X2 : Int2) return Int1;
     function "+" (X1 : Int1; X2 : Int2) return Int2;
     pragma Import (Intrinsic, "+");

This declaration would permit ‘mixed mode’ arithmetic on items of the
differing types ‘Int1’ and ‘Int2’.  It is also possible to specify such
operators for private types, if the full views are appropriate
arithmetic types.


File: gnat_rm.info,  Node: Compilation_ISO_Date,  Next: Compilation_Date,  Prev: Intrinsic Operators,  Up: Intrinsic Subprograms

8.2 Compilation_ISO_Date
========================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.Compilation_ISO_Date’ to
obtain the date of the current compilation (in local time format
YYYY-MM-DD).


File: gnat_rm.info,  Node: Compilation_Date,  Next: Compilation_Time,  Prev: Compilation_ISO_Date,  Up: Intrinsic Subprograms

8.3 Compilation_Date
====================

Same as Compilation_ISO_Date, except the string is in the form MMM DD
YYYY.


File: gnat_rm.info,  Node: Compilation_Time,  Next: Enclosing_Entity,  Prev: Compilation_Date,  Up: Intrinsic Subprograms

8.4 Compilation_Time
====================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.Compilation_Time’ to obtain
the time of the current compilation (in local time format HH:MM:SS).


File: gnat_rm.info,  Node: Enclosing_Entity,  Next: Exception_Information,  Prev: Compilation_Time,  Up: Intrinsic Subprograms

8.5 Enclosing_Entity
====================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.Enclosing_Entity’ to obtain
the name of the current subprogram, package, task, entry, or protected
subprogram.


File: gnat_rm.info,  Node: Exception_Information,  Next: Exception_Message,  Prev: Enclosing_Entity,  Up: Intrinsic Subprograms

8.6 Exception_Information
=========================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Current_Exception’.  The only useful use of the intrinsic
import in this case is the one in this unit, so an application program
should simply call the function
‘GNAT.Current_Exception.Exception_Information’ to obtain the exception
information associated with the current exception.


File: gnat_rm.info,  Node: Exception_Message,  Next: Exception_Name,  Prev: Exception_Information,  Up: Intrinsic Subprograms

8.7 Exception_Message
=====================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Current_Exception’.  The only useful use of the intrinsic
import in this case is the one in this unit, so an application program
should simply call the function
‘GNAT.Current_Exception.Exception_Message’ to obtain the message
associated with the current exception.


File: gnat_rm.info,  Node: Exception_Name,  Next: File,  Prev: Exception_Message,  Up: Intrinsic Subprograms

8.8 Exception_Name
==================

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Current_Exception’.  The only useful use of the intrinsic
import in this case is the one in this unit, so an application program
should simply call the function ‘GNAT.Current_Exception.Exception_Name’
to obtain the name of the current exception.


File: gnat_rm.info,  Node: File,  Next: Line,  Prev: Exception_Name,  Up: Intrinsic Subprograms

8.9 File
========

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.File’ to obtain the name of
the current file.


File: gnat_rm.info,  Node: Line,  Next: Shifts and Rotates,  Prev: File,  Up: Intrinsic Subprograms

8.10 Line
=========

This intrinsic subprogram is used in the implementation of the library
package ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.Line’ to obtain the number of
the current source line.


File: gnat_rm.info,  Node: Shifts and Rotates,  Next: Source_Location,  Prev: Line,  Up: Intrinsic Subprograms

8.11 Shifts and Rotates
=======================

In standard Ada, the shift and rotate functions are available only for
the predefined modular types in package ‘Interfaces’.  However, in GNAT
it is possible to define these functions for any integer type (signed or
modular), as in this example:

     function Shift_Left
       (Value  : T;
        Amount : Natural) return T
     with Import, Convention => Intrinsic;

The function name must be one of Shift_Left, Shift_Right,
Shift_Right_Arithmetic, Rotate_Left, or Rotate_Right.  T must be an
integer type.  T’Size must be 8, 16, 32 or 64 bits; if T is modular, the
modulus must be 2**8, 2**16, 2**32 or 2**64.  The result type must be
the same as the type of ‘Value’.  The shift amount must be Natural.  The
formal parameter names can be anything.

A more convenient way of providing these shift operators is to use the
Provide_Shift_Operators pragma, which provides the function declarations
and corresponding pragma Import’s for all five shift functions.  For
signed types the semantics of these operators is to interpret the
bitwise result of the corresponding operator for modular type.  In
particular, shifting a negative number may change its sign bit to
positive.


File: gnat_rm.info,  Node: Source_Location,  Prev: Shifts and Rotates,  Up: Intrinsic Subprograms

8.12 Source_Location
====================

This intrinsic subprogram is used in the implementation of the library
routine ‘GNAT.Source_Info’.  The only useful use of the intrinsic import
in this case is the one in this unit, so an application program should
simply call the function ‘GNAT.Source_Info.Source_Location’ to obtain
the current source file location.


File: gnat_rm.info,  Node: Representation Clauses and Pragmas,  Next: Standard Library Routines,  Prev: Intrinsic Subprograms,  Up: Top

9 Representation Clauses and Pragmas
************************************

This section describes the representation clauses accepted by GNAT, and
their effect on the representation of corresponding data objects.

GNAT fully implements Annex C (Systems Programming).  This means that
all the implementation advice sections in chapter 13 are fully
implemented.  However, these sections only require a minimal level of
support for representation clauses.  GNAT provides much more extensive
capabilities, and this section describes the additional capabilities
provided.

* Menu:

* Alignment Clauses::
* Size Clauses::
* Storage_Size Clauses::
* Size of Variant Record Objects::
* Biased Representation::
* Value_Size and Object_Size Clauses::
* Component_Size Clauses::
* Bit_Order Clauses::
* Effect of Bit_Order on Byte Ordering::
* Pragma Pack for Arrays::
* Pragma Pack for Records::
* Record Representation Clauses::
* Handling of Records with Holes::
* Enumeration Clauses::
* Address Clauses::
* Use of Address Clauses for Memory-Mapped I/O::
* Effect of Convention on Representation::
* Conventions and Anonymous Access Types::
* Determining the Representations chosen by GNAT::


File: gnat_rm.info,  Node: Alignment Clauses,  Next: Size Clauses,  Up: Representation Clauses and Pragmas

9.1 Alignment Clauses
=====================

GNAT requires that all alignment clauses specify 0 or a power of 2, and
all default alignments are always a power of 2.  Specifying 0 is the
same as specifying 1.

The default alignment values are as follows:

   * `Elementary Types'.

     For elementary types, the alignment is the minimum of the actual
     size of objects of the type divided by ‘Storage_Unit’, and the
     maximum alignment supported by the target.  (This maximum alignment
     is given by the GNAT-specific attribute
     ‘Standard'Maximum_Alignment’; see *note Attribute
     Maximum_Alignment: 18c.)

     For example, for type ‘Long_Float’, the object size is 8 bytes, and
     the default alignment will be 8 on any target that supports
     alignments this large, but on some targets, the maximum alignment
     may be smaller than 8, in which case objects of type ‘Long_Float’
     will be maximally aligned.

   * `Arrays'.

     For arrays, the alignment is equal to the alignment of the
     component type for the normal case where no packing or component
     size is given.  If the array is packed, and the packing is
     effective (see separate section on packed arrays), then the
     alignment will be either 4, 2, or 1 for long packed arrays or
     arrays whose length is not known at compile time, depending on
     whether the component size is divisible by 4, 2, or is odd.  For
     short packed arrays, which are handled internally as modular types,
     the alignment will be as described for elementary types, e.g.  a
     packed array of length 31 bits will have an object size of four
     bytes, and an alignment of 4.

   * `Records'.

     For the normal unpacked case, the alignment of a record is equal to
     the maximum alignment of any of its components.  For tagged
     records, this includes the implicit access type used for the tag.
     If a pragma ‘Pack’ is used and all components are packable (see
     separate section on pragma ‘Pack’), then the resulting alignment is
     1, unless the layout of the record makes it profitable to increase
     it.

     A special case is when:

        * the size of the record is given explicitly, or a full record
          representation clause is given, and

        * the size of the record is 2, 4, or 8 bytes.

     In this case, an alignment is chosen to match the size of the
     record.  For example, if we have:

          type Small is record
             A, B : Character;
          end record;
          for Small'Size use 16;

     then the default alignment of the record type ‘Small’ is 2, not 1.
     This leads to more efficient code when the record is treated as a
     unit, and also allows the type to specified as ‘Atomic’ on
     architectures requiring strict alignment.

An alignment clause may specify a larger alignment than the default
value up to some maximum value dependent on the target (obtainable by
using the attribute reference ‘Standard'Maximum_Alignment’).  It may
also specify a smaller alignment than the default value for enumeration,
integer and fixed point types, as well as for record types, for example

     type V is record
        A : Integer;
     end record;

     for V'alignment use 1;

The default alignment for the type ‘V’ is 4, as a result of the Integer
field in the record, but it is permissible, as shown, to override the
default alignment of the record with a smaller value.

Note that according to the Ada standard, an alignment clause applies
only to the first named subtype.  If additional subtypes are declared,
then the compiler is allowed to choose any alignment it likes, and there
is no way to control this choice.  Consider:

     type R is range 1 .. 10_000;
     for R'Alignment use 1;
     subtype RS is R range 1 .. 1000;

The alignment clause specifies an alignment of 1 for the first named
subtype ‘R’ but this does not necessarily apply to ‘RS’.  When writing
portable Ada code, you should avoid writing code that explicitly or
implicitly relies on the alignment of such subtypes.

For the GNAT compiler, if an explicit alignment clause is given, this
value is also used for any subsequent subtypes.  So for GNAT, in the
above example, you can count on the alignment of ‘RS’ being 1.  But this
assumption is non-portable, and other compilers may choose different
alignments for the subtype ‘RS’.


File: gnat_rm.info,  Node: Size Clauses,  Next: Storage_Size Clauses,  Prev: Alignment Clauses,  Up: Representation Clauses and Pragmas

9.2 Size Clauses
================

The default size for a type ‘T’ is obtainable through the
language-defined attribute ‘T'Size’ and also through the equivalent
GNAT-defined attribute ‘T'Value_Size’.  For objects of type ‘T’, GNAT
will generally increase the type size so that the object size
(obtainable through the GNAT-defined attribute ‘T'Object_Size’) is a
multiple of ‘T'Alignment * Storage_Unit’.

For example:

     type Smallint is range 1 .. 6;

     type Rec is record
        Y1 : integer;
        Y2 : boolean;
     end record;

In this example, ‘Smallint'Size’ = ‘Smallint'Value_Size’ = 3, as
specified by the RM rules, but objects of this type will have a size of
8 (‘Smallint'Object_Size’ = 8), since objects by default occupy an
integral number of storage units.  On some targets, notably older
versions of the Digital Alpha, the size of stand alone objects of this
type may be 32, reflecting the inability of the hardware to do byte
load/stores.

Similarly, the size of type ‘Rec’ is 40 bits (‘Rec'Size’ =
‘Rec'Value_Size’ = 40), but the alignment is 4, so objects of this type
will have their size increased to 64 bits so that it is a multiple of
the alignment (in bits).  This decision is in accordance with the
specific Implementation Advice in RM 13.3(43):

     “A ‘Size’ clause should be supported for an object if the specified
     ‘Size’ is at least as large as its subtype’s ‘Size’, and
     corresponds to a size in storage elements that is a multiple of the
     object’s ‘Alignment’ (if the ‘Alignment’ is nonzero).”

An explicit size clause may be used to override the default size by
increasing it.  For example, if we have:

     type My_Boolean is new Boolean;
     for My_Boolean'Size use 32;

then values of this type will always be 32-bit long.  In the case of
discrete types, the size can be increased up to 64 bits on 32-bit
targets and 128 bits on 64-bit targets, with the effect that the entire
specified field is used to hold the value, sign- or zero-extended as
appropriate.  If more than 64 bits or 128 bits resp.  is specified, then
padding space is allocated after the value, and a warning is issued that
there are unused bits.

Similarly the size of records and arrays may be increased, and the
effect is to add padding bits after the value.  This also causes a
warning message to be generated.

The largest Size value permitted in GNAT is 2**31-1.  Since this is a
Size in bits, this corresponds to an object of size 256 megabytes (minus
one).  This limitation is true on all targets.  The reason for this
limitation is that it improves the quality of the code in many cases if
it is known that a Size value can be accommodated in an object of type
Integer.


File: gnat_rm.info,  Node: Storage_Size Clauses,  Next: Size of Variant Record Objects,  Prev: Size Clauses,  Up: Representation Clauses and Pragmas

9.3 Storage_Size Clauses
========================

For tasks, the ‘Storage_Size’ clause specifies the amount of space to be
allocated for the task stack.  This cannot be extended, and if the stack
is exhausted, then ‘Storage_Error’ will be raised (if stack checking is
enabled).  Use a ‘Storage_Size’ attribute definition clause, or a
‘Storage_Size’ pragma in the task definition to set the appropriate
required size.  A useful technique is to include in every task
definition a pragma of the form:

     pragma Storage_Size (Default_Stack_Size);

Then ‘Default_Stack_Size’ can be defined in a global package, and
modified as required.  Any tasks requiring stack sizes different from
the default can have an appropriate alternative reference in the pragma.

You can also use the `-d' binder switch to modify the default stack
size.

For access types, the ‘Storage_Size’ clause specifies the maximum space
available for allocation of objects of the type.  If this space is
exceeded then ‘Storage_Error’ will be raised by an allocation attempt.
In the case where the access type is declared local to a subprogram, the
use of a ‘Storage_Size’ clause triggers automatic use of a special
predefined storage pool (‘System.Pool_Size’) that ensures that all space
for the pool is automatically reclaimed on exit from the scope in which
the type is declared.

A special case recognized by the compiler is the specification of a
‘Storage_Size’ of zero for an access type.  This means that no items can
be allocated from the pool, and this is recognized at compile time, and
all the overhead normally associated with maintaining a fixed size
storage pool is eliminated.  Consider the following example:

     procedure p is
        type R is array (Natural) of Character;
        type P is access all R;
        for P'Storage_Size use 0;
        --  Above access type intended only for interfacing purposes

        y : P;

        procedure g (m : P);
        pragma Import (C, g);

        --  ...

     begin
        --  ...
        y := new R;
     end;

As indicated in this example, these dummy storage pools are often useful
in connection with interfacing where no object will ever be allocated.
If you compile the above example, you get the warning:

     p.adb:16:09: warning: allocation from empty storage pool
     p.adb:16:09: warning: Storage_Error will be raised at run time

Of course in practice, there will not be any explicit allocators in the
case of such an access declaration.


File: gnat_rm.info,  Node: Size of Variant Record Objects,  Next: Biased Representation,  Prev: Storage_Size Clauses,  Up: Representation Clauses and Pragmas

9.4 Size of Variant Record Objects
==================================

In the case of variant record objects, there is a question whether Size
gives information about a particular variant, or the maximum size
required for any variant.  Consider the following program

     with Text_IO; use Text_IO;
     procedure q is
        type R1 (A : Boolean := False) is record
          case A is
            when True  => X : Character;
            when False => null;
          end case;
        end record;

        V1 : R1 (False);
        V2 : R1;

     begin
        Put_Line (Integer'Image (V1'Size));
        Put_Line (Integer'Image (V2'Size));
     end q;

Here we are dealing with a variant record, where the True variant
requires 16 bits, and the False variant requires 8 bits.  In the above
example, both V1 and V2 contain the False variant, which is only 8 bits
long.  However, the result of running the program is:

     8
     16

The reason for the difference here is that the discriminant value of V1
is fixed, and will always be False.  It is not possible to assign a True
variant value to V1, therefore 8 bits is sufficient.  On the other hand,
in the case of V2, the initial discriminant value is False (from the
default), but it is possible to assign a True variant value to V2,
therefore 16 bits must be allocated for V2 in the general case, even
fewer bits may be needed at any particular point during the program
execution.

As can be seen from the output of this program, the ‘'Size’ attribute
applied to such an object in GNAT gives the actual allocated size of the
variable, which is the largest size of any of the variants.  The Ada
Reference Manual is not completely clear on what choice should be made
here, but the GNAT behavior seems most consistent with the language in
the RM.

In some cases, it may be desirable to obtain the size of the current
variant, rather than the size of the largest variant.  This can be
achieved in GNAT by making use of the fact that in the case of a
subprogram parameter, GNAT does indeed return the size of the current
variant (because a subprogram has no way of knowing how much space is
actually allocated for the actual).

Consider the following modified version of the above program:

     with Text_IO; use Text_IO;
     procedure q is
        type R1 (A : Boolean := False) is record
          case A is
            when True  => X : Character;
            when False => null;
          end case;
        end record;

        V2 : R1;

        function Size (V : R1) return Integer is
        begin
           return V'Size;
        end Size;

     begin
        Put_Line (Integer'Image (V2'Size));
        Put_Line (Integer'Image (Size (V2)));
        V2 := (True, 'x');
        Put_Line (Integer'Image (V2'Size));
        Put_Line (Integer'Image (Size (V2)));
     end q;

The output from this program is

     16
     8
     16
     16

Here we see that while the ‘'Size’ attribute always returns the maximum
size, regardless of the current variant value, the ‘Size’ function does
indeed return the size of the current variant value.


File: gnat_rm.info,  Node: Biased Representation,  Next: Value_Size and Object_Size Clauses,  Prev: Size of Variant Record Objects,  Up: Representation Clauses and Pragmas

9.5 Biased Representation
=========================

In the case of scalars with a range starting at other than zero, it is
possible in some cases to specify a size smaller than the default
minimum value, and in such cases, GNAT uses an unsigned biased
representation, in which zero is used to represent the lower bound, and
successive values represent successive values of the type.

For example, suppose we have the declaration:

     type Small is range -7 .. -4;
     for Small'Size use 2;

Although the default size of type ‘Small’ is 4, the ‘Size’ clause is
accepted by GNAT and results in the following representation scheme:

     -7 is represented as 2#00#
     -6 is represented as 2#01#
     -5 is represented as 2#10#
     -4 is represented as 2#11#

Biased representation is only used if the specified ‘Size’ clause cannot
be accepted in any other manner.  These reduced sizes that force biased
representation can be used for all discrete types except for enumeration
types for which a representation clause is given.


File: gnat_rm.info,  Node: Value_Size and Object_Size Clauses,  Next: Component_Size Clauses,  Prev: Biased Representation,  Up: Representation Clauses and Pragmas

9.6 Value_Size and Object_Size Clauses
======================================

In Ada 95 and Ada 2005, ‘T'Size’ for a type ‘T’ is the minimum number of
bits required to hold values of type ‘T’.  Although this interpretation
was allowed in Ada 83, it was not required, and this requirement in
practice can cause some significant difficulties.  For example, in most
Ada 83 compilers, ‘Natural'Size’ was 32.  However, in Ada 95 and Ada
2005, ‘Natural'Size’ is typically 31.  This means that code may change
in behavior when moving from Ada 83 to Ada 95 or Ada 2005.  For example,
consider:

     type Rec is record;
        A : Natural;
        B : Natural;
     end record;

     for Rec use record
        at 0  range 0 .. Natural'Size - 1;
        at 0  range Natural'Size .. 2 * Natural'Size - 1;
     end record;

In the above code, since the typical size of ‘Natural’ objects is 32
bits and ‘Natural'Size’ is 31, the above code can cause unexpected
inefficient packing in Ada 95 and Ada 2005, and in general there are
cases where the fact that the object size can exceed the size of the
type causes surprises.

To help get around this problem GNAT provides two implementation defined
attributes, ‘Value_Size’ and ‘Object_Size’.  When applied to a type,
these attributes yield the size of the type (corresponding to the RM
defined size attribute), and the size of objects of the type
respectively.

The ‘Object_Size’ is used for determining the default size of objects
and components.  This size value can be referred to using the
‘Object_Size’ attribute.  The phrase ‘is used’ here means that it is the
basis of the determination of the size.  The backend is free to pad this
up if necessary for efficiency, e.g., an 8-bit stand-alone character
might be stored in 32 bits on a machine with no efficient byte access
instructions such as the Alpha.

The default rules for the value of ‘Object_Size’ for discrete types are
as follows:

   * The ‘Object_Size’ for base subtypes reflect the natural hardware
     size in bits (run the compiler with `-gnatS' to find those values
     for numeric types).  Enumeration types and fixed-point base
     subtypes have 8, 16, 32, or 64 bits for this size, depending on the
     range of values to be stored.

   * The ‘Object_Size’ of a subtype is the same as the ‘Object_Size’ of
     the type from which it is obtained.

   * The ‘Object_Size’ of a derived base type is copied from the parent
     base type, and the ‘Object_Size’ of a derived first subtype is
     copied from the parent first subtype.

The ‘Value_Size’ attribute is the (minimum) number of bits required to
store a value of the type.  This value is used to determine how tightly
to pack records or arrays with components of this type, and also affects
the semantics of unchecked conversion (unchecked conversions where the
‘Value_Size’ values differ generate a warning, and are potentially
target dependent).

The default rules for the value of ‘Value_Size’ are as follows:

   * The ‘Value_Size’ for a base subtype is the minimum number of bits
     required to store all values of the type (including the sign bit
     only if negative values are possible).

   * If a subtype statically matches the first subtype of a given type,
     then it has by default the same ‘Value_Size’ as the first subtype.
     This is a consequence of RM 13.1(14): “if two subtypes statically
     match, then their subtype-specific aspects are the same”.)

   * All other subtypes have a ‘Value_Size’ corresponding to the minimum
     number of bits required to store all values of the subtype.  For
     dynamic bounds, it is assumed that the value can range down or up
     to the corresponding bound of the ancestor

The RM defined attribute ‘Size’ corresponds to the ‘Value_Size’
attribute.

The ‘Size’ attribute may be defined for a first-named subtype.  This
sets the ‘Value_Size’ of the first-named subtype to the given value, and
the ‘Object_Size’ of this first-named subtype to the given value padded
up to an appropriate boundary.  It is a consequence of the default rules
above that this ‘Object_Size’ will apply to all further subtypes.  On
the other hand, ‘Value_Size’ is affected only for the first subtype, any
dynamic subtypes obtained from it directly, and any statically matching
subtypes.  The ‘Value_Size’ of any other static subtypes is not
affected.

‘Value_Size’ and ‘Object_Size’ may be explicitly set for any subtype
using an attribute definition clause.  Note that the use of these
attributes can cause the RM 13.1(14) rule to be violated.  If two access
types reference aliased objects whose subtypes have differing
‘Object_Size’ values as a result of explicit attribute definition
clauses, then it is illegal to convert from one access subtype to the
other.  For a more complete description of this additional legality
rule, see the description of the ‘Object_Size’ attribute.

To get a feel for the difference, consider the following examples (note
that in each case the base is ‘Short_Short_Integer’ with a size of 8):

Type or subtype declaration                       Object_Size       Value_Size
                                                                    
--------------------------------------------------------------------------------------
                                                                    
‘type x1 is range 0 .. 5;’                        8                 3
                                                                    
                                                                    
‘type x2 is range 0 .. 5;’ ‘for x2'size use       16                12
12;’                                                                

‘subtype x3 is x2 range 0 .. 3;’                  16                2
                                                                    
                                                                    
‘subtype x4 is x2'base range 0 .. 10;’            8                 4
                                                                    
                                                                    
‘dynamic : x2'Base range -64 .. +63;’

‘subtype x5 is x2 range 0 .. dynamic;’            16                3*
                                                                    
                                                                    
‘subtype x6 is x2'base range 0 .. dynamic;’       8                 7*
                                                                    

Note: the entries marked ‘*’ are not actually specified by the Ada
Reference Manual, which has nothing to say about size in the dynamic
case.  What GNAT does is to allocate sufficient bits to accommodate any
possible dynamic values for the bounds at run-time.

So far, so good, but GNAT has to obey the RM rules, so the question is
under what conditions must the RM ‘Size’ be used.  The following is a
list of the occasions on which the RM ‘Size’ must be used:

   * Component size for packed arrays or records

   * Value of the attribute ‘Size’ for a type

   * Warning about sizes not matching for unchecked conversion

For record types, the ‘Object_Size’ is always a multiple of the
alignment of the type (this is true for all types).  In some cases the
‘Value_Size’ can be smaller.  Consider:

     type R is record
       X : Integer;
       Y : Character;
     end record;

On a typical 32-bit architecture, the X component will occupy four bytes
and the Y component will occupy one byte, for a total of 5 bytes.  As a
result ‘R'Value_Size’ will be 40 (bits) since this is the minimum size
required to store a value of this type.  For example, it is permissible
to have a component of type R in an array whose component size is
specified to be 40 bits.

However, ‘R'Object_Size’ will be 64 (bits).  The difference is due to
the alignment requirement for objects of the record type.  The X
component will require four-byte alignment because that is what type
Integer requires, whereas the Y component, a Character, will only
require 1-byte alignment.  Since the alignment required for X is the
greatest of all the components’ alignments, that is the alignment
required for the enclosing record type, i.e., 4 bytes or 32 bits.  As
indicated above, the actual object size must be rounded up so that it is
a multiple of the alignment value.  Therefore, 40 bits rounded up to the
next multiple of 32 yields 64 bits.

For all other types, the ‘Object_Size’ and ‘Value_Size’ are the same
(and equivalent to the RM attribute ‘Size’).  Only ‘Size’ may be
specified for such types.

Note that ‘Value_Size’ can be used to force biased representation for a
particular subtype.  Consider this example:

     type R is (A, B, C, D, E, F);
     subtype RAB is R range A .. B;
     subtype REF is R range E .. F;

By default, ‘RAB’ has a size of 1 (sufficient to accommodate the
representation of ‘A’ and ‘B’, 0 and 1), and ‘REF’ has a size of 3
(sufficient to accommodate the representation of ‘E’ and ‘F’, 4 and 5).
But if we add the following ‘Value_Size’ attribute definition clause:

     for REF'Value_Size use 1;

then biased representation is forced for ‘REF’, and 0 will represent ‘E’
and 1 will represent ‘F’.  A warning is issued when a ‘Value_Size’
attribute definition clause forces biased representation.  This warning
can be turned off using ‘-gnatw.B’.


File: gnat_rm.info,  Node: Component_Size Clauses,  Next: Bit_Order Clauses,  Prev: Value_Size and Object_Size Clauses,  Up: Representation Clauses and Pragmas

9.7 Component_Size Clauses
==========================

Normally, the value specified in a component size clause must be
consistent with the subtype of the array component with regard to size
and alignment.  In other words, the value specified must be at least
equal to the size of this subtype, and must be a multiple of the
alignment value.

In addition, component size clauses are allowed which cause the array to
be packed, by specifying a smaller value.  A first case is for component
size values in the range 1 through 63 on 32-bit targets, and 1 through
127 on 64-bit targets.  The value specified may not be smaller than the
Size of the subtype.  GNAT will accurately honor all packing requests in
this range.  For example, if we have:

     type r is array (1 .. 8) of Natural;
     for r'Component_Size use 31;

then the resulting array has a length of 31 bytes (248 bits = 8 * 31).
Of course access to the components of such an array is considerably less
efficient than if the natural component size of 32 is used.  A second
case is when the subtype of the component is a record type padded
because of its default alignment.  For example, if we have:

     type r is record
       i : Integer;
       j : Integer;
       b : Boolean;
     end record;

     type a is array (1 .. 8) of r;
     for a'Component_Size use 72;

then the resulting array has a length of 72 bytes, instead of 96 bytes
if the alignment of the record (4) was obeyed.

Note that there is no point in giving both a component size clause and a
pragma Pack for the same array type.  if such duplicate clauses are
given, the pragma Pack will be ignored.


File: gnat_rm.info,  Node: Bit_Order Clauses,  Next: Effect of Bit_Order on Byte Ordering,  Prev: Component_Size Clauses,  Up: Representation Clauses and Pragmas

9.8 Bit_Order Clauses
=====================

For record subtypes, GNAT permits the specification of the ‘Bit_Order’
attribute.  The specification may either correspond to the default bit
order for the target, in which case the specification has no effect and
places no additional restrictions, or it may be for the non-standard
setting (that is the opposite of the default).

In the case where the non-standard value is specified, the effect is to
renumber bits within each byte, but the ordering of bytes is not
affected.  There are certain restrictions placed on component clauses as
follows:

   * Components fitting within a single storage unit.

     These are unrestricted, and the effect is merely to renumber bits.
     For example if we are on a little-endian machine with
     ‘Low_Order_First’ being the default, then the following two
     declarations have exactly the same effect:

          type R1 is record
             A : Boolean;
             B : Integer range 1 .. 120;
          end record;

          for R1 use record
             A at 0 range 0 .. 0;
             B at 0 range 1 .. 7;
          end record;

          type R2 is record
             A : Boolean;
             B : Integer range 1 .. 120;
          end record;

          for R2'Bit_Order use High_Order_First;

          for R2 use record
             A at 0 range 7 .. 7;
             B at 0 range 0 .. 6;
          end record;

     The useful application here is to write the second declaration with
     the ‘Bit_Order’ attribute definition clause, and know that it will
     be treated the same, regardless of whether the target is
     little-endian or big-endian.

   * Components occupying an integral number of bytes.

     These are components that exactly fit in two or more bytes.  Such
     component declarations are allowed, but have no effect, since it is
     important to realize that the ‘Bit_Order’ specification does not
     affect the ordering of bytes.  In particular, the following attempt
     at getting an endian-independent integer does not work:

          type R2 is record
             A : Integer;
          end record;

          for R2'Bit_Order use High_Order_First;

          for R2 use record
             A at 0 range 0 .. 31;
          end record;

     This declaration will result in a little-endian integer on a
     little-endian machine, and a big-endian integer on a big-endian
     machine.  If byte flipping is required for interoperability between
     big- and little-endian machines, this must be explicitly
     programmed.  This capability is not provided by ‘Bit_Order’.

   * Components that are positioned across byte boundaries.

     but do not occupy an integral number of bytes.  Given that bytes
     are not reordered, such fields would occupy a non-contiguous
     sequence of bits in memory, requiring non-trivial code to
     reassemble.  They are for this reason not permitted, and any
     component clause specifying such a layout will be flagged as
     illegal by GNAT.

Since the misconception that Bit_Order automatically deals with all
endian-related incompatibilities is a common one, the specification of a
component field that is an integral number of bytes will always generate
a warning.  This warning may be suppressed using ‘pragma Warnings (Off)’
if desired.  The following section contains additional details regarding
the issue of byte ordering.


File: gnat_rm.info,  Node: Effect of Bit_Order on Byte Ordering,  Next: Pragma Pack for Arrays,  Prev: Bit_Order Clauses,  Up: Representation Clauses and Pragmas

9.9 Effect of Bit_Order on Byte Ordering
========================================

In this section we will review the effect of the ‘Bit_Order’ attribute
definition clause on byte ordering.  Briefly, it has no effect at all,
but a detailed example will be helpful.  Before giving this example, let
us review the precise definition of the effect of defining ‘Bit_Order’.
The effect of a non-standard bit order is described in section 13.5.3 of
the Ada Reference Manual:

     “2 A bit ordering is a method of interpreting the meaning of the
     storage place attributes.”

To understand the precise definition of storage place attributes in this
context, we visit section 13.5.1 of the manual:

     “13 A record_representation_clause (without the mod_clause)
     specifies the layout.  The storage place attributes (see 13.5.2)
     are taken from the values of the position, first_bit, and last_bit
     expressions after normalizing those values so that first_bit is
     less than Storage_Unit.”

The critical point here is that storage places are taken from the values
after normalization, not before.  So the ‘Bit_Order’ interpretation
applies to normalized values.  The interpretation is described in the
later part of the 13.5.3 paragraph:

     “2 A bit ordering is a method of interpreting the meaning of the
     storage place attributes.  High_Order_First (known in the
     vernacular as ‘big endian’) means that the first bit of a storage
     element (bit 0) is the most significant bit (interpreting the
     sequence of bits that represent a component as an unsigned integer
     value).  Low_Order_First (known in the vernacular as ‘little
     endian’) means the opposite: the first bit is the least
     significant.”

Note that the numbering is with respect to the bits of a storage unit.
In other words, the specification affects only the numbering of bits
within a single storage unit.

We can make the effect clearer by giving an example.

Suppose that we have an external device which presents two bytes, the
first byte presented, which is the first (low addressed byte) of the two
byte record is called Master, and the second byte is called Slave.

The left most (most significant bit is called Control for each byte, and
the remaining 7 bits are called V1, V2, … V7, where V7 is the rightmost
(least significant) bit.

On a big-endian machine, we can write the following representation
clause

     type Data is record
        Master_Control : Bit;
        Master_V1      : Bit;
        Master_V2      : Bit;
        Master_V3      : Bit;
        Master_V4      : Bit;
        Master_V5      : Bit;
        Master_V6      : Bit;
        Master_V7      : Bit;
        Slave_Control  : Bit;
        Slave_V1       : Bit;
        Slave_V2       : Bit;
        Slave_V3       : Bit;
        Slave_V4       : Bit;
        Slave_V5       : Bit;
        Slave_V6       : Bit;
        Slave_V7       : Bit;
     end record;

     for Data use record
        Master_Control at 0 range 0 .. 0;
        Master_V1      at 0 range 1 .. 1;
        Master_V2      at 0 range 2 .. 2;
        Master_V3      at 0 range 3 .. 3;
        Master_V4      at 0 range 4 .. 4;
        Master_V5      at 0 range 5 .. 5;
        Master_V6      at 0 range 6 .. 6;
        Master_V7      at 0 range 7 .. 7;
        Slave_Control  at 1 range 0 .. 0;
        Slave_V1       at 1 range 1 .. 1;
        Slave_V2       at 1 range 2 .. 2;
        Slave_V3       at 1 range 3 .. 3;
        Slave_V4       at 1 range 4 .. 4;
        Slave_V5       at 1 range 5 .. 5;
        Slave_V6       at 1 range 6 .. 6;
        Slave_V7       at 1 range 7 .. 7;
     end record;

Now if we move this to a little endian machine, then the bit ordering
within the byte is backwards, so we have to rewrite the record rep
clause as:

     for Data use record
        Master_Control at 0 range 7 .. 7;
        Master_V1      at 0 range 6 .. 6;
        Master_V2      at 0 range 5 .. 5;
        Master_V3      at 0 range 4 .. 4;
        Master_V4      at 0 range 3 .. 3;
        Master_V5      at 0 range 2 .. 2;
        Master_V6      at 0 range 1 .. 1;
        Master_V7      at 0 range 0 .. 0;
        Slave_Control  at 1 range 7 .. 7;
        Slave_V1       at 1 range 6 .. 6;
        Slave_V2       at 1 range 5 .. 5;
        Slave_V3       at 1 range 4 .. 4;
        Slave_V4       at 1 range 3 .. 3;
        Slave_V5       at 1 range 2 .. 2;
        Slave_V6       at 1 range 1 .. 1;
        Slave_V7       at 1 range 0 .. 0;
     end record;

It is a nuisance to have to rewrite the clause, especially if the code
has to be maintained on both machines.  However, this is a case that we
can handle with the ‘Bit_Order’ attribute if it is implemented.  Note
that the implementation is not required on byte addressed machines, but
it is indeed implemented in GNAT. This means that we can simply use the
first record clause, together with the declaration

     for Data'Bit_Order use High_Order_First;

and the effect is what is desired, namely the layout is exactly the
same, independent of whether the code is compiled on a big-endian or
little-endian machine.

The important point to understand is that byte ordering is not affected.
A ‘Bit_Order’ attribute definition never affects which byte a field ends
up in, only where it ends up in that byte.  To make this clear, let us
rewrite the record rep clause of the previous example as:

     for Data'Bit_Order use High_Order_First;
     for Data use record
        Master_Control at 0 range  0 .. 0;
        Master_V1      at 0 range  1 .. 1;
        Master_V2      at 0 range  2 .. 2;
        Master_V3      at 0 range  3 .. 3;
        Master_V4      at 0 range  4 .. 4;
        Master_V5      at 0 range  5 .. 5;
        Master_V6      at 0 range  6 .. 6;
        Master_V7      at 0 range  7 .. 7;
        Slave_Control  at 0 range  8 .. 8;
        Slave_V1       at 0 range  9 .. 9;
        Slave_V2       at 0 range 10 .. 10;
        Slave_V3       at 0 range 11 .. 11;
        Slave_V4       at 0 range 12 .. 12;
        Slave_V5       at 0 range 13 .. 13;
        Slave_V6       at 0 range 14 .. 14;
        Slave_V7       at 0 range 15 .. 15;
     end record;

This is exactly equivalent to saying (a repeat of the first example):

     for Data'Bit_Order use High_Order_First;
     for Data use record
        Master_Control at 0 range 0 .. 0;
        Master_V1      at 0 range 1 .. 1;
        Master_V2      at 0 range 2 .. 2;
        Master_V3      at 0 range 3 .. 3;
        Master_V4      at 0 range 4 .. 4;
        Master_V5      at 0 range 5 .. 5;
        Master_V6      at 0 range 6 .. 6;
        Master_V7      at 0 range 7 .. 7;
        Slave_Control  at 1 range 0 .. 0;
        Slave_V1       at 1 range 1 .. 1;
        Slave_V2       at 1 range 2 .. 2;
        Slave_V3       at 1 range 3 .. 3;
        Slave_V4       at 1 range 4 .. 4;
        Slave_V5       at 1 range 5 .. 5;
        Slave_V6       at 1 range 6 .. 6;
        Slave_V7       at 1 range 7 .. 7;
     end record;

Why are they equivalent?  Well take a specific field, the ‘Slave_V2’
field.  The storage place attributes are obtained by normalizing the
values given so that the ‘First_Bit’ value is less than 8.  After
normalizing the values (0,10,10) we get (1,2,2) which is exactly what we
specified in the other case.

Now one might expect that the ‘Bit_Order’ attribute might affect bit
numbering within the entire record component (two bytes in this case,
thus affecting which byte fields end up in), but that is not the way
this feature is defined, it only affects numbering of bits, not which
byte they end up in.

Consequently it never makes sense to specify a starting bit number
greater than 7 (for a byte addressable field) if an attribute definition
for ‘Bit_Order’ has been given, and indeed it may be actively confusing
to specify such a value, so the compiler generates a warning for such
usage.

If you do need to control byte ordering then appropriate conditional
values must be used.  If in our example, the slave byte came first on
some machines we might write:

     Master_Byte_First constant Boolean := ...;

     Master_Byte : constant Natural :=
                     1 - Boolean'Pos (Master_Byte_First);
     Slave_Byte  : constant Natural :=
                     Boolean'Pos (Master_Byte_First);

     for Data'Bit_Order use High_Order_First;
     for Data use record
        Master_Control at Master_Byte range 0 .. 0;
        Master_V1      at Master_Byte range 1 .. 1;
        Master_V2      at Master_Byte range 2 .. 2;
        Master_V3      at Master_Byte range 3 .. 3;
        Master_V4      at Master_Byte range 4 .. 4;
        Master_V5      at Master_Byte range 5 .. 5;
        Master_V6      at Master_Byte range 6 .. 6;
        Master_V7      at Master_Byte range 7 .. 7;
        Slave_Control  at Slave_Byte  range 0 .. 0;
        Slave_V1       at Slave_Byte  range 1 .. 1;
        Slave_V2       at Slave_Byte  range 2 .. 2;
        Slave_V3       at Slave_Byte  range 3 .. 3;
        Slave_V4       at Slave_Byte  range 4 .. 4;
        Slave_V5       at Slave_Byte  range 5 .. 5;
        Slave_V6       at Slave_Byte  range 6 .. 6;
        Slave_V7       at Slave_Byte  range 7 .. 7;
     end record;

Now to switch between machines, all that is necessary is to set the
boolean constant ‘Master_Byte_First’ in an appropriate manner.


File: gnat_rm.info,  Node: Pragma Pack for Arrays,  Next: Pragma Pack for Records,  Prev: Effect of Bit_Order on Byte Ordering,  Up: Representation Clauses and Pragmas

9.10 Pragma Pack for Arrays
===========================

Pragma ‘Pack’ applied to an array has an effect that depends upon
whether the component type is `packable'.  For a component type to be
`packable', it must be one of the following cases:

   * Any elementary type.

   * Any small packed array type with a static size.

   * Any small simple record type with a static size.

For all these cases, if the component subtype size is in the range 1
through 63 on 32-bit targets, and 1 through 127 on 64-bit targets, then
the effect of the pragma ‘Pack’ is exactly as though a component size
were specified giving the component subtype size.

All other types are non-packable, they occupy an integral number of
storage units and the only effect of pragma Pack is to remove alignment
gaps.

For example if we have:

     type r is range 0 .. 17;

     type ar is array (1 .. 8) of r;
     pragma Pack (ar);

Then the component size of ‘ar’ will be set to 5 (i.e., to ‘r'size’, and
the size of the array ‘ar’ will be exactly 40 bits).

Note that in some cases this rather fierce approach to packing can
produce unexpected effects.  For example, in Ada 95 and Ada 2005,
subtype ‘Natural’ typically has a size of 31, meaning that if you pack
an array of ‘Natural’, you get 31-bit close packing, which saves a few
bits, but results in far less efficient access.  Since many other Ada
compilers will ignore such a packing request, GNAT will generate a
warning on some uses of pragma ‘Pack’ that it guesses might not be what
is intended.  You can easily remove this warning by using an explicit
‘Component_Size’ setting instead, which never generates a warning, since
the intention of the programmer is clear in this case.

GNAT treats packed arrays in one of two ways.  If the size of the array
is known at compile time and is at most 64 bits on 32-bit targets, and
at most 128 bits on 64-bit targets, then internally the array is
represented as a single modular type, of exactly the appropriate number
of bits.  If the length is greater than 64 bits on 32-bit targets, and
greater than 128 bits on 64-bit targets, or is not known at compile
time, then the packed array is represented as an array of bytes, and its
length is always a multiple of 8 bits.

Note that to represent a packed array as a modular type, the alignment
must be suitable for the modular type involved.  For example, on typical
machines a 32-bit packed array will be represented by a 32-bit modular
integer with an alignment of four bytes.  If you explicitly override the
default alignment with an alignment clause that is too small, the
modular representation cannot be used.  For example, consider the
following set of declarations:

     type R is range 1 .. 3;
     type S is array (1 .. 31) of R;
     for S'Component_Size use 2;
     for S'Size use 62;
     for S'Alignment use 1;

If the alignment clause were not present, then a 62-bit modular
representation would be chosen (typically with an alignment of 4 or 8
bytes depending on the target).  But the default alignment is overridden
with the explicit alignment clause.  This means that the modular
representation cannot be used, and instead the array of bytes
representation must be used, meaning that the length must be a multiple
of 8.  Thus the above set of declarations will result in a diagnostic
rejecting the size clause and noting that the minimum size allowed is
64.

One special case that is worth noting occurs when the base type of the
component size is 8/16/32 and the subtype is one bit less.  Notably this
occurs with subtype ‘Natural’.  Consider:

     type Arr is array (1 .. 32) of Natural;
     pragma Pack (Arr);

In all commonly used Ada 83 compilers, this pragma Pack would be
ignored, since typically ‘Natural'Size’ is 32 in Ada 83, and in any case
most Ada 83 compilers did not attempt 31 bit packing.

In Ada 95 and Ada 2005, ‘Natural'Size’ is required to be 31.
Furthermore, GNAT really does pack 31-bit subtype to 31 bits.  This may
result in a substantial unintended performance penalty when porting
legacy Ada 83 code.  To help prevent this, GNAT generates a warning in
such cases.  If you really want 31 bit packing in a case like this, you
can set the component size explicitly:

     type Arr is array (1 .. 32) of Natural;
     for Arr'Component_Size use 31;

Here 31-bit packing is achieved as required, and no warning is
generated, since in this case the programmer intention is clear.


File: gnat_rm.info,  Node: Pragma Pack for Records,  Next: Record Representation Clauses,  Prev: Pragma Pack for Arrays,  Up: Representation Clauses and Pragmas

9.11 Pragma Pack for Records
============================

Pragma ‘Pack’ applied to a record will pack the components to reduce
wasted space from alignment gaps and by reducing the amount of space
taken by components.  We distinguish between `packable' components and
`non-packable' components.  Components of the following types are
considered packable:

   * Components of an elementary type are packable unless they are
     aliased, independent or atomic.

   * Small packed arrays, where the size is statically known, are
     represented internally as modular integers, and so they are also
     packable.

   * Small simple records, where the size is statically known, are also
     packable.

For all these cases, if the ‘'Size’ value is in the range 1 through 64
on 32-bit targets, and 1 through 128 on 64-bit targets, the components
occupy the exact number of bits corresponding to this value and are
packed with no padding bits, i.e.  they can start on an arbitrary bit
boundary.

All other types are non-packable, they occupy an integral number of
storage units and the only effect of pragma ‘Pack’ is to remove
alignment gaps.

For example, consider the record

     type Rb1 is array (1 .. 13) of Boolean;
     pragma Pack (Rb1);

     type Rb2 is array (1 .. 65) of Boolean;
     pragma Pack (Rb2);

     type AF is new Float with Atomic;

     type X2 is record
        L1 : Boolean;
        L2 : Duration;
        L3 : AF;
        L4 : Boolean;
        L5 : Rb1;
        L6 : Rb2;
     end record;
     pragma Pack (X2);

The representation for the record ‘X2’ is as follows on 32-bit targets:

     for X2'Size use 224;
     for X2 use record
        L1 at  0 range  0 .. 0;
        L2 at  0 range  1 .. 64;
        L3 at 12 range  0 .. 31;
        L4 at 16 range  0 .. 0;
        L5 at 16 range  1 .. 13;
        L6 at 18 range  0 .. 71;
     end record;

Studying this example, we see that the packable fields ‘L1’ and ‘L2’ are
of length equal to their sizes, and placed at specific bit boundaries
(and not byte boundaries) to eliminate padding.  But ‘L3’ is of a
non-packable float type (because it is aliased), so it is on the next
appropriate alignment boundary.

The next two fields are fully packable, so ‘L4’ and ‘L5’ are minimally
packed with no gaps.  However, type ‘Rb2’ is a packed array that is
longer than 64 bits, so it is itself non-packable on 32-bit targets.
Thus the ‘L6’ field is aligned to the next byte boundary, and takes an
integral number of bytes, i.e., 72 bits.


File: gnat_rm.info,  Node: Record Representation Clauses,  Next: Handling of Records with Holes,  Prev: Pragma Pack for Records,  Up: Representation Clauses and Pragmas

9.12 Record Representation Clauses
==================================

Record representation clauses may be given for all record types,
including types obtained by record extension.  Component clauses are
allowed for any static component.  The restrictions on component clauses
depend on the type of the component.

For all components of an elementary type, the only restriction on
component clauses is that the size must be at least the ‘'Size’ value of
the type (actually the Value_Size).  There are no restrictions due to
alignment, and such components may freely cross storage boundaries.

Packed arrays with a size up to and including 64 bits on 32-bit targets,
and up to and including 128 bits on 64-bit targets, are represented
internally using a modular type with the appropriate number of bits, and
thus the same lack of restriction applies.  For example, if you declare:

     type R is array (1 .. 49) of Boolean;
     pragma Pack (R);
     for R'Size use 49;

then a component clause for a component of type ‘R’ may start on any
specified bit boundary, and may specify a value of 49 bits or greater.

For packed bit arrays that are longer than 64 bits on 32-bit targets,
and longer than 128 bits on 64-bit targets, there are two cases.  If the
component size is a power of 2 (1,2,4,8,16,32,64 bits), including the
important case of single bits or boolean values, then there are no
limitations on placement of such components, and they may start and end
at arbitrary bit boundaries.

If the component size is not a power of 2 (e.g., 3 or 5), then an array
of this type must always be placed on on a storage unit (byte) boundary
and occupy an integral number of storage units (bytes).  Any component
clause that does not meet this requirement will be rejected.

Any aliased component, or component of an aliased type, must have its
normal alignment and size.  A component clause that does not meet this
requirement will be rejected.

The tag field of a tagged type always occupies an address sized field at
the start of the record.  No component clause may attempt to overlay
this tag.  When a tagged type appears as a component, the tag field must
have proper alignment

In the case of a record extension ‘T1’, of a type ‘T’, no component
clause applied to the type ‘T1’ can specify a storage location that
would overlap the first ‘T'Object_Size’ bits of the record.

For all other component types, including non-bit-packed arrays, the
component can be placed at an arbitrary bit boundary, so for example,
the following is permitted:

     type R is array (1 .. 10) of Boolean;
     for R'Size use 80;

     type Q is record
        G, H : Boolean;
        L, M : R;
     end record;

     for Q use record
        G at 0 range  0 ..   0;
        H at 0 range  1 ..   1;
        L at 0 range  2 ..  81;
        R at 0 range 82 .. 161;
     end record;


File: gnat_rm.info,  Node: Handling of Records with Holes,  Next: Enumeration Clauses,  Prev: Record Representation Clauses,  Up: Representation Clauses and Pragmas

9.13 Handling of Records with Holes
===================================

As a result of alignment considerations, records may contain “holes” or
gaps which do not correspond to the data bits of any of the components.
Record representation clauses can also result in holes in records.

GNAT does not attempt to clear these holes, so in record objects, they
should be considered to hold undefined rubbish.  The generated equality
routine just tests components so does not access these undefined bits,
and assignment and copy operations may or may not preserve the contents
of these holes (for assignments, the holes in the target will in
practice contain either the bits that are present in the holes in the
source, or the bits that were present in the target before the
assignment).

If it is necessary to ensure that holes in records have all zero bits,
then record objects for which this initialization is desired should be
explicitly set to all zero values using Unchecked_Conversion or address
overlays.  For example

     type HRec is record
        C : Character;
        I : Integer;
     end record;

On typical machines, integers need to be aligned on a four-byte
boundary, resulting in three bytes of undefined rubbish following the
8-bit field for C. To ensure that the hole in a variable of type HRec is
set to all zero bits, you could for example do:

     type Base is record
        Dummy1, Dummy2 : Integer := 0;
     end record;

     BaseVar : Base;
     RealVar : Hrec;
     for RealVar'Address use BaseVar'Address;

Now the 8-bytes of the value of RealVar start out containing all zero
bits.  A safer approach is to just define dummy fields, avoiding the
holes, as in:

     type HRec is record
        C      : Character;
        Dummy1 : Short_Short_Integer := 0;
        Dummy2 : Short_Short_Integer := 0;
        Dummy3 : Short_Short_Integer := 0;
        I      : Integer;
     end record;

And to make absolutely sure that the intent of this is followed, you can
use representation clauses:

     for Hrec use record
        C      at 0 range 0 .. 7;
        Dummy1 at 1 range 0 .. 7;
        Dummy2 at 2 range 0 .. 7;
        Dummy3 at 3 range 0 .. 7;
        I      at 4 range 0 .. 31;
     end record;
     for Hrec'Size use 64;


File: gnat_rm.info,  Node: Enumeration Clauses,  Next: Address Clauses,  Prev: Handling of Records with Holes,  Up: Representation Clauses and Pragmas

9.14 Enumeration Clauses
========================

The only restriction on enumeration clauses is that the range of values
must be representable.  For the signed case, if one or more of the
representation values are negative, all values must be in the range:

     System.Min_Int .. System.Max_Int

For the unsigned case, where all values are nonnegative, the values must
be in the range:

     0 .. System.Max_Binary_Modulus;

A `confirming' representation clause is one in which the values range
from 0 in sequence, i.e., a clause that confirms the default
representation for an enumeration type.  Such a confirming
representation is permitted by these rules, and is specially recognized
by the compiler so that no extra overhead results from the use of such a
clause.

If an array has an index type which is an enumeration type to which an
enumeration clause has been applied, then the array is stored in a
compact manner.  Consider the declarations:

     type r is (A, B, C);
     for r use (A => 1, B => 5, C => 10);
     type t is array (r) of Character;

The array type t corresponds to a vector with exactly three elements and
has a default size equal to ‘3*Character'Size’.  This ensures efficient
use of space, but means that accesses to elements of the array will
incur the overhead of converting representation values to the
corresponding positional values, (i.e., the value delivered by the ‘Pos’
attribute).


File: gnat_rm.info,  Node: Address Clauses,  Next: Use of Address Clauses for Memory-Mapped I/O,  Prev: Enumeration Clauses,  Up: Representation Clauses and Pragmas

9.15 Address Clauses
====================

The reference manual allows a general restriction on representation
clauses, as found in RM 13.1(22):

     “An implementation need not support representation items containing
     nonstatic expressions, except that an implementation should support
     a representation item for a given entity if each nonstatic
     expression in the representation item is a name that statically
     denotes a constant declared before the entity.”

In practice this is applicable only to address clauses, since this is
the only case in which a nonstatic expression is permitted by the
syntax.  As the AARM notes in sections 13.1 (22.a-22.h):

     22.a Reason: This is to avoid the following sort of thing:

     22.b X : Integer := F(…); Y : Address := G(…); for X’Address use Y;

     22.c In the above, we have to evaluate the initialization
     expression for X before we know where to put the result.  This
     seems like an unreasonable implementation burden.

     22.d The above code should instead be written like this:

     22.e Y : constant Address := G(…); X : Integer := F(…); for
     X’Address use Y;

     22.f This allows the expression ‘Y’ to be safely evaluated before X
     is created.

     22.g The constant could be a formal parameter of mode in.

     22.h An implementation can support other nonstatic expressions if
     it wants to.  Expressions of type Address are hardly ever static,
     but their value might be known at compile time anyway in many
     cases.

GNAT does indeed permit many additional cases of nonstatic expressions.
In particular, if the type involved is elementary there are no
restrictions (since in this case, holding a temporary copy of the
initialization value, if one is present, is inexpensive).  In addition,
if there is no implicit or explicit initialization, then there are no
restrictions.  GNAT will reject only the case where all three of these
conditions hold:

   * The type of the item is non-elementary (e.g., a record or array).

   * There is explicit or implicit initialization required for the
     object.  Note that access values are always implicitly initialized.

   * The address value is nonstatic.  Here GNAT is more permissive than
     the RM, and allows the address value to be the address of a
     previously declared stand-alone variable, as long as it does not
     itself have an address clause.

          Anchor  : Some_Initialized_Type;
          Overlay : Some_Initialized_Type;
          for Overlay'Address use Anchor'Address;

     However, the prefix of the address clause cannot be an array
     component, or a component of a discriminated record.

As noted above in section 22.h, address values are typically nonstatic.
In particular the To_Address function, even if applied to a literal
value, is a nonstatic function call.  To avoid this minor annoyance,
GNAT provides the implementation defined attribute ‘To_Address.  The
following two expressions have identical values:

     To_Address (16#1234_0000#)
     System'To_Address (16#1234_0000#);

except that the second form is considered to be a static expression, and
thus when used as an address clause value is always permitted.

Additionally, GNAT treats as static an address clause that is an
unchecked_conversion of a static integer value.  This simplifies the
porting of legacy code, and provides a portable equivalent to the GNAT
attribute ‘To_Address’.

Another issue with address clauses is the interaction with alignment
requirements.  When an address clause is given for an object, the
address value must be consistent with the alignment of the object (which
is usually the same as the alignment of the type of the object).  If an
address clause is given that specifies an inappropriately aligned
address value, then the program execution is erroneous.

Since this source of erroneous behavior can have unfortunate effects on
machines with strict alignment requirements, GNAT checks (at compile
time if possible, generating a warning, or at execution time with a
run-time check) that the alignment is appropriate.  If the run-time
check fails, then ‘Program_Error’ is raised.  This run-time check is
suppressed if range checks are suppressed, or if the special GNAT check
Alignment_Check is suppressed, or if ‘pragma Restrictions
(No_Elaboration_Code)’ is in effect.  It is also suppressed by default
on non-strict alignment machines (such as the x86).

Finally, GNAT does not permit overlaying of objects of class-wide types.
In most cases, the compiler can detect an attempt at such overlays and
will generate a warning at compile time and a Program_Error exception at
run time.

An address clause cannot be given for an exported object.  More
understandably the real restriction is that objects with an address
clause cannot be exported.  This is because such variables are not
defined by the Ada program, so there is no external object to export.

It is permissible to give an address clause and a pragma Import for the
same object.  In this case, the variable is not really defined by the
Ada program, so there is no external symbol to be linked.  The link name
and the external name are ignored in this case.  The reason that we
allow this combination is that it provides a useful idiom to avoid
unwanted initializations on objects with address clauses.

When an address clause is given for an object that has implicit or
explicit initialization, then by default initialization takes place.
This means that the effect of the object declaration is to overwrite the
memory at the specified address.  This is almost always not what the
programmer wants, so GNAT will output a warning:

     with System;
     package G is
        type R is record
           M : Integer := 0;
        end record;

        Ext : R;
        for Ext'Address use System'To_Address (16#1234_1234#);
            |
     >>> warning: implicit initialization of "Ext" may
         modify overlaid storage
     >>> warning: use pragma Import for "Ext" to suppress
         initialization (RM B(24))

     end G;

As indicated by the warning message, the solution is to use a (dummy)
pragma Import to suppress this initialization.  The pragma tell the
compiler that the object is declared and initialized elsewhere.  The
following package compiles without warnings (and the initialization is
suppressed):

     with System;
     package G is
        type R is record
           M : Integer := 0;
        end record;

        Ext : R;
        for Ext'Address use System'To_Address (16#1234_1234#);
        pragma Import (Ada, Ext);
     end G;

A final issue with address clauses involves their use for overlaying
variables, as in the following example:

     A : Integer;
     B : Integer;
     for B'Address use A'Address;

or alternatively, using the form recommended by the RM:

     A    : Integer;
     Addr : constant Address := A'Address;
     B    : Integer;
     for B'Address use Addr;

In both of these cases, ‘A’ and ‘B’ become aliased to one another via
the address clause.  This use of address clauses to overlay variables,
achieving an effect similar to unchecked conversion was erroneous in Ada
83, but in Ada 95 and Ada 2005 the effect is implementation defined.
Furthermore, the Ada RM specifically recommends that in a situation like
this, ‘B’ should be subject to the following implementation advice (RM
13.3(19)):

     “19 If the Address of an object is specified, or it is imported or
     exported, then the implementation should not perform optimizations
     based on assumptions of no aliases.”

GNAT follows this recommendation, and goes further by also applying this
recommendation to the overlaid variable (‘A’ in the above example) in
this case.  This means that the overlay works “as expected”, in that a
modification to one of the variables will affect the value of the other.

More generally, GNAT interprets this recommendation conservatively for
address clauses: in the cases other than overlays, it considers that the
object is effectively subject to pragma ‘Volatile’ and implements the
associated semantics.

Note that when address clause overlays are used in this way, there is an
issue of unintentional initialization, as shown by this example:

     package Overwrite_Record is
        type R is record
           A : Character := 'C';
           B : Character := 'A';
        end record;
        X : Short_Integer := 3;
        Y : R;
        for Y'Address use X'Address;
            |
     >>> warning: default initialization of "Y" may
         modify "X", use pragma Import for "Y" to
         suppress initialization (RM B.1(24))

     end Overwrite_Record;

Here the default initialization of ‘Y’ will clobber the value of ‘X’,
which justifies the warning.  The warning notes that this effect can be
eliminated by adding a ‘pragma Import’ which suppresses the
initialization:

     package Overwrite_Record is
        type R is record
           A : Character := 'C';
           B : Character := 'A';
        end record;
        X : Short_Integer := 3;
        Y : R;
        for Y'Address use X'Address;
        pragma Import (Ada, Y);
     end Overwrite_Record;

Note that the use of ‘pragma Initialize_Scalars’ may cause variables to
be initialized when they would not otherwise have been in the absence of
the use of this pragma.  This may cause an overlay to have this
unintended clobbering effect.  The compiler avoids this for scalar
types, but not for composite objects (where in general the effect of
‘Initialize_Scalars’ is part of the initialization routine for the
composite object):

     pragma Initialize_Scalars;
     with Ada.Text_IO;  use Ada.Text_IO;
     procedure Overwrite_Array is
        type Arr is array (1 .. 5) of Integer;
        X : Arr := (others => 1);
        A : Arr;
        for A'Address use X'Address;
            |
     >>> warning: default initialization of "A" may
         modify "X", use pragma Import for "A" to
         suppress initialization (RM B.1(24))

     begin
        if X /= Arr'(others => 1) then
           Put_Line ("X was clobbered");
        else
           Put_Line ("X was not clobbered");
        end if;
     end Overwrite_Array;

The above program generates the warning as shown, and at execution time,
prints ‘X was clobbered’.  If the ‘pragma Import’ is added as suggested:

     pragma Initialize_Scalars;
     with Ada.Text_IO;  use Ada.Text_IO;
     procedure Overwrite_Array is
        type Arr is array (1 .. 5) of Integer;
        X : Arr := (others => 1);
        A : Arr;
        for A'Address use X'Address;
        pragma Import (Ada, A);
     begin
        if X /= Arr'(others => 1) then
           Put_Line ("X was clobbered");
        else
           Put_Line ("X was not clobbered");
        end if;
     end Overwrite_Array;

then the program compiles without the warning and when run will generate
the output ‘X was not clobbered’.


File: gnat_rm.info,  Node: Use of Address Clauses for Memory-Mapped I/O,  Next: Effect of Convention on Representation,  Prev: Address Clauses,  Up: Representation Clauses and Pragmas

9.16 Use of Address Clauses for Memory-Mapped I/O
=================================================

A common pattern is to use an address clause to map an atomic variable
to a location in memory that corresponds to a memory-mapped I/O
operation or operations, for example:

     type Mem_Word is record
        A,B,C,D : Byte;
     end record;
     pragma Atomic (Mem_Word);
     for Mem_Word_Size use 32;

     Mem : Mem_Word;
     for Mem'Address use some-address;
     ...
     Temp := Mem;
     Temp.A := 32;
     Mem := Temp;

For a full access (reference or modification) of the variable (Mem) in
this case, as in the above examples, GNAT guarantees that the entire
atomic word will be accessed, in accordance with the RM C.6(15) clause.

A problem arises with a component access such as:

     Mem.A := 32;

Note that the component A is not declared as atomic.  This means that it
is not clear what this assignment means.  It could correspond to full
word read and write as given in the first example, or on architectures
that supported such an operation it might be a single byte store
instruction.  The RM does not have anything to say in this situation,
and GNAT does not make any guarantee.  The code generated may vary from
target to target.  GNAT will issue a warning in such a case:

     Mem.A := 32;
     |
     >>> warning: access to non-atomic component of atomic array,
         may cause unexpected accesses to atomic object

It is best to be explicit in this situation, by either declaring the
components to be atomic if you want the byte store, or explicitly
writing the full word access sequence if that is what the hardware
requires.  Alternatively, if the full word access sequence is required,
GNAT also provides the pragma ‘Volatile_Full_Access’ which can be used
in lieu of pragma ‘Atomic’ and will give the additional guarantee.


File: gnat_rm.info,  Node: Effect of Convention on Representation,  Next: Conventions and Anonymous Access Types,  Prev: Use of Address Clauses for Memory-Mapped I/O,  Up: Representation Clauses and Pragmas

9.17 Effect of Convention on Representation
===========================================

Normally the specification of a foreign language convention for a type
or an object has no effect on the chosen representation.  In particular,
the representation chosen for data in GNAT generally meets the standard
system conventions, and for example records are laid out in a manner
that is consistent with C. This means that specifying convention C (for
example) has no effect.

There are four exceptions to this general rule:

   * `Convention Fortran and array subtypes'.

     If pragma Convention Fortran is specified for an array subtype,
     then in accordance with the implementation advice in section
     3.6.2(11) of the Ada Reference Manual, the array will be stored in
     a Fortran-compatible column-major manner, instead of the normal
     default row-major order.

   * `Convention C and enumeration types'

     GNAT normally stores enumeration types in 8, 16, or 32 bits as
     required to accommodate all values of the type.  For example, for
     the enumeration type declared by:

          type Color is (Red, Green, Blue);

     8 bits is sufficient to store all values of the type, so by
     default, objects of type ‘Color’ will be represented using 8 bits.
     However, normal C convention is to use 32 bits for all enum values
     in C, since enum values are essentially of type int.  If pragma
     ‘Convention C’ is specified for an Ada enumeration type, then the
     size is modified as necessary (usually to 32 bits) to be consistent
     with the C convention for enum values.

     Note that this treatment applies only to types.  If Convention C is
     given for an enumeration object, where the enumeration type is not
     Convention C, then Object_Size bits are allocated.  For example,
     for a normal enumeration type, with less than 256 elements, only 8
     bits will be allocated for the object.  Since this may be a
     surprise in terms of what C expects, GNAT will issue a warning in
     this situation.  The warning can be suppressed by giving an
     explicit size clause specifying the desired size.

   * `Convention C/Fortran and Boolean types'

     In C, the usual convention for boolean values, that is values used
     for conditions, is that zero represents false, and nonzero values
     represent true.  In Ada, the normal convention is that two specific
     values, typically 0/1, are used to represent false/true
     respectively.

     Fortran has a similar convention for ‘LOGICAL’ values (any nonzero
     value represents true).

     To accommodate the Fortran and C conventions, if a pragma
     Convention specifies C or Fortran convention for a derived Boolean,
     as in the following example:

          type C_Switch is new Boolean;
          pragma Convention (C, C_Switch);

     then the GNAT generated code will treat any nonzero value as true.
     For truth values generated by GNAT, the conventional value 1 will
     be used for True, but when one of these values is read, any nonzero
     value is treated as True.


File: gnat_rm.info,  Node: Conventions and Anonymous Access Types,  Next: Determining the Representations chosen by GNAT,  Prev: Effect of Convention on Representation,  Up: Representation Clauses and Pragmas

9.18 Conventions and Anonymous Access Types
===========================================

The RM is not entirely clear on convention handling in a number of
cases, and in particular, it is not clear on the convention to be given
to anonymous access types in general, and in particular what is to be
done for the case of anonymous access-to-subprogram.

In GNAT, we decide that if an explicit Convention is applied to an
object or component, and its type is such an anonymous type, then the
convention will apply to this anonymous type as well.  This seems to
make sense since it is anomolous in any case to have a different
convention for an object and its type, and there is clearly no way to
explicitly specify a convention for an anonymous type, since it doesn’t
have a name to specify!

Furthermore, we decide that if a convention is applied to a record type,
then this convention is inherited by any of its components that are of
an anonymous access type which do not have an explicitly specified
convention.

The following program shows these conventions in action:

     package ConvComp is
        type Foo is range 1 .. 10;
        type T1 is record
           A : access function (X : Foo) return Integer;
           B : Integer;
        end record;
        pragma Convention (C, T1);

        type T2 is record
           A : access function (X : Foo) return Integer;
           pragma Convention  (C, A);
           B : Integer;
        end record;
        pragma Convention (COBOL, T2);

        type T3 is record
           A : access function (X : Foo) return Integer;
           pragma Convention  (COBOL, A);
           B : Integer;
        end record;
        pragma Convention (C, T3);

        type T4 is record
           A : access function (X : Foo) return Integer;
           B : Integer;
        end record;
        pragma Convention (COBOL, T4);

        function F (X : Foo) return Integer;
        pragma Convention (C, F);

        function F (X : Foo) return Integer is (13);

        TV1 : T1 := (F'Access, 12);  -- OK
        TV2 : T2 := (F'Access, 13);  -- OK

        TV3 : T3 := (F'Access, 13);  -- ERROR
                     |
     >>> subprogram "F" has wrong convention
     >>> does not match access to subprogram declared at line 17
          38.    TV4 : T4 := (F'Access, 13);  -- ERROR
                     |
     >>> subprogram "F" has wrong convention
     >>> does not match access to subprogram declared at line 24
          39. end ConvComp;


File: gnat_rm.info,  Node: Determining the Representations chosen by GNAT,  Prev: Conventions and Anonymous Access Types,  Up: Representation Clauses and Pragmas

9.19 Determining the Representations chosen by GNAT
===================================================

Although the descriptions in this section are intended to be complete,
it is often easier to simply experiment to see what GNAT accepts and
what the effect is on the layout of types and objects.

As required by the Ada RM, if a representation clause is not accepted,
then it must be rejected as illegal by the compiler.  However, when a
representation clause or pragma is accepted, there can still be
questions of what the compiler actually does.  For example, if a partial
record representation clause specifies the location of some components
and not others, then where are the non-specified components placed?  Or
if pragma ‘Pack’ is used on a record, then exactly where are the
resulting fields placed?  The section on pragma ‘Pack’ in this chapter
can be used to answer the second question, but it is often easier to
just see what the compiler does.

For this purpose, GNAT provides the option `-gnatR'. If you compile with
this option, then the compiler will output information on the actual
representations chosen, in a format similar to source representation
clauses.  For example, if we compile the package:

     package q is
        type r (x : boolean) is tagged record
           case x is
              when True => S : String (1 .. 100);
              when False => null;
           end case;
        end record;

        type r2 is new r (false) with record
           y2 : integer;
        end record;

        for r2 use record
           y2 at 16 range 0 .. 31;
        end record;

        type x is record
           y : character;
        end record;

        type x1 is array (1 .. 10) of x;
        for x1'component_size use 11;

        type ia is access integer;

        type Rb1 is array (1 .. 13) of Boolean;
        pragma Pack (rb1);

        type Rb2 is array (1 .. 65) of Boolean;
        pragma Pack (rb2);

        type x2 is record
           l1 : Boolean;
           l2 : Duration;
           l3 : Float;
           l4 : Boolean;
           l5 : Rb1;
           l6 : Rb2;
        end record;
        pragma Pack (x2);
     end q;

using the switch `-gnatR' we obtain the following output:

     Representation information for unit q
     -------------------------------------

     for r'Size use ??;
     for r'Alignment use 4;
     for r use record
        x    at 4 range  0 .. 7;
        _tag at 0 range  0 .. 31;
        s    at 5 range  0 .. 799;
     end record;

     for r2'Size use 160;
     for r2'Alignment use 4;
     for r2 use record
        x       at  4 range  0 .. 7;
        _tag    at  0 range  0 .. 31;
        _parent at  0 range  0 .. 63;
        y2      at 16 range  0 .. 31;
     end record;

     for x'Size use 8;
     for x'Alignment use 1;
     for x use record
        y at 0 range  0 .. 7;
     end record;

     for x1'Size use 112;
     for x1'Alignment use 1;
     for x1'Component_Size use 11;

     for rb1'Size use 13;
     for rb1'Alignment use 2;
     for rb1'Component_Size use 1;

     for rb2'Size use 72;
     for rb2'Alignment use 1;
     for rb2'Component_Size use 1;

     for x2'Size use 224;
     for x2'Alignment use 4;
     for x2 use record
        l1 at  0 range  0 .. 0;
        l2 at  0 range  1 .. 64;
        l3 at 12 range  0 .. 31;
        l4 at 16 range  0 .. 0;
        l5 at 16 range  1 .. 13;
        l6 at 18 range  0 .. 71;
     end record;

The Size values are actually the Object_Size, i.e., the default size
that will be allocated for objects of the type.  The ‘??’ size for type
r indicates that we have a variant record, and the actual size of
objects will depend on the discriminant value.

The Alignment values show the actual alignment chosen by the compiler
for each record or array type.

The record representation clause for type r shows where all fields are
placed, including the compiler generated tag field (whose location
cannot be controlled by the programmer).

The record representation clause for the type extension r2 shows all the
fields present, including the parent field, which is a copy of the
fields of the parent type of r2, i.e., r1.

The component size and size clauses for types rb1 and rb2 show the exact
effect of pragma ‘Pack’ on these arrays, and the record representation
clause for type x2 shows how pragma ‘Pack’ affects this record type.

In some cases, it may be useful to cut and paste the representation
clauses generated by the compiler into the original source to fix and
guarantee the actual representation to be used.


File: gnat_rm.info,  Node: Standard Library Routines,  Next: The Implementation of Standard I/O,  Prev: Representation Clauses and Pragmas,  Up: Top

10 Standard Library Routines
****************************

The Ada Reference Manual contains in Annex A a full description of an
extensive set of standard library routines that can be used in any Ada
program, and which must be provided by all Ada compilers.  They are
analogous to the standard C library used by C programs.

GNAT implements all of the facilities described in annex A, and for most
purposes the description in the Ada Reference Manual, or appropriate Ada
text book, will be sufficient for making use of these facilities.

In the case of the input-output facilities, *note The Implementation of
Standard I/O: f, gives details on exactly how GNAT interfaces to the
file system.  For the remaining packages, the Ada Reference Manual
should be sufficient.  The following is a list of the packages included,
together with a brief description of the functionality that is provided.

For completeness, references are included to other predefined library
routines defined in other sections of the Ada Reference Manual (these
are cross-indexed from Annex A). For further details see the relevant
package declarations in the run-time library.  In particular, a few
units are not implemented, as marked by the presence of pragma
Unimplemented_Unit, and in this case the package declaration contains
comments explaining why the unit is not implemented.

‘Ada’ `(A.2)'

     This is a parent package for all the standard library packages.  It
     is usually included implicitly in your program, and itself contains
     no useful data or routines.

‘Ada.Assertions’ `(11.4.2)'

     ‘Assertions’ provides the ‘Assert’ subprograms, and also the
     declaration of the ‘Assertion_Error’ exception.

‘Ada.Asynchronous_Task_Control’ `(D.11)'

     ‘Asynchronous_Task_Control’ provides low level facilities for task
     synchronization.  It is typically not implemented.  See package
     spec for details.

‘Ada.Calendar’ `(9.6)'

     ‘Calendar’ provides time of day access, and routines for
     manipulating times and durations.

‘Ada.Calendar.Arithmetic’ `(9.6.1)'

     This package provides additional arithmetic operations for
     ‘Calendar’.

‘Ada.Calendar.Formatting’ `(9.6.1)'

     This package provides formatting operations for ‘Calendar’.

‘Ada.Calendar.Time_Zones’ `(9.6.1)'

     This package provides additional ‘Calendar’ facilities for handling
     time zones.

‘Ada.Characters’ `(A.3.1)'

     This is a dummy parent package that contains no useful entities

‘Ada.Characters.Conversions’ `(A.3.2)'

     This package provides character conversion functions.

‘Ada.Characters.Handling’ `(A.3.2)'

     This package provides some basic character handling capabilities,
     including classification functions for classes of characters (e.g.,
     test for letters, or digits).

‘Ada.Characters.Latin_1’ `(A.3.3)'

     This package includes a complete set of definitions of the
     characters that appear in type CHARACTER. It is useful for writing
     programs that will run in international environments.  For example,
     if you want an upper case E with an acute accent in a string, it is
     often better to use the definition of ‘UC_E_Acute’ in this package.
     Then your program will print in an understandable manner even if
     your environment does not support these extended characters.

‘Ada.Command_Line’ `(A.15)'

     This package provides access to the command line parameters and the
     name of the current program (analogous to the use of ‘argc’ and
     ‘argv’ in C), and also allows the exit status for the program to be
     set in a system-independent manner.

‘Ada.Complex_Text_IO’ `(G.1.3)'

     This package provides text input and output of complex numbers.

‘Ada.Containers’ `(A.18.1)'

     A top level package providing a few basic definitions used by all
     the following specific child packages that provide specific kinds
     of containers.

‘Ada.Containers.Bounded_Priority_Queues’ `(A.18.31)'

‘Ada.Containers.Bounded_Synchronized_Queues’ `(A.18.29)'

‘Ada.Containers.Doubly_Linked_Lists’ `(A.18.3)'

‘Ada.Containers.Generic_Array_Sort’ `(A.18.26)'

‘Ada.Containers.Generic_Constrained_Array_Sort’ `(A.18.26)'

‘Ada.Containers.Generic_Sort’ `(A.18.26)'

‘Ada.Containers.Hashed_Maps’ `(A.18.5)'

‘Ada.Containers.Hashed_Sets’ `(A.18.8)'

‘Ada.Containers.Indefinite_Doubly_Linked_Lists’ `(A.18.12)'

‘Ada.Containers.Indefinite_Hashed_Maps’ `(A.18.13)'

‘Ada.Containers.Indefinite_Hashed_Sets’ `(A.18.15)'

‘Ada.Containers.Indefinite_Holders’ `(A.18.18)'

‘Ada.Containers.Indefinite_Multiway_Trees’ `(A.18.17)'

‘Ada.Containers.Indefinite_Ordered_Maps’ `(A.18.14)'

‘Ada.Containers.Indefinite_Ordered_Sets’ `(A.18.16)'

‘Ada.Containers.Indefinite_Vectors’ `(A.18.11)'

‘Ada.Containers.Multiway_Trees’ `(A.18.10)'

‘Ada.Containers.Ordered_Maps’ `(A.18.6)'

‘Ada.Containers.Ordered_Sets’ `(A.18.9)'

‘Ada.Containers.Synchronized_Queue_Interfaces’ `(A.18.27)'

‘Ada.Containers.Unbounded_Priority_Queues’ `(A.18.30)'

‘Ada.Containers.Unbounded_Synchronized_Queues’ `(A.18.28)'

‘Ada.Containers.Vectors’ `(A.18.2)'

‘Ada.Directories’ `(A.16)'

     This package provides operations on directories.

‘Ada.Directories.Hierarchical_File_Names’ `(A.16.1)'

     This package provides additional directory operations handling
     hiearchical file names.

‘Ada.Directories.Information’ `(A.16)'

     This is an implementation defined package for additional directory
     operations, which is not implemented in GNAT.

‘Ada.Decimal’ `(F.2)'

     This package provides constants describing the range of decimal
     numbers implemented, and also a decimal divide routine (analogous
     to the COBOL verb DIVIDE … GIVING … REMAINDER …)

‘Ada.Direct_IO’ `(A.8.4)'

     This package provides input-output using a model of a set of
     records of fixed-length, containing an arbitrary definite Ada type,
     indexed by an integer record number.

‘Ada.Dispatching’ `(D.2.1)'

     A parent package containing definitions for task dispatching
     operations.

‘Ada.Dispatching.EDF’ `(D.2.6)'

     Not implemented in GNAT.

‘Ada.Dispatching.Non_Preemptive’ `(D.2.4)'

     Not implemented in GNAT.

‘Ada.Dispatching.Round_Robin’ `(D.2.5)'

     Not implemented in GNAT.

‘Ada.Dynamic_Priorities’ `(D.5)'

     This package allows the priorities of a task to be adjusted
     dynamically as the task is running.

‘Ada.Environment_Variables’ `(A.17)'

     This package provides facilities for accessing environment
     variables.

‘Ada.Exceptions’ `(11.4.1)'

     This package provides additional information on exceptions, and
     also contains facilities for treating exceptions as data objects,
     and raising exceptions with associated messages.

‘Ada.Execution_Time’ `(D.14)'

     This package provides CPU clock functionalities.  It is not
     implemented on all targets (see package spec for details).

‘Ada.Execution_Time.Group_Budgets’ `(D.14.2)'

     Not implemented in GNAT.

‘Ada.Execution_Time.Timers’ `(D.14.1)’'

     Not implemented in GNAT.

‘Ada.Finalization’ `(7.6)'

     This package contains the declarations and subprograms to support
     the use of controlled types, providing for automatic initialization
     and finalization (analogous to the constructors and destructors of
     C++).

‘Ada.Float_Text_IO’ `(A.10.9)'

     A library level instantiation of Text_IO.Float_IO for type Float.

‘Ada.Float_Wide_Text_IO’ `(A.10.9)'

     A library level instantiation of Wide_Text_IO.Float_IO for type
     Float.

‘Ada.Float_Wide_Wide_Text_IO’ `(A.10.9)'

     A library level instantiation of Wide_Wide_Text_IO.Float_IO for
     type Float.

‘Ada.Integer_Text_IO’ `(A.10.9)'

     A library level instantiation of Text_IO.Integer_IO for type
     Integer.

‘Ada.Integer_Wide_Text_IO’ `(A.10.9)'

     A library level instantiation of Wide_Text_IO.Integer_IO for type
     Integer.

‘Ada.Integer_Wide_Wide_Text_IO’ `(A.10.9)'

     A library level instantiation of Wide_Wide_Text_IO.Integer_IO for
     type Integer.

‘Ada.Interrupts’ `(C.3.2)'

     This package provides facilities for interfacing to interrupts,
     which includes the set of signals or conditions that can be raised
     and recognized as interrupts.

‘Ada.Interrupts.Names’ `(C.3.2)'

     This package provides the set of interrupt names (actually signal
     or condition names) that can be handled by GNAT.

‘Ada.IO_Exceptions’ `(A.13)'

     This package defines the set of exceptions that can be raised by
     use of the standard IO packages.

‘Ada.Iterator_Interfaces’ `(5.5.1)'

     This package provides a generic interface to generalized iterators.

‘Ada.Locales’ `(A.19)'

     This package provides declarations providing information (Language
     and Country) about the current locale.

‘Ada.Numerics’

     This package contains some standard constants and exceptions used
     throughout the numerics packages.  Note that the constants pi and e
     are defined here, and it is better to use these definitions than
     rolling your own.

‘Ada.Numerics.Complex_Arrays’ `(G.3.2)'

     Provides operations on arrays of complex numbers.

‘Ada.Numerics.Complex_Elementary_Functions’

     Provides the implementation of standard elementary functions (such
     as log and trigonometric functions) operating on complex numbers
     using the standard ‘Float’ and the ‘Complex’ and ‘Imaginary’ types
     created by the package ‘Numerics.Complex_Types’.

‘Ada.Numerics.Complex_Types’

     This is a predefined instantiation of
     ‘Numerics.Generic_Complex_Types’ using ‘Standard.Float’ to build
     the type ‘Complex’ and ‘Imaginary’.

‘Ada.Numerics.Discrete_Random’

     This generic package provides a random number generator suitable
     for generating uniformly distributed values of a specified discrete
     subtype.

‘Ada.Numerics.Float_Random’

     This package provides a random number generator suitable for
     generating uniformly distributed floating point values in the unit
     interval.

‘Ada.Numerics.Generic_Complex_Elementary_Functions’

     This is a generic version of the package that provides the
     implementation of standard elementary functions (such as log and
     trigonometric functions) for an arbitrary complex type.

     The following predefined instantiations of this package are
     provided:

        * ‘Short_Float’

          ‘Ada.Numerics.Short_Complex_Elementary_Functions’

        * ‘Float’

          ‘Ada.Numerics.Complex_Elementary_Functions’

        * ‘Long_Float’

          ‘Ada.Numerics.Long_Complex_Elementary_Functions’

‘Ada.Numerics.Generic_Complex_Types’

     This is a generic package that allows the creation of complex
     types, with associated complex arithmetic operations.

     The following predefined instantiations of this package exist

        * ‘Short_Float’

          ‘Ada.Numerics.Short_Complex_Complex_Types’

        * ‘Float’

          ‘Ada.Numerics.Complex_Complex_Types’

        * ‘Long_Float’

          ‘Ada.Numerics.Long_Complex_Complex_Types’

‘Ada.Numerics.Generic_Elementary_Functions’

     This is a generic package that provides the implementation of
     standard elementary functions (such as log an trigonometric
     functions) for an arbitrary float type.

     The following predefined instantiations of this package exist

        * ‘Short_Float’

          ‘Ada.Numerics.Short_Elementary_Functions’

        * ‘Float’

          ‘Ada.Numerics.Elementary_Functions’

        * ‘Long_Float’

          ‘Ada.Numerics.Long_Elementary_Functions’

‘Ada.Numerics.Generic_Real_Arrays’ `(G.3.1)'

     Generic operations on arrays of reals

‘Ada.Numerics.Real_Arrays’ `(G.3.1)'

     Preinstantiation of Ada.Numerics.Generic_Real_Arrays (Float).

‘Ada.Real_Time’ `(D.8)'

     This package provides facilities similar to those of ‘Calendar’,
     but operating with a finer clock suitable for real time control.
     Note that annex D requires that there be no backward clock jumps,
     and GNAT generally guarantees this behavior, but of course if the
     external clock on which the GNAT runtime depends is deliberately
     reset by some external event, then such a backward jump may occur.

‘Ada.Real_Time.Timing_Events’ `(D.15)'

     Not implemented in GNAT.

‘Ada.Sequential_IO’ `(A.8.1)'

     This package provides input-output facilities for sequential files,
     which can contain a sequence of values of a single type, which can
     be any Ada type, including indefinite (unconstrained) types.

‘Ada.Storage_IO’ `(A.9)'

     This package provides a facility for mapping arbitrary Ada types to
     and from a storage buffer.  It is primarily intended for the
     creation of new IO packages.

‘Ada.Streams’ `(13.13.1)'

     This is a generic package that provides the basic support for the
     concept of streams as used by the stream attributes (‘Input’,
     ‘Output’, ‘Read’ and ‘Write’).

‘Ada.Streams.Stream_IO’ `(A.12.1)'

     This package is a specialization of the type ‘Streams’ defined in
     package ‘Streams’ together with a set of operations providing
     Stream_IO capability.  The Stream_IO model permits both random and
     sequential access to a file which can contain an arbitrary set of
     values of one or more Ada types.

‘Ada.Strings’ `(A.4.1)'

     This package provides some basic constants used by the string
     handling packages.

‘Ada.Strings.Bounded’ `(A.4.4)'

     This package provides facilities for handling variable length
     strings.  The bounded model requires a maximum length.  It is thus
     somewhat more limited than the unbounded model, but avoids the use
     of dynamic allocation or finalization.

‘Ada.Strings.Bounded.Equal_Case_Insensitive’ `(A.4.10)'

     Provides case-insensitive comparisons of bounded strings

‘Ada.Strings.Bounded.Hash’ `(A.4.9)'

     This package provides a generic hash function for bounded strings

‘Ada.Strings.Bounded.Hash_Case_Insensitive’ `(A.4.9)'

     This package provides a generic hash function for bounded strings
     that converts the string to be hashed to lower case.

‘Ada.Strings.Bounded.Less_Case_Insensitive’ `(A.4.10)'

     This package provides a comparison function for bounded strings
     that works in a case insensitive manner by converting to lower case
     before the comparison.

‘Ada.Strings.Fixed’ `(A.4.3)'

     This package provides facilities for handling fixed length strings.

‘Ada.Strings.Fixed.Equal_Case_Insensitive’ `(A.4.10)'

     This package provides an equality function for fixed strings that
     compares the strings after converting both to lower case.

‘Ada.Strings.Fixed.Hash_Case_Insensitive’ `(A.4.9)'

     This package provides a case insensitive hash function for fixed
     strings that converts the string to lower case before computing the
     hash.

‘Ada.Strings.Fixed.Less_Case_Insensitive’ `(A.4.10)'

     This package provides a comparison function for fixed strings that
     works in a case insensitive manner by converting to lower case
     before the comparison.

‘Ada.Strings.Hash’ `(A.4.9)'

     This package provides a hash function for strings.

‘Ada.Strings.Hash_Case_Insensitive’ `(A.4.9)'

     This package provides a hash function for strings that is case
     insensitive.  The string is converted to lower case before
     computing the hash.

‘Ada.Strings.Less_Case_Insensitive’ `(A.4.10)'

     This package provides a comparison function for\strings that works
     in a case insensitive manner by converting to lower case before the
     comparison.

‘Ada.Strings.Maps’ `(A.4.2)'

     This package provides facilities for handling character mappings
     and arbitrarily defined subsets of characters.  For instance it is
     useful in defining specialized translation tables.

‘Ada.Strings.Maps.Constants’ `(A.4.6)'

     This package provides a standard set of predefined mappings and
     predefined character sets.  For example, the standard upper to
     lower case conversion table is found in this package.  Note that
     upper to lower case conversion is non-trivial if you want to take
     the entire set of characters, including extended characters like E
     with an acute accent, into account.  You should use the mappings in
     this package (rather than adding 32 yourself) to do case mappings.

‘Ada.Strings.Unbounded’ `(A.4.5)'

     This package provides facilities for handling variable length
     strings.  The unbounded model allows arbitrary length strings, but
     requires the use of dynamic allocation and finalization.

‘Ada.Strings.Unbounded.Equal_Case_Insensitive’ `(A.4.10)'

     Provides case-insensitive comparisons of unbounded strings

‘Ada.Strings.Unbounded.Hash’ `(A.4.9)'

     This package provides a generic hash function for unbounded strings

‘Ada.Strings.Unbounded.Hash_Case_Insensitive’ `(A.4.9)'

     This package provides a generic hash function for unbounded strings
     that converts the string to be hashed to lower case.

‘Ada.Strings.Unbounded.Less_Case_Insensitive’ `(A.4.10)'

     This package provides a comparison function for unbounded strings
     that works in a case insensitive manner by converting to lower case
     before the comparison.

‘Ada.Strings.UTF_Encoding’ `(A.4.11)'

     This package provides basic definitions for dealing with
     UTF-encoded strings.

‘Ada.Strings.UTF_Encoding.Conversions’ `(A.4.11)'

     This package provides conversion functions for UTF-encoded strings.

‘Ada.Strings.UTF_Encoding.Strings’ `(A.4.11)'

‘Ada.Strings.UTF_Encoding.Wide_Strings’ `(A.4.11)'

‘Ada.Strings.UTF_Encoding.Wide_Wide_Strings’ `(A.4.11)'

     These packages provide facilities for handling UTF encodings for
     Strings, Wide_Strings and Wide_Wide_Strings.

‘Ada.Strings.Wide_Bounded’ `(A.4.7)'

‘Ada.Strings.Wide_Fixed’ `(A.4.7)'

‘Ada.Strings.Wide_Maps’ `(A.4.7)'

‘Ada.Strings.Wide_Unbounded’ `(A.4.7)'

     These packages provide analogous capabilities to the corresponding
     packages without ‘Wide_’ in the name, but operate with the types
     ‘Wide_String’ and ‘Wide_Character’ instead of ‘String’ and
     ‘Character’.  Versions of all the child packages are available.

‘Ada.Strings.Wide_Wide_Bounded’ `(A.4.7)'

‘Ada.Strings.Wide_Wide_Fixed’ `(A.4.7)'

‘Ada.Strings.Wide_Wide_Maps’ `(A.4.7)'

‘Ada.Strings.Wide_Wide_Unbounded’ `(A.4.7)'

     These packages provide analogous capabilities to the corresponding
     packages without ‘Wide_’ in the name, but operate with the types
     ‘Wide_Wide_String’ and ‘Wide_Wide_Character’ instead of ‘String’
     and ‘Character’.

‘Ada.Synchronous_Barriers’ `(D.10.1)'

     This package provides facilities for synchronizing tasks at a low
     level with barriers.

‘Ada.Synchronous_Task_Control’ `(D.10)'

     This package provides some standard facilities for controlling task
     communication in a synchronous manner.

‘Ada.Synchronous_Task_Control.EDF’ `(D.10)'

     Not implemented in GNAT.

‘Ada.Tags’

     This package contains definitions for manipulation of the tags of
     tagged values.

‘Ada.Tags.Generic_Dispatching_Constructor’ `(3.9)'

     This package provides a way of constructing tagged class-wide
     values given only the tag value.

‘Ada.Task_Attributes’ `(C.7.2)'

     This package provides the capability of associating arbitrary
     task-specific data with separate tasks.

‘Ada.Task_Identifification’ `(C.7.1)'

     This package provides capabilities for task identification.

‘Ada.Task_Termination’ `(C.7.3)'

     This package provides control over task termination.

‘Ada.Text_IO’

     This package provides basic text input-output capabilities for
     character, string and numeric data.  The subpackages of this
     package are listed next.  Note that although these are defined as
     subpackages in the RM, they are actually transparently implemented
     as child packages in GNAT, meaning that they are only loaded if
     needed.

‘Ada.Text_IO.Decimal_IO’

     Provides input-output facilities for decimal fixed-point types

‘Ada.Text_IO.Enumeration_IO’

     Provides input-output facilities for enumeration types.

‘Ada.Text_IO.Fixed_IO’

     Provides input-output facilities for ordinary fixed-point types.

‘Ada.Text_IO.Float_IO’

     Provides input-output facilities for float types.  The following
     predefined instantiations of this generic package are available:

        * ‘Short_Float’

          ‘Short_Float_Text_IO’

        * ‘Float’

          ‘Float_Text_IO’

        * ‘Long_Float’

          ‘Long_Float_Text_IO’

‘Ada.Text_IO.Integer_IO’

     Provides input-output facilities for integer types.  The following
     predefined instantiations of this generic package are available:

        * ‘Short_Short_Integer’

          ‘Ada.Short_Short_Integer_Text_IO’

        * ‘Short_Integer’

          ‘Ada.Short_Integer_Text_IO’

        * ‘Integer’

          ‘Ada.Integer_Text_IO’

        * ‘Long_Integer’

          ‘Ada.Long_Integer_Text_IO’

        * ‘Long_Long_Integer’

          ‘Ada.Long_Long_Integer_Text_IO’

‘Ada.Text_IO.Modular_IO’

     Provides input-output facilities for modular (unsigned) types.

‘Ada.Text_IO.Bounded_IO (A.10.11)’

     Provides input-output facilities for bounded strings.

‘Ada.Text_IO.Complex_IO (G.1.3)’

     This package provides basic text input-output capabilities for
     complex data.

‘Ada.Text_IO.Editing (F.3.3)’

     This package contains routines for edited output, analogous to the
     use of pictures in COBOL. The picture formats used by this package
     are a close copy of the facility in COBOL.

‘Ada.Text_IO.Text_Streams (A.12.2)’

     This package provides a facility that allows Text_IO files to be
     treated as streams, so that the stream attributes can be used for
     writing arbitrary data, including binary data, to Text_IO files.

‘Ada.Text_IO.Unbounded_IO (A.10.12)’

     This package provides input-output facilities for unbounded
     strings.

‘Ada.Unchecked_Conversion (13.9)’

     This generic package allows arbitrary conversion from one type to
     another of the same size, providing for breaking the type safety in
     special circumstances.

     If the types have the same Size (more accurately the same
     Value_Size), then the effect is simply to transfer the bits from
     the source to the target type without any modification.  This usage
     is well defined, and for simple types whose representation is
     typically the same across all implementations, gives a portable
     method of performing such conversions.

     If the types do not have the same size, then the result is
     implementation defined, and thus may be non-portable.  The
     following describes how GNAT handles such unchecked conversion
     cases.

     If the types are of different sizes, and are both discrete types,
     then the effect is of a normal type conversion without any
     constraint checking.  In particular if the result type has a larger
     size, the result will be zero or sign extended.  If the result type
     has a smaller size, the result will be truncated by ignoring high
     order bits.

     If the types are of different sizes, and are not both discrete
     types, then the conversion works as though pointers were created to
     the source and target, and the pointer value is converted.  The
     effect is that bits are copied from successive low order storage
     units and bits of the source up to the length of the target type.

     A warning is issued if the lengths differ, since the effect in this
     case is implementation dependent, and the above behavior may not
     match that of some other compiler.

     A pointer to one type may be converted to a pointer to another type
     using unchecked conversion.  The only case in which the effect is
     undefined is when one or both pointers are pointers to
     unconstrained array types.  In this case, the bounds information
     may get incorrectly transferred, and in particular, GNAT uses
     double size pointers for such types, and it is meaningless to
     convert between such pointer types.  GNAT will issue a warning if
     the alignment of the target designated type is more strict than the
     alignment of the source designated type (since the result may be
     unaligned in this case).

     A pointer other than a pointer to an unconstrained array type may
     be converted to and from System.Address.  Such usage is common in
     Ada 83 programs, but note that Ada.Address_To_Access_Conversions is
     the preferred method of performing such conversions in Ada 95 and
     Ada 2005.  Neither unchecked conversion nor
     Ada.Address_To_Access_Conversions should be used in conjunction
     with pointers to unconstrained objects, since the bounds
     information cannot be handled correctly in this case.

‘Ada.Unchecked_Deallocation’ `(13.11.2)'

     This generic package allows explicit freeing of storage previously
     allocated by use of an allocator.

‘Ada.Wide_Text_IO’ `(A.11)'

     This package is similar to ‘Ada.Text_IO’, except that the external
     file supports wide character representations, and the internal
     types are ‘Wide_Character’ and ‘Wide_String’ instead of ‘Character’
     and ‘String’.  The corresponding set of nested packages and child
     packages are defined.

‘Ada.Wide_Wide_Text_IO’ `(A.11)'

     This package is similar to ‘Ada.Text_IO’, except that the external
     file supports wide character representations, and the internal
     types are ‘Wide_Character’ and ‘Wide_String’ instead of ‘Character’
     and ‘String’.  The corresponding set of nested packages and child
     packages are defined.

For packages in Interfaces and System, all the RM defined packages are
available in GNAT, see the Ada 2012 RM for full details.


File: gnat_rm.info,  Node: The Implementation of Standard I/O,  Next: The GNAT Library,  Prev: Standard Library Routines,  Up: Top

11 The Implementation of Standard I/O
*************************************

GNAT implements all the required input-output facilities described in
A.6 through A.14.  These sections of the Ada Reference Manual describe
the required behavior of these packages from the Ada point of view, and
if you are writing a portable Ada program that does not need to know the
exact manner in which Ada maps to the outside world when it comes to
reading or writing external files, then you do not need to read this
chapter.  As long as your files are all regular files (not pipes or
devices), and as long as you write and read the files only from Ada, the
description in the Ada Reference Manual is sufficient.

However, if you want to do input-output to pipes or other devices, such
as the keyboard or screen, or if the files you are dealing with are
either generated by some other language, or to be read by some other
language, then you need to know more about the details of how the GNAT
implementation of these input-output facilities behaves.

In this chapter we give a detailed description of exactly how GNAT
interfaces to the file system.  As always, the sources of the system are
available to you for answering questions at an even more detailed level,
but for most purposes the information in this chapter will suffice.

Another reason that you may need to know more about how input-output is
implemented arises when you have a program written in mixed languages
where, for example, files are shared between the C and Ada sections of
the same program.  GNAT provides some additional facilities, in the form
of additional child library packages, that facilitate this sharing, and
these additional facilities are also described in this chapter.

* Menu:

* Standard I/O Packages::
* FORM Strings::
* Direct_IO::
* Sequential_IO::
* Text_IO::
* Wide_Text_IO::
* Wide_Wide_Text_IO::
* Stream_IO::
* Text Translation::
* Shared Files::
* Filenames encoding::
* File content encoding::
* Open Modes::
* Operations on C Streams::
* Interfacing to C Streams::


File: gnat_rm.info,  Node: Standard I/O Packages,  Next: FORM Strings,  Up: The Implementation of Standard I/O

11.1 Standard I/O Packages
==========================

The Standard I/O packages described in Annex A for

   * Ada.Text_IO

   * Ada.Text_IO.Complex_IO

   * Ada.Text_IO.Text_Streams

   * Ada.Wide_Text_IO

   * Ada.Wide_Text_IO.Complex_IO

   * Ada.Wide_Text_IO.Text_Streams

   * Ada.Wide_Wide_Text_IO

   * Ada.Wide_Wide_Text_IO.Complex_IO

   * Ada.Wide_Wide_Text_IO.Text_Streams

   * Ada.Stream_IO

   * Ada.Sequential_IO

   * Ada.Direct_IO

are implemented using the C library streams facility; where

   * All files are opened using ‘fopen’.

   * All input/output operations use ‘fread’/‘fwrite’.

There is no internal buffering of any kind at the Ada library level.
The only buffering is that provided at the system level in the
implementation of the library routines that support streams.  This
facilitates shared use of these streams by mixed language programs.
Note though that system level buffering is explicitly enabled at
elaboration of the standard I/O packages and that can have an impact on
mixed language programs, in particular those using I/O before calling
the Ada elaboration routine (e.g., adainit).  It is recommended to call
the Ada elaboration routine before performing any I/O or when
impractical, flush the common I/O streams and in particular
Standard_Output before elaborating the Ada code.


File: gnat_rm.info,  Node: FORM Strings,  Next: Direct_IO,  Prev: Standard I/O Packages,  Up: The Implementation of Standard I/O

11.2 FORM Strings
=================

The format of a FORM string in GNAT is:

     "keyword=value,keyword=value,...,keyword=value"

where letters may be in upper or lower case, and there are no spaces
between values.  The order of the entries is not important.  Currently
the following keywords defined.

     TEXT_TRANSLATION=[YES|NO|TEXT|BINARY|U8TEXT|WTEXT|U16TEXT]
     SHARED=[YES|NO]
     WCEM=[n|h|u|s|e|8|b]
     ENCODING=[UTF8|8BITS]

The use of these parameters is described later in this section.  If an
unrecognized keyword appears in a form string, it is silently ignored
and not considered invalid.


File: gnat_rm.info,  Node: Direct_IO,  Next: Sequential_IO,  Prev: FORM Strings,  Up: The Implementation of Standard I/O

11.3 Direct_IO
==============

Direct_IO can only be instantiated for definite types.  This is a
restriction of the Ada language, which means that the records are fixed
length (the length being determined by ‘type'Size’, rounded up to the
next storage unit boundary if necessary).

The records of a Direct_IO file are simply written to the file in index
sequence, with the first record starting at offset zero, and subsequent
records following.  There is no control information of any kind.  For
example, if 32-bit integers are being written, each record takes
4-bytes, so the record at index ‘K’ starts at offset (‘K’-1)*4.

There is no limit on the size of Direct_IO files, they are expanded as
necessary to accommodate whatever records are written to the file.


File: gnat_rm.info,  Node: Sequential_IO,  Next: Text_IO,  Prev: Direct_IO,  Up: The Implementation of Standard I/O

11.4 Sequential_IO
==================

Sequential_IO may be instantiated with either a definite (constrained)
or indefinite (unconstrained) type.

For the definite type case, the elements written to the file are simply
the memory images of the data values with no control information of any
kind.  The resulting file should be read using the same type, no
validity checking is performed on input.

For the indefinite type case, the elements written consist of two parts.
First is the size of the data item, written as the memory image of a
‘Interfaces.C.size_t’ value, followed by the memory image of the data
value.  The resulting file can only be read using the same
(unconstrained) type.  Normal assignment checks are performed on these
read operations, and if these checks fail, ‘Data_Error’ is raised.  In
particular, in the array case, the lengths must match, and in the
variant record case, if the variable for a particular read operation is
constrained, the discriminants must match.

Note that it is not possible to use Sequential_IO to write variable
length array items, and then read the data back into different length
arrays.  For example, the following will raise ‘Data_Error’:

     package IO is new Sequential_IO (String);
     F : IO.File_Type;
     S : String (1..4);
     ...
     IO.Create (F)
     IO.Write (F, "hello!")
     IO.Reset (F, Mode=>In_File);
     IO.Read (F, S);
     Put_Line (S);

On some Ada implementations, this will print ‘hell’, but the program is
clearly incorrect, since there is only one element in the file, and that
element is the string ‘hello!’.

In Ada 95 and Ada 2005, this kind of behavior can be legitimately
achieved using Stream_IO, and this is the preferred mechanism.  In
particular, the above program fragment rewritten to use Stream_IO will
work correctly.


File: gnat_rm.info,  Node: Text_IO,  Next: Wide_Text_IO,  Prev: Sequential_IO,  Up: The Implementation of Standard I/O

11.5 Text_IO
============

Text_IO files consist of a stream of characters containing the following
special control characters:

     LF (line feed, 16#0A#) Line Mark
     FF (form feed, 16#0C#) Page Mark

A canonical Text_IO file is defined as one in which the following
conditions are met:

   * The character ‘LF’ is used only as a line mark, i.e., to mark the
     end of the line.

   * The character ‘FF’ is used only as a page mark, i.e., to mark the
     end of a page and consequently can appear only immediately
     following a ‘LF’ (line mark) character.

   * The file ends with either ‘LF’ (line mark) or ‘LF’-‘FF’ (line mark,
     page mark).  In the former case, the page mark is implicitly
     assumed to be present.

A file written using Text_IO will be in canonical form provided that no
explicit ‘LF’ or ‘FF’ characters are written using ‘Put’ or ‘Put_Line’.
There will be no ‘FF’ character at the end of the file unless an
explicit ‘New_Page’ operation was performed before closing the file.

A canonical Text_IO file that is a regular file (i.e., not a device or a
pipe) can be read using any of the routines in Text_IO. The semantics in
this case will be exactly as defined in the Ada Reference Manual, and
all the routines in Text_IO are fully implemented.

A text file that does not meet the requirements for a canonical Text_IO
file has one of the following:

   * The file contains ‘FF’ characters not immediately following a ‘LF’
     character.

   * The file contains ‘LF’ or ‘FF’ characters written by ‘Put’ or
     ‘Put_Line’, which are not logically considered to be line marks or
     page marks.

   * The file ends in a character other than ‘LF’ or ‘FF’, i.e., there
     is no explicit line mark or page mark at the end of the file.

Text_IO can be used to read such non-standard text files but subprograms
to do with line or page numbers do not have defined meanings.  In
particular, a ‘FF’ character that does not follow a ‘LF’ character may
or may not be treated as a page mark from the point of view of page and
line numbering.  Every ‘LF’ character is considered to end a line, and
there is an implied ‘LF’ character at the end of the file.

* Menu:

* Stream Pointer Positioning::
* Reading and Writing Non-Regular Files::
* Get_Immediate::
* Treating Text_IO Files as Streams::
* Text_IO Extensions::
* Text_IO Facilities for Unbounded Strings::


File: gnat_rm.info,  Node: Stream Pointer Positioning,  Next: Reading and Writing Non-Regular Files,  Up: Text_IO

11.5.1 Stream Pointer Positioning
---------------------------------

‘Ada.Text_IO’ has a definition of current position for a file that is
being read.  No internal buffering occurs in Text_IO, and usually the
physical position in the stream used to implement the file corresponds
to this logical position defined by Text_IO. There are two exceptions:

   * After a call to ‘End_Of_Page’ that returns ‘True’, the stream is
     positioned past the ‘LF’ (line mark) that precedes the page mark.
     Text_IO maintains an internal flag so that subsequent read
     operations properly handle the logical position which is unchanged
     by the ‘End_Of_Page’ call.

   * After a call to ‘End_Of_File’ that returns ‘True’, if the Text_IO
     file was positioned before the line mark at the end of file before
     the call, then the logical position is unchanged, but the stream is
     physically positioned right at the end of file (past the line mark,
     and past a possible page mark following the line mark.  Again
     Text_IO maintains internal flags so that subsequent read operations
     properly handle the logical position.

These discrepancies have no effect on the observable behavior of
Text_IO, but if a single Ada stream is shared between a C program and
Ada program, or shared (using ‘shared=yes’ in the form string) between
two Ada files, then the difference may be observable in some situations.


File: gnat_rm.info,  Node: Reading and Writing Non-Regular Files,  Next: Get_Immediate,  Prev: Stream Pointer Positioning,  Up: Text_IO

11.5.2 Reading and Writing Non-Regular Files
--------------------------------------------

A non-regular file is a device (such as a keyboard), or a pipe.  Text_IO
can be used for reading and writing.  Writing is not affected and the
sequence of characters output is identical to the normal file case, but
for reading, the behavior of Text_IO is modified to avoid undesirable
look-ahead as follows:

An input file that is not a regular file is considered to have no page
marks.  Any ‘Ascii.FF’ characters (the character normally used for a
page mark) appearing in the file are considered to be data characters.
In particular:

   * ‘Get_Line’ and ‘Skip_Line’ do not test for a page mark following a
     line mark.  If a page mark appears, it will be treated as a data
     character.

   * This avoids the need to wait for an extra character to be typed or
     entered from the pipe to complete one of these operations.

   * ‘End_Of_Page’ always returns ‘False’

   * ‘End_Of_File’ will return ‘False’ if there is a page mark at the
     end of the file.

Output to non-regular files is the same as for regular files.  Page
marks may be written to non-regular files using ‘New_Page’, but as noted
above they will not be treated as page marks on input if the output is
piped to another Ada program.

Another important discrepancy when reading non-regular files is that the
end of file indication is not ‘sticky’.  If an end of file is entered,
e.g., by pressing the ‘EOT’ key, then end of file is signaled once
(i.e., the test ‘End_Of_File’ will yield ‘True’, or a read will raise
‘End_Error’), but then reading can resume to read data past that end of
file indication, until another end of file indication is entered.


File: gnat_rm.info,  Node: Get_Immediate,  Next: Treating Text_IO Files as Streams,  Prev: Reading and Writing Non-Regular Files,  Up: Text_IO

11.5.3 Get_Immediate
--------------------

Get_Immediate returns the next character (including control characters)
from the input file.  In particular, Get_Immediate will return LF or FF
characters used as line marks or page marks.  Such operations leave the
file positioned past the control character, and it is thus not treated
as having its normal function.  This means that page, line and column
counts after this kind of Get_Immediate call are set as though the mark
did not occur.  In the case where a Get_Immediate leaves the file
positioned between the line mark and page mark (which is not normally
possible), it is undefined whether the FF character will be treated as a
page mark.


File: gnat_rm.info,  Node: Treating Text_IO Files as Streams,  Next: Text_IO Extensions,  Prev: Get_Immediate,  Up: Text_IO

11.5.4 Treating Text_IO Files as Streams
----------------------------------------

The package ‘Text_IO.Streams’ allows a ‘Text_IO’ file to be treated as a
stream.  Data written to a ‘Text_IO’ file in this stream mode is binary
data.  If this binary data contains bytes 16#0A# (‘LF’) or 16#0C#
(‘FF’), the resulting file may have non-standard format.  Similarly if
read operations are used to read from a Text_IO file treated as a
stream, then ‘LF’ and ‘FF’ characters may be skipped and the effect is
similar to that described above for ‘Get_Immediate’.


File: gnat_rm.info,  Node: Text_IO Extensions,  Next: Text_IO Facilities for Unbounded Strings,  Prev: Treating Text_IO Files as Streams,  Up: Text_IO

11.5.5 Text_IO Extensions
-------------------------

A package GNAT.IO_Aux in the GNAT library provides some useful
extensions to the standard ‘Text_IO’ package:

   * function File_Exists (Name : String) return Boolean; Determines if
     a file of the given name exists.

   * function Get_Line return String; Reads a string from the standard
     input file.  The value returned is exactly the length of the line
     that was read.

   * function Get_Line (File : Ada.Text_IO.File_Type) return String;
     Similar, except that the parameter File specifies the file from
     which the string is to be read.


File: gnat_rm.info,  Node: Text_IO Facilities for Unbounded Strings,  Prev: Text_IO Extensions,  Up: Text_IO

11.5.6 Text_IO Facilities for Unbounded Strings
-----------------------------------------------

The package ‘Ada.Strings.Unbounded.Text_IO’ in library files
‘a-suteio.ads/adb’ contains some GNAT-specific subprograms useful for
Text_IO operations on unbounded strings:

   * function Get_Line (File : File_Type) return Unbounded_String; Reads
     a line from the specified file and returns the result as an
     unbounded string.

   * procedure Put (File : File_Type; U : Unbounded_String); Writes the
     value of the given unbounded string to the specified file Similar
     to the effect of ‘Put (To_String (U))’ except that an extra copy is
     avoided.

   * procedure Put_Line (File : File_Type; U : Unbounded_String); Writes
     the value of the given unbounded string to the specified file,
     followed by a ‘New_Line’.  Similar to the effect of ‘Put_Line
     (To_String (U))’ except that an extra copy is avoided.

In the above procedures, ‘File’ is of type ‘Ada.Text_IO.File_Type’ and
is optional.  If the parameter is omitted, then the standard input or
output file is referenced as appropriate.

The package ‘Ada.Strings.Wide_Unbounded.Wide_Text_IO’ in library files
‘a-swuwti.ads’ and ‘a-swuwti.adb’ provides similar extended
‘Wide_Text_IO’ functionality for unbounded wide strings.

The package ‘Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO’ in
library files ‘a-szuzti.ads’ and ‘a-szuzti.adb’ provides similar
extended ‘Wide_Wide_Text_IO’ functionality for unbounded wide wide
strings.


File: gnat_rm.info,  Node: Wide_Text_IO,  Next: Wide_Wide_Text_IO,  Prev: Text_IO,  Up: The Implementation of Standard I/O

11.6 Wide_Text_IO
=================

‘Wide_Text_IO’ is similar in most respects to Text_IO, except that both
input and output files may contain special sequences that represent wide
character values.  The encoding scheme for a given file may be specified
using a FORM parameter:

     WCEM=`x`

as part of the FORM string (WCEM = wide character encoding method),
where ‘x’ is one of the following characters

Character      Encoding
               
----------------------------------------
               
`h'            Hex ESC encoding
               
               
`u'            Upper half encoding
               
               
`s'            Shift-JIS encoding
               
               
`e'            EUC Encoding
               
               
`8'            UTF-8 encoding
               
               
`b'            Brackets encoding
               

The encoding methods match those that can be used in a source program,
but there is no requirement that the encoding method used for the source
program be the same as the encoding method used for files, and different
files may use different encoding methods.

The default encoding method for the standard files, and for opened files
for which no WCEM parameter is given in the FORM string matches the wide
character encoding specified for the main program (the default being
brackets encoding if no coding method was specified with -gnatW).

`Hex Coding'

     In this encoding, a wide character is represented by a five
     character sequence:

     ESC a b c d

     where ‘a’, ‘b’, ‘c’, ‘d’ are the four hexadecimal characters (using
     upper case letters) of the wide character code.  For example, ESC
     A345 is used to represent the wide character with code 16#A345#.
     This scheme is compatible with use of the full ‘Wide_Character’
     set.

`Upper Half Coding'

     The wide character with encoding 16#abcd#, where the upper bit is
     on (i.e., a is in the range 8-F) is represented as two bytes 16#ab#
     and 16#cd#.  The second byte may never be a format control
     character, but is not required to be in the upper half.  This
     method can be also used for shift-JIS or EUC where the internal
     coding matches the external coding.

`Shift JIS Coding'

     A wide character is represented by a two character sequence 16#ab#
     and 16#cd#, with the restrictions described for upper half encoding
     as described above.  The internal character code is the
     corresponding JIS character according to the standard algorithm for
     Shift-JIS conversion.  Only characters defined in the JIS code set
     table can be used with this encoding method.

`EUC Coding'

     A wide character is represented by a two character sequence 16#ab#
     and 16#cd#, with both characters being in the upper half.  The
     internal character code is the corresponding JIS character
     according to the EUC encoding algorithm.  Only characters defined
     in the JIS code set table can be used with this encoding method.

`UTF-8 Coding'

     A wide character is represented using UCS Transformation Format 8
     (UTF-8) as defined in Annex R of ISO 10646-1/Am.2.  Depending on
     the character value, the representation is a one, two, or three
     byte sequence:

     16#0000#-16#007f#: 2#0xxxxxxx#
     16#0080#-16#07ff#: 2#110xxxxx# 2#10xxxxxx#
     16#0800#-16#ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#

     where the ‘xxx’ bits correspond to the left-padded bits of the
     16-bit character value.  Note that all lower half ASCII characters
     are represented as ASCII bytes and all upper half characters and
     other wide characters are represented as sequences of upper-half
     (The full UTF-8 scheme allows for encoding 31-bit characters as
     6-byte sequences, but in this implementation, all UTF-8 sequences
     of four or more bytes length will raise a Constraint_Error, as will
     all invalid UTF-8 sequences.)

`Brackets Coding'

     In this encoding, a wide character is represented by the following
     eight character sequence:

     [ " a b c d " ]

     where ‘a’, ‘b’, ‘c’, ‘d’ are the four hexadecimal characters (using
     uppercase letters) of the wide character code.  For example,
     ‘["A345"]’ is used to represent the wide character with code
     ‘16#A345#’.  This scheme is compatible with use of the full
     Wide_Character set.  On input, brackets coding can also be used for
     upper half characters, e.g., ‘["C1"]’ for lower case a.  However,
     on output, brackets notation is only used for wide characters with
     a code greater than ‘16#FF#’.

     Note that brackets coding is not normally used in the context of
     Wide_Text_IO or Wide_Wide_Text_IO, since it is really just designed
     as a portable way of encoding source files.  In the context of
     Wide_Text_IO or Wide_Wide_Text_IO, it can only be used if the file
     does not contain any instance of the left bracket character other
     than to encode wide character values using the brackets encoding
     method.  In practice it is expected that some standard wide
     character encoding method such as UTF-8 will be used for text input
     output.

     If brackets notation is used, then any occurrence of a left bracket
     in the input file which is not the start of a valid wide character
     sequence will cause Constraint_Error to be raised.  It is possible
     to encode a left bracket as [“5B”] and Wide_Text_IO and
     Wide_Wide_Text_IO input will interpret this as a left bracket.

     However, when a left bracket is output, it will be output as a left
     bracket and not as [“5B”].  We make this decision because for
     normal use of Wide_Text_IO for outputting messages, it is
     unpleasant to clobber left brackets.  For example, if we write:

          Put_Line ("Start of output [first run]");

     we really do not want to have the left bracket in this message
     clobbered so that the output reads:

     Start of output ["5B"]first run]

     In practice brackets encoding is reasonably useful for normal
     Put_Line use since we won’t get confused between left brackets and
     wide character sequences in the output.  But for input, or when
     files are written out and read back in, it really makes better
     sense to use one of the standard encoding methods such as UTF-8.

For the coding schemes other than UTF-8, Hex, or Brackets encoding, not
all wide character values can be represented.  An attempt to output a
character that cannot be represented using the encoding scheme for the
file causes Constraint_Error to be raised.  An invalid wide character
sequence on input also causes Constraint_Error to be raised.

* Menu:

* Stream Pointer Positioning: Stream Pointer Positioning<2>.
* Reading and Writing Non-Regular Files: Reading and Writing Non-Regular Files<2>.


File: gnat_rm.info,  Node: Stream Pointer Positioning<2>,  Next: Reading and Writing Non-Regular Files<2>,  Up: Wide_Text_IO

11.6.1 Stream Pointer Positioning
---------------------------------

‘Ada.Wide_Text_IO’ is similar to ‘Ada.Text_IO’ in its handling of stream
pointer positioning (*note Text_IO: 2ab.).  There is one additional
case:

If ‘Ada.Wide_Text_IO.Look_Ahead’ reads a character outside the normal
lower ASCII set (i.e., a character in the range:

     Wide_Character'Val (16#0080#) .. Wide_Character'Val (16#FFFF#)

then although the logical position of the file pointer is unchanged by
the ‘Look_Ahead’ call, the stream is physically positioned past the wide
character sequence.  Again this is to avoid the need for buffering or
backup, and all ‘Wide_Text_IO’ routines check the internal indication
that this situation has occurred so that this is not visible to a normal
program using ‘Wide_Text_IO’.  However, this discrepancy can be observed
if the wide text file shares a stream with another file.


File: gnat_rm.info,  Node: Reading and Writing Non-Regular Files<2>,  Prev: Stream Pointer Positioning<2>,  Up: Wide_Text_IO

11.6.2 Reading and Writing Non-Regular Files
--------------------------------------------

As in the case of Text_IO, when a non-regular file is read, it is
assumed that the file contains no page marks (any form characters are
treated as data characters), and ‘End_Of_Page’ always returns ‘False’.
Similarly, the end of file indication is not sticky, so it is possible
to read beyond an end of file.


File: gnat_rm.info,  Node: Wide_Wide_Text_IO,  Next: Stream_IO,  Prev: Wide_Text_IO,  Up: The Implementation of Standard I/O

11.7 Wide_Wide_Text_IO
======================

‘Wide_Wide_Text_IO’ is similar in most respects to Text_IO, except that
both input and output files may contain special sequences that represent
wide wide character values.  The encoding scheme for a given file may be
specified using a FORM parameter:

     WCEM=`x`

as part of the FORM string (WCEM = wide character encoding method),
where ‘x’ is one of the following characters

Character      Encoding
               
----------------------------------------
               
`h'            Hex ESC encoding
               
               
`u'            Upper half encoding
               
               
`s'            Shift-JIS encoding
               
               
`e'            EUC Encoding
               
               
`8'            UTF-8 encoding
               
               
`b'            Brackets encoding
               

The encoding methods match those that can be used in a source program,
but there is no requirement that the encoding method used for the source
program be the same as the encoding method used for files, and different
files may use different encoding methods.

The default encoding method for the standard files, and for opened files
for which no WCEM parameter is given in the FORM string matches the wide
character encoding specified for the main program (the default being
brackets encoding if no coding method was specified with -gnatW).

`UTF-8 Coding'

     A wide character is represented using UCS Transformation Format 8
     (UTF-8) as defined in Annex R of ISO 10646-1/Am.2.  Depending on
     the character value, the representation is a one, two, three, or
     four byte sequence:

     16#000000#-16#00007f#: 2#0xxxxxxx#
     16#000080#-16#0007ff#: 2#110xxxxx# 2#10xxxxxx#
     16#000800#-16#00ffff#: 2#1110xxxx# 2#10xxxxxx# 2#10xxxxxx#
     16#010000#-16#10ffff#: 2#11110xxx# 2#10xxxxxx# 2#10xxxxxx# 2#10xxxxxx#

     where the ‘xxx’ bits correspond to the left-padded bits of the
     21-bit character value.  Note that all lower half ASCII characters
     are represented as ASCII bytes and all upper half characters and
     other wide characters are represented as sequences of upper-half
     characters.

`Brackets Coding'

     In this encoding, a wide wide character is represented by the
     following eight character sequence if is in wide character range

     [ " a b c d " ]

     and by the following ten character sequence if not

     [ " a b c d e f " ]

     where ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, and ‘f’ are the four or six
     hexadecimal characters (using uppercase letters) of the wide wide
     character code.  For example, ‘["01A345"]’ is used to represent the
     wide wide character with code ‘16#01A345#’.

     This scheme is compatible with use of the full Wide_Wide_Character
     set.  On input, brackets coding can also be used for upper half
     characters, e.g., ‘["C1"]’ for lower case a.  However, on output,
     brackets notation is only used for wide characters with a code
     greater than ‘16#FF#’.

If is also possible to use the other Wide_Character encoding methods,
such as Shift-JIS, but the other schemes cannot support the full range
of wide wide characters.  An attempt to output a character that cannot
be represented using the encoding scheme for the file causes
Constraint_Error to be raised.  An invalid wide character sequence on
input also causes Constraint_Error to be raised.

* Menu:

* Stream Pointer Positioning: Stream Pointer Positioning<3>.
* Reading and Writing Non-Regular Files: Reading and Writing Non-Regular Files<3>.


File: gnat_rm.info,  Node: Stream Pointer Positioning<3>,  Next: Reading and Writing Non-Regular Files<3>,  Up: Wide_Wide_Text_IO

11.7.1 Stream Pointer Positioning
---------------------------------

‘Ada.Wide_Wide_Text_IO’ is similar to ‘Ada.Text_IO’ in its handling of
stream pointer positioning (*note Text_IO: 2ab.).  There is one
additional case:

If ‘Ada.Wide_Wide_Text_IO.Look_Ahead’ reads a character outside the
normal lower ASCII set (i.e., a character in the range:

     Wide_Wide_Character'Val (16#0080#) .. Wide_Wide_Character'Val (16#10FFFF#)

then although the logical position of the file pointer is unchanged by
the ‘Look_Ahead’ call, the stream is physically positioned past the wide
character sequence.  Again this is to avoid the need for buffering or
backup, and all ‘Wide_Wide_Text_IO’ routines check the internal
indication that this situation has occurred so that this is not visible
to a normal program using ‘Wide_Wide_Text_IO’.  However, this
discrepancy can be observed if the wide text file shares a stream with
another file.


File: gnat_rm.info,  Node: Reading and Writing Non-Regular Files<3>,  Prev: Stream Pointer Positioning<3>,  Up: Wide_Wide_Text_IO

11.7.2 Reading and Writing Non-Regular Files
--------------------------------------------

As in the case of Text_IO, when a non-regular file is read, it is
assumed that the file contains no page marks (any form characters are
treated as data characters), and ‘End_Of_Page’ always returns ‘False’.
Similarly, the end of file indication is not sticky, so it is possible
to read beyond an end of file.


File: gnat_rm.info,  Node: Stream_IO,  Next: Text Translation,  Prev: Wide_Wide_Text_IO,  Up: The Implementation of Standard I/O

11.8 Stream_IO
==============

A stream file is a sequence of bytes, where individual elements are
written to the file as described in the Ada Reference Manual.  The type
‘Stream_Element’ is simply a byte.  There are two ways to read or write
a stream file.

   * The operations ‘Read’ and ‘Write’ directly read or write a sequence
     of stream elements with no control information.

   * The stream attributes applied to a stream file transfer data in the
     manner described for stream attributes.


File: gnat_rm.info,  Node: Text Translation,  Next: Shared Files,  Prev: Stream_IO,  Up: The Implementation of Standard I/O

11.9 Text Translation
=====================

‘Text_Translation=xxx’ may be used as the Form parameter passed to
Text_IO.Create and Text_IO.Open.  ‘Text_Translation=xxx’ has no effect
on Unix systems.  Possible values are:

   * ‘Yes’ or ‘Text’ is the default, which means to translate LF to/from
     CR/LF on Windows systems.

     ‘No’ disables this translation; i.e.  it uses binary mode.  For
     output files, ‘Text_Translation=No’ may be used to create
     Unix-style files on Windows.

   * ‘wtext’ translation enabled in Unicode mode.  (corresponds to
     _O_WTEXT).

   * ‘u8text’ translation enabled in Unicode UTF-8 mode.  (corresponds
     to O_U8TEXT).

   * ‘u16text’ translation enabled in Unicode UTF-16 mode.  (corresponds
     to_O_U16TEXT).


File: gnat_rm.info,  Node: Shared Files,  Next: Filenames encoding,  Prev: Text Translation,  Up: The Implementation of Standard I/O

11.10 Shared Files
==================

Section A.14 of the Ada Reference Manual allows implementations to
provide a wide variety of behavior if an attempt is made to access the
same external file with two or more internal files.

To provide a full range of functionality, while at the same time
minimizing the problems of portability caused by this implementation
dependence, GNAT handles file sharing as follows:

   * In the absence of a ‘shared=xxx’ form parameter, an attempt to open
     two or more files with the same full name is considered an error
     and is not supported.  The exception ‘Use_Error’ will be raised.
     Note that a file that is not explicitly closed by the program
     remains open until the program terminates.

   * If the form parameter ‘shared=no’ appears in the form string, the
     file can be opened or created with its own separate stream
     identifier, regardless of whether other files sharing the same
     external file are opened.  The exact effect depends on how the C
     stream routines handle multiple accesses to the same external files
     using separate streams.

   * If the form parameter ‘shared=yes’ appears in the form string for
     each of two or more files opened using the same full name, the same
     stream is shared between these files, and the semantics are as
     described in Ada Reference Manual, Section A.14.

When a program that opens multiple files with the same name is ported
from another Ada compiler to GNAT, the effect will be that ‘Use_Error’
is raised.

The documentation of the original compiler and the documentation of the
program should then be examined to determine if file sharing was
expected, and ‘shared=xxx’ parameters added to ‘Open’ and ‘Create’ calls
as required.

When a program is ported from GNAT to some other Ada compiler, no
special attention is required unless the ‘shared=xxx’ form parameter is
used in the program.  In this case, you must examine the documentation
of the new compiler to see if it supports the required file sharing
semantics, and form strings modified appropriately.  Of course it may be
the case that the program cannot be ported if the target compiler does
not support the required functionality.  The best approach in writing
portable code is to avoid file sharing (and hence the use of the
‘shared=xxx’ parameter in the form string) completely.

One common use of file sharing in Ada 83 is the use of instantiations of
Sequential_IO on the same file with different types, to achieve
heterogeneous input-output.  Although this approach will work in GNAT if
‘shared=yes’ is specified, it is preferable in Ada to use Stream_IO for
this purpose (using the stream attributes)


File: gnat_rm.info,  Node: Filenames encoding,  Next: File content encoding,  Prev: Shared Files,  Up: The Implementation of Standard I/O

11.11 Filenames encoding
========================

An encoding form parameter can be used to specify the filename encoding
‘encoding=xxx’.

   * If the form parameter ‘encoding=utf8’ appears in the form string,
     the filename must be encoded in UTF-8.

   * If the form parameter ‘encoding=8bits’ appears in the form string,
     the filename must be a standard 8bits string.

In the absence of a ‘encoding=xxx’ form parameter, the encoding is
controlled by the ‘GNAT_CODE_PAGE’ environment variable.  And if not set
‘utf8’ is assumed.

`CP_ACP'

     The current system Windows ANSI code page.

`CP_UTF8'

     UTF-8 encoding

This encoding form parameter is only supported on the Windows platform.
On the other Operating Systems the run-time is supporting UTF-8
natively.


File: gnat_rm.info,  Node: File content encoding,  Next: Open Modes,  Prev: Filenames encoding,  Up: The Implementation of Standard I/O

11.12 File content encoding
===========================

For text files it is possible to specify the encoding to use.  This is
controlled by the by the ‘GNAT_CCS_ENCODING’ environment variable.  And
if not set ‘TEXT’ is assumed.

The possible values are those supported on Windows:

`TEXT'

     Translated text mode

`WTEXT'

     Translated unicode encoding

`U16TEXT'

     Unicode 16-bit encoding

`U8TEXT'

     Unicode 8-bit encoding

This encoding is only supported on the Windows platform.


File: gnat_rm.info,  Node: Open Modes,  Next: Operations on C Streams,  Prev: File content encoding,  Up: The Implementation of Standard I/O

11.13 Open Modes
================

‘Open’ and ‘Create’ calls result in a call to ‘fopen’ using the mode
shown in the following table:

‘Open’ and ‘Create’ Call Modes

----------------------------------------------------------------------------
                                                     
                                 `OPEN'              `CREATE'
                                                     
                                                     
Append_File                      “r+”                “w+”
                                                     
                                                     
In_File                          “r”                 “w+”
                                                     
                                                     
Out_File (Direct_IO)             “r+”                “w”
                                                     
                                                     
Out_File (all other cases)       “w”                 “w”
                                                     
                                                     
Inout_File                       “r+”                “w+”
                                                     

If text file translation is required, then either ‘b’ or ‘t’ is added to
the mode, depending on the setting of Text.  Text file translation
refers to the mapping of CR/LF sequences in an external file to LF
characters internally.  This mapping only occurs in DOS and DOS-like
systems, and is not relevant to other systems.

A special case occurs with Stream_IO. As shown in the above table, the
file is initially opened in ‘r’ or ‘w’ mode for the ‘In_File’ and
‘Out_File’ cases.  If a ‘Set_Mode’ operation subsequently requires
switching from reading to writing or vice-versa, then the file is
reopened in ‘r+’ mode to permit the required operation.


File: gnat_rm.info,  Node: Operations on C Streams,  Next: Interfacing to C Streams,  Prev: Open Modes,  Up: The Implementation of Standard I/O

11.14 Operations on C Streams
=============================

The package ‘Interfaces.C_Streams’ provides an Ada program with direct
access to the C library functions for operations on C streams:

     package Interfaces.C_Streams is
       -- Note: the reason we do not use the types that are in
       -- Interfaces.C is that we want to avoid dragging in the
       -- code in this unit if possible.
       subtype chars is System.Address;
       -- Pointer to null-terminated array of characters
       subtype FILEs is System.Address;
       -- Corresponds to the C type FILE*
       subtype voids is System.Address;
       -- Corresponds to the C type void*
       subtype int is Integer;
       subtype long is Long_Integer;
       -- Note: the above types are subtypes deliberately, and it
       -- is part of this spec that the above correspondences are
       -- guaranteed.  This means that it is legitimate to, for
       -- example, use Integer instead of int.  We provide these
       -- synonyms for clarity, but in some cases it may be
       -- convenient to use the underlying types (for example to
       -- avoid an unnecessary dependency of a spec on the spec
       -- of this unit).
       type size_t is mod 2 ** Standard'Address_Size;
       NULL_Stream : constant FILEs;
       -- Value returned (NULL in C) to indicate an
       -- fdopen/fopen/tmpfile error
       ----------------------------------
       -- Constants Defined in stdio.h --
       ----------------------------------
       EOF : constant int;
       -- Used by a number of routines to indicate error or
       -- end of file
       IOFBF : constant int;
       IOLBF : constant int;
       IONBF : constant int;
       -- Used to indicate buffering mode for setvbuf call
       SEEK_CUR : constant int;
       SEEK_END : constant int;
       SEEK_SET : constant int;
       -- Used to indicate origin for fseek call
       function stdin return FILEs;
       function stdout return FILEs;
       function stderr return FILEs;
       -- Streams associated with standard files
       --------------------------
       -- Standard C functions --
       --------------------------
       -- The functions selected below are ones that are
       -- available in UNIX (but not necessarily in ANSI C).
       -- These are very thin interfaces
       -- which copy exactly the C headers.  For more
       -- documentation on these functions, see the Microsoft C
       -- "Run-Time Library Reference" (Microsoft Press, 1990,
       -- ISBN 1-55615-225-6), which includes useful information
       -- on system compatibility.
       procedure clearerr (stream : FILEs);
       function fclose (stream : FILEs) return int;
       function fdopen (handle : int; mode : chars) return FILEs;
       function feof (stream : FILEs) return int;
       function ferror (stream : FILEs) return int;
       function fflush (stream : FILEs) return int;
       function fgetc (stream : FILEs) return int;
       function fgets (strng : chars; n : int; stream : FILEs)
           return chars;
       function fileno (stream : FILEs) return int;
       function fopen (filename : chars; Mode : chars)
           return FILEs;
       -- Note: to maintain target independence, use
       -- text_translation_required, a boolean variable defined in
       -- a-sysdep.c to deal with the target dependent text
       -- translation requirement.  If this variable is set,
       -- then  b/t should be appended to the standard mode
       -- argument to set the text translation mode off or on
       -- as required.
       function fputc (C : int; stream : FILEs) return int;
       function fputs (Strng : chars; Stream : FILEs) return int;
       function fread
          (buffer : voids;
           size : size_t;
           count : size_t;
           stream : FILEs)
           return size_t;
       function freopen
          (filename : chars;
           mode : chars;
           stream : FILEs)
           return FILEs;
       function fseek
          (stream : FILEs;
           offset : long;
           origin : int)
           return int;
       function ftell (stream : FILEs) return long;
       function fwrite
          (buffer : voids;
           size : size_t;
           count : size_t;
           stream : FILEs)
           return size_t;
       function isatty (handle : int) return int;
       procedure mktemp (template : chars);
       -- The return value (which is just a pointer to template)
       -- is discarded
       procedure rewind (stream : FILEs);
       function rmtmp return int;
       function setvbuf
          (stream : FILEs;
           buffer : chars;
           mode : int;
           size : size_t)
           return int;

       function tmpfile return FILEs;
       function ungetc (c : int; stream : FILEs) return int;
       function unlink (filename : chars) return int;
       ---------------------
       -- Extra functions --
       ---------------------
       -- These functions supply slightly thicker bindings than
       -- those above.  They are derived from functions in the
       -- C Run-Time Library, but may do a bit more work than
       -- just directly calling one of the Library functions.
       function is_regular_file (handle : int) return int;
       -- Tests if given handle is for a regular file (result 1)
       -- or for a non-regular file (pipe or device, result 0).
       ---------------------------------
       -- Control of Text/Binary Mode --
       ---------------------------------
       -- If text_translation_required is true, then the following
       -- functions may be used to dynamically switch a file from
       -- binary to text mode or vice versa.  These functions have
       -- no effect if text_translation_required is false (i.e., in
       -- normal UNIX mode).  Use fileno to get a stream handle.
       procedure set_binary_mode (handle : int);
       procedure set_text_mode (handle : int);
       ----------------------------
       -- Full Path Name support --
       ----------------------------
       procedure full_name (nam : chars; buffer : chars);
       -- Given a NUL terminated string representing a file
       -- name, returns in buffer a NUL terminated string
       -- representing the full path name for the file name.
       -- On systems where it is relevant the   drive is also
       -- part of the full path name.  It is the responsibility
       -- of the caller to pass an actual parameter for buffer
       -- that is big enough for any full path name.  Use
       -- max_path_len given below as the size of buffer.
       max_path_len : integer;
       -- Maximum length of an allowable full path name on the
       -- system, including a terminating NUL character.
     end Interfaces.C_Streams;


File: gnat_rm.info,  Node: Interfacing to C Streams,  Prev: Operations on C Streams,  Up: The Implementation of Standard I/O

11.15 Interfacing to C Streams
==============================

The packages in this section permit interfacing Ada files to C Stream
operations.

     with Interfaces.C_Streams;
     package Ada.Sequential_IO.C_Streams is
        function C_Stream (F : File_Type)
           return Interfaces.C_Streams.FILEs;
        procedure Open
          (File : in out File_Type;
           Mode : in File_Mode;
           C_Stream : in Interfaces.C_Streams.FILEs;
           Form : in String := "");
     end Ada.Sequential_IO.C_Streams;

      with Interfaces.C_Streams;
      package Ada.Direct_IO.C_Streams is
         function C_Stream (F : File_Type)
            return Interfaces.C_Streams.FILEs;
         procedure Open
           (File : in out File_Type;
            Mode : in File_Mode;
            C_Stream : in Interfaces.C_Streams.FILEs;
            Form : in String := "");
      end Ada.Direct_IO.C_Streams;

      with Interfaces.C_Streams;
      package Ada.Text_IO.C_Streams is
         function C_Stream (F : File_Type)
            return Interfaces.C_Streams.FILEs;
         procedure Open
           (File : in out File_Type;
            Mode : in File_Mode;
            C_Stream : in Interfaces.C_Streams.FILEs;
            Form : in String := "");
      end Ada.Text_IO.C_Streams;

      with Interfaces.C_Streams;
      package Ada.Wide_Text_IO.C_Streams is
         function C_Stream (F : File_Type)
            return Interfaces.C_Streams.FILEs;
         procedure Open
           (File : in out File_Type;
            Mode : in File_Mode;
            C_Stream : in Interfaces.C_Streams.FILEs;
            Form : in String := "");
     end Ada.Wide_Text_IO.C_Streams;

      with Interfaces.C_Streams;
      package Ada.Wide_Wide_Text_IO.C_Streams is
         function C_Stream (F : File_Type)
            return Interfaces.C_Streams.FILEs;
         procedure Open
           (File : in out File_Type;
            Mode : in File_Mode;
            C_Stream : in Interfaces.C_Streams.FILEs;
            Form : in String := "");
     end Ada.Wide_Wide_Text_IO.C_Streams;

     with Interfaces.C_Streams;
     package Ada.Stream_IO.C_Streams is
        function C_Stream (F : File_Type)
           return Interfaces.C_Streams.FILEs;
        procedure Open
          (File : in out File_Type;
           Mode : in File_Mode;
           C_Stream : in Interfaces.C_Streams.FILEs;
           Form : in String := "");
     end Ada.Stream_IO.C_Streams;

In each of these six packages, the ‘C_Stream’ function obtains the
‘FILE’ pointer from a currently opened Ada file.  It is then possible to
use the ‘Interfaces.C_Streams’ package to operate on this stream, or the
stream can be passed to a C program which can operate on it directly.
Of course the program is responsible for ensuring that only appropriate
sequences of operations are executed.

One particular use of relevance to an Ada program is that the ‘setvbuf’
function can be used to control the buffering of the stream used by an
Ada file.  In the absence of such a call the standard default buffering
is used.

The ‘Open’ procedures in these packages open a file giving an existing C
Stream instead of a file name.  Typically this stream is imported from a
C program, allowing an Ada file to operate on an existing C file.


File: gnat_rm.info,  Node: The GNAT Library,  Next: Interfacing to Other Languages,  Prev: The Implementation of Standard I/O,  Up: Top

12 The GNAT Library
*******************

The GNAT library contains a number of general and special purpose
packages.  It represents functionality that the GNAT developers have
found useful, and which is made available to GNAT users.  The packages
described here are fully supported, and upwards compatibility will be
maintained in future releases, so you can use these facilities with the
confidence that the same functionality will be available in future
releases.

The chapter here simply gives a brief summary of the facilities
available.  The full documentation is found in the spec file for the
package.  The full sources of these library packages, including both
spec and body, are provided with all GNAT releases.  For example, to
find out the full specifications of the SPITBOL pattern matching
capability, including a full tutorial and extensive examples, look in
the ‘g-spipat.ads’ file in the library.

For each entry here, the package name (as it would appear in a ‘with’
clause) is given, followed by the name of the corresponding spec file in
parentheses.  The packages are children in four hierarchies, ‘Ada’,
‘Interfaces’, ‘System’, and ‘GNAT’, the latter being a GNAT-specific
hierarchy.

Note that an application program should only use packages in one of
these four hierarchies if the package is defined in the Ada Reference
Manual, or is listed in this section of the GNAT Programmers Reference
Manual.  All other units should be considered internal implementation
units and should not be directly ‘with’ed by application code.  The use
of a ‘with’ clause that references one of these internal implementation
units makes an application potentially dependent on changes in versions
of GNAT, and will generate a warning message.

* Menu:

* Ada.Characters.Latin_9 (a-chlat9.ads): Ada Characters Latin_9 a-chlat9 ads.
* Ada.Characters.Wide_Latin_1 (a-cwila1.ads): Ada Characters Wide_Latin_1 a-cwila1 ads.
* Ada.Characters.Wide_Latin_9 (a-cwila1.ads): Ada Characters Wide_Latin_9 a-cwila1 ads.
* Ada.Characters.Wide_Wide_Latin_1 (a-chzla1.ads): Ada Characters Wide_Wide_Latin_1 a-chzla1 ads.
* Ada.Characters.Wide_Wide_Latin_9 (a-chzla9.ads): Ada Characters Wide_Wide_Latin_9 a-chzla9 ads.
* Ada.Containers.Formal_Doubly_Linked_Lists (a-cfdlli.ads): Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads.
* Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads): Ada Containers Formal_Hashed_Maps a-cfhama ads.
* Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads): Ada Containers Formal_Hashed_Sets a-cfhase ads.
* Ada.Containers.Formal_Ordered_Maps (a-cforma.ads): Ada Containers Formal_Ordered_Maps a-cforma ads.
* Ada.Containers.Formal_Ordered_Sets (a-cforse.ads): Ada Containers Formal_Ordered_Sets a-cforse ads.
* Ada.Containers.Formal_Vectors (a-cofove.ads): Ada Containers Formal_Vectors a-cofove ads.
* Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads): Ada Containers Formal_Indefinite_Vectors a-cfinve ads.
* Ada.Containers.Functional_Vectors (a-cofuve.ads): Ada Containers Functional_Vectors a-cofuve ads.
* Ada.Containers.Functional_Sets (a-cofuse.ads): Ada Containers Functional_Sets a-cofuse ads.
* Ada.Containers.Functional_Maps (a-cofuma.ads): Ada Containers Functional_Maps a-cofuma ads.
* Ada.Containers.Bounded_Holders (a-coboho.ads): Ada Containers Bounded_Holders a-coboho ads.
* Ada.Command_Line.Environment (a-colien.ads): Ada Command_Line Environment a-colien ads.
* Ada.Command_Line.Remove (a-colire.ads): Ada Command_Line Remove a-colire ads.
* Ada.Command_Line.Response_File (a-clrefi.ads): Ada Command_Line Response_File a-clrefi ads.
* Ada.Direct_IO.C_Streams (a-diocst.ads): Ada Direct_IO C_Streams a-diocst ads.
* Ada.Exceptions.Is_Null_Occurrence (a-einuoc.ads): Ada Exceptions Is_Null_Occurrence a-einuoc ads.
* Ada.Exceptions.Last_Chance_Handler (a-elchha.ads): Ada Exceptions Last_Chance_Handler a-elchha ads.
* Ada.Exceptions.Traceback (a-exctra.ads): Ada Exceptions Traceback a-exctra ads.
* Ada.Sequential_IO.C_Streams (a-siocst.ads): Ada Sequential_IO C_Streams a-siocst ads.
* Ada.Streams.Stream_IO.C_Streams (a-ssicst.ads): Ada Streams Stream_IO C_Streams a-ssicst ads.
* Ada.Strings.Unbounded.Text_IO (a-suteio.ads): Ada Strings Unbounded Text_IO a-suteio ads.
* Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads): Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
* Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads): Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
* Ada.Task_Initialization (a-tasini.ads): Ada Task_Initialization a-tasini ads.
* Ada.Text_IO.C_Streams (a-tiocst.ads): Ada Text_IO C_Streams a-tiocst ads.
* Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads): Ada Text_IO Reset_Standard_Files a-tirsfi ads.
* Ada.Wide_Characters.Unicode (a-wichun.ads): Ada Wide_Characters Unicode a-wichun ads.
* Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads): Ada Wide_Text_IO C_Streams a-wtcstr ads.
* Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads): Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads.
* Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads): Ada Wide_Wide_Characters Unicode a-zchuni ads.
* Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads): Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads.
* Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads): Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads.
* GNAT.Altivec (g-altive.ads): GNAT Altivec g-altive ads.
* GNAT.Altivec.Conversions (g-altcon.ads): GNAT Altivec Conversions g-altcon ads.
* GNAT.Altivec.Vector_Operations (g-alveop.ads): GNAT Altivec Vector_Operations g-alveop ads.
* GNAT.Altivec.Vector_Types (g-alvety.ads): GNAT Altivec Vector_Types g-alvety ads.
* GNAT.Altivec.Vector_Views (g-alvevi.ads): GNAT Altivec Vector_Views g-alvevi ads.
* GNAT.Array_Split (g-arrspl.ads): GNAT Array_Split g-arrspl ads.
* GNAT.AWK (g-awk.ads): GNAT AWK g-awk ads.
* GNAT.Bind_Environment (g-binenv.ads): GNAT Bind_Environment g-binenv ads.
* GNAT.Branch_Prediction (g-brapre.ads): GNAT Branch_Prediction g-brapre ads.
* GNAT.Bounded_Buffers (g-boubuf.ads): GNAT Bounded_Buffers g-boubuf ads.
* GNAT.Bounded_Mailboxes (g-boumai.ads): GNAT Bounded_Mailboxes g-boumai ads.
* GNAT.Bubble_Sort (g-bubsor.ads): GNAT Bubble_Sort g-bubsor ads.
* GNAT.Bubble_Sort_A (g-busora.ads): GNAT Bubble_Sort_A g-busora ads.
* GNAT.Bubble_Sort_G (g-busorg.ads): GNAT Bubble_Sort_G g-busorg ads.
* GNAT.Byte_Order_Mark (g-byorma.ads): GNAT Byte_Order_Mark g-byorma ads.
* GNAT.Byte_Swapping (g-bytswa.ads): GNAT Byte_Swapping g-bytswa ads.
* GNAT.Calendar (g-calend.ads): GNAT Calendar g-calend ads.
* GNAT.Calendar.Time_IO (g-catiio.ads): GNAT Calendar Time_IO g-catiio ads.
* GNAT.CRC32 (g-crc32.ads): GNAT CRC32 g-crc32 ads.
* GNAT.Case_Util (g-casuti.ads): GNAT Case_Util g-casuti ads.
* GNAT.CGI (g-cgi.ads): GNAT CGI g-cgi ads.
* GNAT.CGI.Cookie (g-cgicoo.ads): GNAT CGI Cookie g-cgicoo ads.
* GNAT.CGI.Debug (g-cgideb.ads): GNAT CGI Debug g-cgideb ads.
* GNAT.Command_Line (g-comlin.ads): GNAT Command_Line g-comlin ads.
* GNAT.Compiler_Version (g-comver.ads): GNAT Compiler_Version g-comver ads.
* GNAT.Ctrl_C (g-ctrl_c.ads): GNAT Ctrl_C g-ctrl_c ads.
* GNAT.Current_Exception (g-curexc.ads): GNAT Current_Exception g-curexc ads.
* GNAT.Debug_Pools (g-debpoo.ads): GNAT Debug_Pools g-debpoo ads.
* GNAT.Debug_Utilities (g-debuti.ads): GNAT Debug_Utilities g-debuti ads.
* GNAT.Decode_String (g-decstr.ads): GNAT Decode_String g-decstr ads.
* GNAT.Decode_UTF8_String (g-deutst.ads): GNAT Decode_UTF8_String g-deutst ads.
* GNAT.Directory_Operations (g-dirope.ads): GNAT Directory_Operations g-dirope ads.
* GNAT.Directory_Operations.Iteration (g-diopit.ads): GNAT Directory_Operations Iteration g-diopit ads.
* GNAT.Dynamic_HTables (g-dynhta.ads): GNAT Dynamic_HTables g-dynhta ads.
* GNAT.Dynamic_Tables (g-dyntab.ads): GNAT Dynamic_Tables g-dyntab ads.
* GNAT.Encode_String (g-encstr.ads): GNAT Encode_String g-encstr ads.
* GNAT.Encode_UTF8_String (g-enutst.ads): GNAT Encode_UTF8_String g-enutst ads.
* GNAT.Exception_Actions (g-excact.ads): GNAT Exception_Actions g-excact ads.
* GNAT.Exception_Traces (g-exctra.ads): GNAT Exception_Traces g-exctra ads.
* GNAT.Exceptions (g-except.ads): GNAT Exceptions g-except ads.
* GNAT.Expect (g-expect.ads): GNAT Expect g-expect ads.
* GNAT.Expect.TTY (g-exptty.ads): GNAT Expect TTY g-exptty ads.
* GNAT.Float_Control (g-flocon.ads): GNAT Float_Control g-flocon ads.
* GNAT.Formatted_String (g-forstr.ads): GNAT Formatted_String g-forstr ads.
* GNAT.Heap_Sort (g-heasor.ads): GNAT Heap_Sort g-heasor ads.
* GNAT.Heap_Sort_A (g-hesora.ads): GNAT Heap_Sort_A g-hesora ads.
* GNAT.Heap_Sort_G (g-hesorg.ads): GNAT Heap_Sort_G g-hesorg ads.
* GNAT.HTable (g-htable.ads): GNAT HTable g-htable ads.
* GNAT.IO (g-io.ads): GNAT IO g-io ads.
* GNAT.IO_Aux (g-io_aux.ads): GNAT IO_Aux g-io_aux ads.
* GNAT.Lock_Files (g-locfil.ads): GNAT Lock_Files g-locfil ads.
* GNAT.MBBS_Discrete_Random (g-mbdira.ads): GNAT MBBS_Discrete_Random g-mbdira ads.
* GNAT.MBBS_Float_Random (g-mbflra.ads): GNAT MBBS_Float_Random g-mbflra ads.
* GNAT.MD5 (g-md5.ads): GNAT MD5 g-md5 ads.
* GNAT.Memory_Dump (g-memdum.ads): GNAT Memory_Dump g-memdum ads.
* GNAT.Most_Recent_Exception (g-moreex.ads): GNAT Most_Recent_Exception g-moreex ads.
* GNAT.OS_Lib (g-os_lib.ads): GNAT OS_Lib g-os_lib ads.
* GNAT.Perfect_Hash_Generators (g-pehage.ads): GNAT Perfect_Hash_Generators g-pehage ads.
* GNAT.Random_Numbers (g-rannum.ads): GNAT Random_Numbers g-rannum ads.
* GNAT.Regexp (g-regexp.ads): GNAT Regexp g-regexp ads.
* GNAT.Registry (g-regist.ads): GNAT Registry g-regist ads.
* GNAT.Regpat (g-regpat.ads): GNAT Regpat g-regpat ads.
* GNAT.Rewrite_Data (g-rewdat.ads): GNAT Rewrite_Data g-rewdat ads.
* GNAT.Secondary_Stack_Info (g-sestin.ads): GNAT Secondary_Stack_Info g-sestin ads.
* GNAT.Semaphores (g-semaph.ads): GNAT Semaphores g-semaph ads.
* GNAT.Serial_Communications (g-sercom.ads): GNAT Serial_Communications g-sercom ads.
* GNAT.SHA1 (g-sha1.ads): GNAT SHA1 g-sha1 ads.
* GNAT.SHA224 (g-sha224.ads): GNAT SHA224 g-sha224 ads.
* GNAT.SHA256 (g-sha256.ads): GNAT SHA256 g-sha256 ads.
* GNAT.SHA384 (g-sha384.ads): GNAT SHA384 g-sha384 ads.
* GNAT.SHA512 (g-sha512.ads): GNAT SHA512 g-sha512 ads.
* GNAT.Signals (g-signal.ads): GNAT Signals g-signal ads.
* GNAT.Sockets (g-socket.ads): GNAT Sockets g-socket ads.
* GNAT.Source_Info (g-souinf.ads): GNAT Source_Info g-souinf ads.
* GNAT.Spelling_Checker (g-speche.ads): GNAT Spelling_Checker g-speche ads.
* GNAT.Spelling_Checker_Generic (g-spchge.ads): GNAT Spelling_Checker_Generic g-spchge ads.
* GNAT.Spitbol.Patterns (g-spipat.ads): GNAT Spitbol Patterns g-spipat ads.
* GNAT.Spitbol (g-spitbo.ads): GNAT Spitbol g-spitbo ads.
* GNAT.Spitbol.Table_Boolean (g-sptabo.ads): GNAT Spitbol Table_Boolean g-sptabo ads.
* GNAT.Spitbol.Table_Integer (g-sptain.ads): GNAT Spitbol Table_Integer g-sptain ads.
* GNAT.Spitbol.Table_VString (g-sptavs.ads): GNAT Spitbol Table_VString g-sptavs ads.
* GNAT.SSE (g-sse.ads): GNAT SSE g-sse ads.
* GNAT.SSE.Vector_Types (g-ssvety.ads): GNAT SSE Vector_Types g-ssvety ads.
* GNAT.String_Hash (g-strhas.ads): GNAT String_Hash g-strhas ads.
* GNAT.Strings (g-string.ads): GNAT Strings g-string ads.
* GNAT.String_Split (g-strspl.ads): GNAT String_Split g-strspl ads.
* GNAT.Table (g-table.ads): GNAT Table g-table ads.
* GNAT.Task_Lock (g-tasloc.ads): GNAT Task_Lock g-tasloc ads.
* GNAT.Time_Stamp (g-timsta.ads): GNAT Time_Stamp g-timsta ads.
* GNAT.Threads (g-thread.ads): GNAT Threads g-thread ads.
* GNAT.Traceback (g-traceb.ads): GNAT Traceback g-traceb ads.
* GNAT.Traceback.Symbolic (g-trasym.ads): GNAT Traceback Symbolic g-trasym ads.
* GNAT.UTF_32 (g-table.ads): GNAT UTF_32 g-table ads.
* GNAT.Wide_Spelling_Checker (g-u3spch.ads): GNAT Wide_Spelling_Checker g-u3spch ads.
* GNAT.Wide_Spelling_Checker (g-wispch.ads): GNAT Wide_Spelling_Checker g-wispch ads.
* GNAT.Wide_String_Split (g-wistsp.ads): GNAT Wide_String_Split g-wistsp ads.
* GNAT.Wide_Wide_Spelling_Checker (g-zspche.ads): GNAT Wide_Wide_Spelling_Checker g-zspche ads.
* GNAT.Wide_Wide_String_Split (g-zistsp.ads): GNAT Wide_Wide_String_Split g-zistsp ads.
* Interfaces.C.Extensions (i-cexten.ads): Interfaces C Extensions i-cexten ads.
* Interfaces.C.Streams (i-cstrea.ads): Interfaces C Streams i-cstrea ads.
* Interfaces.Packed_Decimal (i-pacdec.ads): Interfaces Packed_Decimal i-pacdec ads.
* Interfaces.VxWorks (i-vxwork.ads): Interfaces VxWorks i-vxwork ads.
* Interfaces.VxWorks.Int_Connection (i-vxinco.ads): Interfaces VxWorks Int_Connection i-vxinco ads.
* Interfaces.VxWorks.IO (i-vxwoio.ads): Interfaces VxWorks IO i-vxwoio ads.
* System.Address_Image (s-addima.ads): System Address_Image s-addima ads.
* System.Assertions (s-assert.ads): System Assertions s-assert ads.
* System.Atomic_Counters (s-atocou.ads): System Atomic_Counters s-atocou ads.
* System.Memory (s-memory.ads): System Memory s-memory ads.
* System.Multiprocessors (s-multip.ads): System Multiprocessors s-multip ads.
* System.Multiprocessors.Dispatching_Domains (s-mudido.ads): System Multiprocessors Dispatching_Domains s-mudido ads.
* System.Partition_Interface (s-parint.ads): System Partition_Interface s-parint ads.
* System.Pool_Global (s-pooglo.ads): System Pool_Global s-pooglo ads.
* System.Pool_Local (s-pooloc.ads): System Pool_Local s-pooloc ads.
* System.Restrictions (s-restri.ads): System Restrictions s-restri ads.
* System.Rident (s-rident.ads): System Rident s-rident ads.
* System.Strings.Stream_Ops (s-ststop.ads): System Strings Stream_Ops s-ststop ads.
* System.Unsigned_Types (s-unstyp.ads): System Unsigned_Types s-unstyp ads.
* System.Wch_Cnv (s-wchcnv.ads): System Wch_Cnv s-wchcnv ads.
* System.Wch_Con (s-wchcon.ads): System Wch_Con s-wchcon ads.


File: gnat_rm.info,  Node: Ada Characters Latin_9 a-chlat9 ads,  Next: Ada Characters Wide_Latin_1 a-cwila1 ads,  Up: The GNAT Library

12.1 ‘Ada.Characters.Latin_9’ (‘a-chlat9.ads’)
==============================================

This child of ‘Ada.Characters’ provides a set of definitions
corresponding to those in the RM-defined package
‘Ada.Characters.Latin_1’ but with the few modifications required for
‘Latin-9’ The provision of such a package is specifically authorized by
the Ada Reference Manual (RM A.3.3(27)).


File: gnat_rm.info,  Node: Ada Characters Wide_Latin_1 a-cwila1 ads,  Next: Ada Characters Wide_Latin_9 a-cwila1 ads,  Prev: Ada Characters Latin_9 a-chlat9 ads,  Up: The GNAT Library

12.2 ‘Ada.Characters.Wide_Latin_1’ (‘a-cwila1.ads’)
===================================================

This child of ‘Ada.Characters’ provides a set of definitions
corresponding to those in the RM-defined package
‘Ada.Characters.Latin_1’ but with the types of the constants being
‘Wide_Character’ instead of ‘Character’.  The provision of such a
package is specifically authorized by the Ada Reference Manual (RM
A.3.3(27)).


File: gnat_rm.info,  Node: Ada Characters Wide_Latin_9 a-cwila1 ads,  Next: Ada Characters Wide_Wide_Latin_1 a-chzla1 ads,  Prev: Ada Characters Wide_Latin_1 a-cwila1 ads,  Up: The GNAT Library

12.3 ‘Ada.Characters.Wide_Latin_9’ (‘a-cwila1.ads’)
===================================================

This child of ‘Ada.Characters’ provides a set of definitions
corresponding to those in the GNAT defined package
‘Ada.Characters.Latin_9’ but with the types of the constants being
‘Wide_Character’ instead of ‘Character’.  The provision of such a
package is specifically authorized by the Ada Reference Manual (RM
A.3.3(27)).


File: gnat_rm.info,  Node: Ada Characters Wide_Wide_Latin_1 a-chzla1 ads,  Next: Ada Characters Wide_Wide_Latin_9 a-chzla9 ads,  Prev: Ada Characters Wide_Latin_9 a-cwila1 ads,  Up: The GNAT Library

12.4 ‘Ada.Characters.Wide_Wide_Latin_1’ (‘a-chzla1.ads’)
========================================================

This child of ‘Ada.Characters’ provides a set of definitions
corresponding to those in the RM-defined package
‘Ada.Characters.Latin_1’ but with the types of the constants being
‘Wide_Wide_Character’ instead of ‘Character’.  The provision of such a
package is specifically authorized by the Ada Reference Manual (RM
A.3.3(27)).


File: gnat_rm.info,  Node: Ada Characters Wide_Wide_Latin_9 a-chzla9 ads,  Next: Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads,  Prev: Ada Characters Wide_Wide_Latin_1 a-chzla1 ads,  Up: The GNAT Library

12.5 ‘Ada.Characters.Wide_Wide_Latin_9’ (‘a-chzla9.ads’)
========================================================

This child of ‘Ada.Characters’ provides a set of definitions
corresponding to those in the GNAT defined package
‘Ada.Characters.Latin_9’ but with the types of the constants being
‘Wide_Wide_Character’ instead of ‘Character’.  The provision of such a
package is specifically authorized by the Ada Reference Manual (RM
A.3.3(27)).


File: gnat_rm.info,  Node: Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads,  Next: Ada Containers Formal_Hashed_Maps a-cfhama ads,  Prev: Ada Characters Wide_Wide_Latin_9 a-chzla9 ads,  Up: The GNAT Library

12.6 ‘Ada.Containers.Formal_Doubly_Linked_Lists’ (‘a-cfdlli.ads’)
=================================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for doubly linked lists, meant to facilitate formal
verification of code using such containers.  The specification of this
unit is compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Hashed_Maps a-cfhama ads,  Next: Ada Containers Formal_Hashed_Sets a-cfhase ads,  Prev: Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads,  Up: The GNAT Library

12.7 ‘Ada.Containers.Formal_Hashed_Maps’ (‘a-cfhama.ads’)
=========================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for hashed maps, meant to facilitate formal verification
of code using such containers.  The specification of this unit is
compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Hashed_Sets a-cfhase ads,  Next: Ada Containers Formal_Ordered_Maps a-cforma ads,  Prev: Ada Containers Formal_Hashed_Maps a-cfhama ads,  Up: The GNAT Library

12.8 ‘Ada.Containers.Formal_Hashed_Sets’ (‘a-cfhase.ads’)
=========================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for hashed sets, meant to facilitate formal verification
of code using such containers.  The specification of this unit is
compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Ordered_Maps a-cforma ads,  Next: Ada Containers Formal_Ordered_Sets a-cforse ads,  Prev: Ada Containers Formal_Hashed_Sets a-cfhase ads,  Up: The GNAT Library

12.9 ‘Ada.Containers.Formal_Ordered_Maps’ (‘a-cforma.ads’)
==========================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for ordered maps, meant to facilitate formal verification
of code using such containers.  The specification of this unit is
compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Ordered_Sets a-cforse ads,  Next: Ada Containers Formal_Vectors a-cofove ads,  Prev: Ada Containers Formal_Ordered_Maps a-cforma ads,  Up: The GNAT Library

12.10 ‘Ada.Containers.Formal_Ordered_Sets’ (‘a-cforse.ads’)
===========================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for ordered sets, meant to facilitate formal verification
of code using such containers.  The specification of this unit is
compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Vectors a-cofove ads,  Next: Ada Containers Formal_Indefinite_Vectors a-cfinve ads,  Prev: Ada Containers Formal_Ordered_Sets a-cforse ads,  Up: The GNAT Library

12.11 ‘Ada.Containers.Formal_Vectors’ (‘a-cofove.ads’)
======================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for vectors, meant to facilitate formal verification of
code using such containers.  The specification of this unit is
compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Formal_Indefinite_Vectors a-cfinve ads,  Next: Ada Containers Functional_Vectors a-cofuve ads,  Prev: Ada Containers Formal_Vectors a-cofove ads,  Up: The GNAT Library

12.12 ‘Ada.Containers.Formal_Indefinite_Vectors’ (‘a-cfinve.ads’)
=================================================================

This child of ‘Ada.Containers’ defines a modified version of the Ada
2005 container for vectors of indefinite elements, meant to facilitate
formal verification of code using such containers.  The specification of
this unit is compatible with SPARK 2014.

Note that although this container was designed with formal verification
in mind, it may well be generally useful in that it is a simplified more
efficient version than the one defined in the standard.  In particular
it does not have the complex overhead required to detect cursor
tampering.


File: gnat_rm.info,  Node: Ada Containers Functional_Vectors a-cofuve ads,  Next: Ada Containers Functional_Sets a-cofuse ads,  Prev: Ada Containers Formal_Indefinite_Vectors a-cfinve ads,  Up: The GNAT Library

12.13 ‘Ada.Containers.Functional_Vectors’ (‘a-cofuve.ads’)
==========================================================

This child of ‘Ada.Containers’ defines immutable vectors.  These
containers are unbounded and may contain indefinite elements.
Furthermore, to be usable in every context, they are neither controlled
nor limited.  As they are functional, that is, no primitives are
provided which would allow modifying an existing container, these
containers can still be used safely.

Their API features functions creating new containers from existing ones.
As a consequence, these containers are highly inefficient.  They are
also memory consuming, as the allocated memory is not reclaimed when the
container is no longer referenced.  Thus, they should in general be used
in ghost code and annotations, so that they can be removed from the
final executable.  The specification of this unit is compatible with
SPARK 2014.


File: gnat_rm.info,  Node: Ada Containers Functional_Sets a-cofuse ads,  Next: Ada Containers Functional_Maps a-cofuma ads,  Prev: Ada Containers Functional_Vectors a-cofuve ads,  Up: The GNAT Library

12.14 ‘Ada.Containers.Functional_Sets’ (‘a-cofuse.ads’)
=======================================================

This child of ‘Ada.Containers’ defines immutable sets.  These containers
are unbounded and may contain indefinite elements.  Furthermore, to be
usable in every context, they are neither controlled nor limited.  As
they are functional, that is, no primitives are provided which would
allow modifying an existing container, these containers can still be
used safely.

Their API features functions creating new containers from existing ones.
As a consequence, these containers are highly inefficient.  They are
also memory consuming, as the allocated memory is not reclaimed when the
container is no longer referenced.  Thus, they should in general be used
in ghost code and annotations, so that they can be removed from the
final executable.  The specification of this unit is compatible with
SPARK 2014.


File: gnat_rm.info,  Node: Ada Containers Functional_Maps a-cofuma ads,  Next: Ada Containers Bounded_Holders a-coboho ads,  Prev: Ada Containers Functional_Sets a-cofuse ads,  Up: The GNAT Library

12.15 ‘Ada.Containers.Functional_Maps’ (‘a-cofuma.ads’)
=======================================================

This child of ‘Ada.Containers’ defines immutable maps.  These containers
are unbounded and may contain indefinite elements.  Furthermore, to be
usable in every context, they are neither controlled nor limited.  As
they are functional, that is, no primitives are provided which would
allow modifying an existing container, these containers can still be
used safely.

Their API features functions creating new containers from existing ones.
As a consequence, these containers are highly inefficient.  They are
also memory consuming, as the allocated memory is not reclaimed when the
container is no longer referenced.  Thus, they should in general be used
in ghost code and annotations, so that they can be removed from the
final executable.  The specification of this unit is compatible with
SPARK 2014.


File: gnat_rm.info,  Node: Ada Containers Bounded_Holders a-coboho ads,  Next: Ada Command_Line Environment a-colien ads,  Prev: Ada Containers Functional_Maps a-cofuma ads,  Up: The GNAT Library

12.16 ‘Ada.Containers.Bounded_Holders’ (‘a-coboho.ads’)
=======================================================

This child of ‘Ada.Containers’ defines a modified version of
Indefinite_Holders that avoids heap allocation.


File: gnat_rm.info,  Node: Ada Command_Line Environment a-colien ads,  Next: Ada Command_Line Remove a-colire ads,  Prev: Ada Containers Bounded_Holders a-coboho ads,  Up: The GNAT Library

12.17 ‘Ada.Command_Line.Environment’ (‘a-colien.ads’)
=====================================================

This child of ‘Ada.Command_Line’ provides a mechanism for obtaining
environment values on systems where this concept makes sense.


File: gnat_rm.info,  Node: Ada Command_Line Remove a-colire ads,  Next: Ada Command_Line Response_File a-clrefi ads,  Prev: Ada Command_Line Environment a-colien ads,  Up: The GNAT Library

12.18 ‘Ada.Command_Line.Remove’ (‘a-colire.ads’)
================================================

This child of ‘Ada.Command_Line’ provides a mechanism for logically
removing arguments from the argument list.  Once removed, an argument is
not visible to further calls on the subprograms in ‘Ada.Command_Line’
will not see the removed argument.


File: gnat_rm.info,  Node: Ada Command_Line Response_File a-clrefi ads,  Next: Ada Direct_IO C_Streams a-diocst ads,  Prev: Ada Command_Line Remove a-colire ads,  Up: The GNAT Library

12.19 ‘Ada.Command_Line.Response_File’ (‘a-clrefi.ads’)
=======================================================

This child of ‘Ada.Command_Line’ provides a mechanism facilities for
getting command line arguments from a text file, called a “response
file”.  Using a response file allow passing a set of arguments to an
executable longer than the maximum allowed by the system on the command
line.


File: gnat_rm.info,  Node: Ada Direct_IO C_Streams a-diocst ads,  Next: Ada Exceptions Is_Null_Occurrence a-einuoc ads,  Prev: Ada Command_Line Response_File a-clrefi ads,  Up: The GNAT Library

12.20 ‘Ada.Direct_IO.C_Streams’ (‘a-diocst.ads’)
================================================

This package provides subprograms that allow interfacing between C
streams and ‘Direct_IO’.  The stream identifier can be extracted from a
file opened on the Ada side, and an Ada file can be constructed from a
stream opened on the C side.


File: gnat_rm.info,  Node: Ada Exceptions Is_Null_Occurrence a-einuoc ads,  Next: Ada Exceptions Last_Chance_Handler a-elchha ads,  Prev: Ada Direct_IO C_Streams a-diocst ads,  Up: The GNAT Library

12.21 ‘Ada.Exceptions.Is_Null_Occurrence’ (‘a-einuoc.ads’)
==========================================================

This child subprogram provides a way of testing for the null exception
occurrence (‘Null_Occurrence’) without raising an exception.


File: gnat_rm.info,  Node: Ada Exceptions Last_Chance_Handler a-elchha ads,  Next: Ada Exceptions Traceback a-exctra ads,  Prev: Ada Exceptions Is_Null_Occurrence a-einuoc ads,  Up: The GNAT Library

12.22 ‘Ada.Exceptions.Last_Chance_Handler’ (‘a-elchha.ads’)
===========================================================

This child subprogram is used for handling otherwise unhandled
exceptions (hence the name last chance), and perform clean ups before
terminating the program.  Note that this subprogram never returns.


File: gnat_rm.info,  Node: Ada Exceptions Traceback a-exctra ads,  Next: Ada Sequential_IO C_Streams a-siocst ads,  Prev: Ada Exceptions Last_Chance_Handler a-elchha ads,  Up: The GNAT Library

12.23 ‘Ada.Exceptions.Traceback’ (‘a-exctra.ads’)
=================================================

This child package provides the subprogram (‘Tracebacks’) to give a
traceback array of addresses based on an exception occurrence.


File: gnat_rm.info,  Node: Ada Sequential_IO C_Streams a-siocst ads,  Next: Ada Streams Stream_IO C_Streams a-ssicst ads,  Prev: Ada Exceptions Traceback a-exctra ads,  Up: The GNAT Library

12.24 ‘Ada.Sequential_IO.C_Streams’ (‘a-siocst.ads’)
====================================================

This package provides subprograms that allow interfacing between C
streams and ‘Sequential_IO’.  The stream identifier can be extracted
from a file opened on the Ada side, and an Ada file can be constructed
from a stream opened on the C side.


File: gnat_rm.info,  Node: Ada Streams Stream_IO C_Streams a-ssicst ads,  Next: Ada Strings Unbounded Text_IO a-suteio ads,  Prev: Ada Sequential_IO C_Streams a-siocst ads,  Up: The GNAT Library

12.25 ‘Ada.Streams.Stream_IO.C_Streams’ (‘a-ssicst.ads’)
========================================================

This package provides subprograms that allow interfacing between C
streams and ‘Stream_IO’.  The stream identifier can be extracted from a
file opened on the Ada side, and an Ada file can be constructed from a
stream opened on the C side.


File: gnat_rm.info,  Node: Ada Strings Unbounded Text_IO a-suteio ads,  Next: Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads,  Prev: Ada Streams Stream_IO C_Streams a-ssicst ads,  Up: The GNAT Library

12.26 ‘Ada.Strings.Unbounded.Text_IO’ (‘a-suteio.ads’)
======================================================

This package provides subprograms for Text_IO for unbounded strings,
avoiding the necessity for an intermediate operation with ordinary
strings.


File: gnat_rm.info,  Node: Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads,  Next: Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads,  Prev: Ada Strings Unbounded Text_IO a-suteio ads,  Up: The GNAT Library

12.27 ‘Ada.Strings.Wide_Unbounded.Wide_Text_IO’ (‘a-swuwti.ads’)
================================================================

This package provides subprograms for Text_IO for unbounded wide
strings, avoiding the necessity for an intermediate operation with
ordinary wide strings.


File: gnat_rm.info,  Node: Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads,  Next: Ada Task_Initialization a-tasini ads,  Prev: Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads,  Up: The GNAT Library

12.28 ‘Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO’ (‘a-szuzti.ads’)
==========================================================================

This package provides subprograms for Text_IO for unbounded wide wide
strings, avoiding the necessity for an intermediate operation with
ordinary wide wide strings.


File: gnat_rm.info,  Node: Ada Task_Initialization a-tasini ads,  Next: Ada Text_IO C_Streams a-tiocst ads,  Prev: Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads,  Up: The GNAT Library

12.29 ‘Ada.Task_Initialization’ (‘a-tasini.ads’)
================================================

This package provides a way to set a global initialization handler that
is automatically invoked whenever a task is activated.  Handlers are
parameterless procedures.  Note that such a handler is only invoked for
those tasks activated after the handler is set.


File: gnat_rm.info,  Node: Ada Text_IO C_Streams a-tiocst ads,  Next: Ada Text_IO Reset_Standard_Files a-tirsfi ads,  Prev: Ada Task_Initialization a-tasini ads,  Up: The GNAT Library

12.30 ‘Ada.Text_IO.C_Streams’ (‘a-tiocst.ads’)
==============================================

This package provides subprograms that allow interfacing between C
streams and ‘Text_IO’.  The stream identifier can be extracted from a
file opened on the Ada side, and an Ada file can be constructed from a
stream opened on the C side.


File: gnat_rm.info,  Node: Ada Text_IO Reset_Standard_Files a-tirsfi ads,  Next: Ada Wide_Characters Unicode a-wichun ads,  Prev: Ada Text_IO C_Streams a-tiocst ads,  Up: The GNAT Library

12.31 ‘Ada.Text_IO.Reset_Standard_Files’ (‘a-tirsfi.ads’)
=========================================================

This procedure is used to reset the status of the standard files used by
Ada.Text_IO. This is useful in a situation (such as a restart in an
embedded application) where the status of the files may change during
execution (for example a standard input file may be redefined to be
interactive).


File: gnat_rm.info,  Node: Ada Wide_Characters Unicode a-wichun ads,  Next: Ada Wide_Text_IO C_Streams a-wtcstr ads,  Prev: Ada Text_IO Reset_Standard_Files a-tirsfi ads,  Up: The GNAT Library

12.32 ‘Ada.Wide_Characters.Unicode’ (‘a-wichun.ads’)
====================================================

This package provides subprograms that allow categorization of
Wide_Character values according to Unicode categories.


File: gnat_rm.info,  Node: Ada Wide_Text_IO C_Streams a-wtcstr ads,  Next: Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads,  Prev: Ada Wide_Characters Unicode a-wichun ads,  Up: The GNAT Library

12.33 ‘Ada.Wide_Text_IO.C_Streams’ (‘a-wtcstr.ads’)
===================================================

This package provides subprograms that allow interfacing between C
streams and ‘Wide_Text_IO’.  The stream identifier can be extracted from
a file opened on the Ada side, and an Ada file can be constructed from a
stream opened on the C side.


File: gnat_rm.info,  Node: Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads,  Next: Ada Wide_Wide_Characters Unicode a-zchuni ads,  Prev: Ada Wide_Text_IO C_Streams a-wtcstr ads,  Up: The GNAT Library

12.34 ‘Ada.Wide_Text_IO.Reset_Standard_Files’ (‘a-wrstfi.ads’)
==============================================================

This procedure is used to reset the status of the standard files used by
Ada.Wide_Text_IO. This is useful in a situation (such as a restart in an
embedded application) where the status of the files may change during
execution (for example a standard input file may be redefined to be
interactive).


File: gnat_rm.info,  Node: Ada Wide_Wide_Characters Unicode a-zchuni ads,  Next: Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads,  Prev: Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads,  Up: The GNAT Library

12.35 ‘Ada.Wide_Wide_Characters.Unicode’ (‘a-zchuni.ads’)
=========================================================

This package provides subprograms that allow categorization of
Wide_Wide_Character values according to Unicode categories.


File: gnat_rm.info,  Node: Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads,  Next: Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads,  Prev: Ada Wide_Wide_Characters Unicode a-zchuni ads,  Up: The GNAT Library

12.36 ‘Ada.Wide_Wide_Text_IO.C_Streams’ (‘a-ztcstr.ads’)
========================================================

This package provides subprograms that allow interfacing between C
streams and ‘Wide_Wide_Text_IO’.  The stream identifier can be extracted
from a file opened on the Ada side, and an Ada file can be constructed
from a stream opened on the C side.


File: gnat_rm.info,  Node: Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads,  Next: GNAT Altivec g-altive ads,  Prev: Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads,  Up: The GNAT Library

12.37 ‘Ada.Wide_Wide_Text_IO.Reset_Standard_Files’ (‘a-zrstfi.ads’)
===================================================================

This procedure is used to reset the status of the standard files used by
Ada.Wide_Wide_Text_IO. This is useful in a situation (such as a restart
in an embedded application) where the status of the files may change
during execution (for example a standard input file may be redefined to
be interactive).


File: gnat_rm.info,  Node: GNAT Altivec g-altive ads,  Next: GNAT Altivec Conversions g-altcon ads,  Prev: Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads,  Up: The GNAT Library

12.38 ‘GNAT.Altivec’ (‘g-altive.ads’)
=====================================

This is the root package of the GNAT AltiVec binding.  It provides
definitions of constants and types common to all the versions of the
binding.


File: gnat_rm.info,  Node: GNAT Altivec Conversions g-altcon ads,  Next: GNAT Altivec Vector_Operations g-alveop ads,  Prev: GNAT Altivec g-altive ads,  Up: The GNAT Library

12.39 ‘GNAT.Altivec.Conversions’ (‘g-altcon.ads’)
=================================================

This package provides the Vector/View conversion routines.


File: gnat_rm.info,  Node: GNAT Altivec Vector_Operations g-alveop ads,  Next: GNAT Altivec Vector_Types g-alvety ads,  Prev: GNAT Altivec Conversions g-altcon ads,  Up: The GNAT Library

12.40 ‘GNAT.Altivec.Vector_Operations’ (‘g-alveop.ads’)
=======================================================

This package exposes the Ada interface to the AltiVec operations on
vector objects.  A soft emulation is included by default in the GNAT
library.  The hard binding is provided as a separate package.  This unit
is common to both bindings.


File: gnat_rm.info,  Node: GNAT Altivec Vector_Types g-alvety ads,  Next: GNAT Altivec Vector_Views g-alvevi ads,  Prev: GNAT Altivec Vector_Operations g-alveop ads,  Up: The GNAT Library

12.41 ‘GNAT.Altivec.Vector_Types’ (‘g-alvety.ads’)
==================================================

This package exposes the various vector types part of the Ada binding to
AltiVec facilities.


File: gnat_rm.info,  Node: GNAT Altivec Vector_Views g-alvevi ads,  Next: GNAT Array_Split g-arrspl ads,  Prev: GNAT Altivec Vector_Types g-alvety ads,  Up: The GNAT Library

12.42 ‘GNAT.Altivec.Vector_Views’ (‘g-alvevi.ads’)
==================================================

This package provides public ‘View’ data types from/to which private
vector representations can be converted via GNAT.Altivec.Conversions.
This allows convenient access to individual vector elements and provides
a simple way to initialize vector objects.


File: gnat_rm.info,  Node: GNAT Array_Split g-arrspl ads,  Next: GNAT AWK g-awk ads,  Prev: GNAT Altivec Vector_Views g-alvevi ads,  Up: The GNAT Library

12.43 ‘GNAT.Array_Split’ (‘g-arrspl.ads’)
=========================================

Useful array-manipulation routines: given a set of separators, split an
array wherever the separators appear, and provide direct access to the
resulting slices.


File: gnat_rm.info,  Node: GNAT AWK g-awk ads,  Next: GNAT Bind_Environment g-binenv ads,  Prev: GNAT Array_Split g-arrspl ads,  Up: The GNAT Library

12.44 ‘GNAT.AWK’ (‘g-awk.ads’)
==============================

Provides AWK-like parsing functions, with an easy interface for parsing
one or more files containing formatted data.  The file is viewed as a
database where each record is a line and a field is a data element in
this line.


File: gnat_rm.info,  Node: GNAT Bind_Environment g-binenv ads,  Next: GNAT Branch_Prediction g-brapre ads,  Prev: GNAT AWK g-awk ads,  Up: The GNAT Library

12.45 ‘GNAT.Bind_Environment’ (‘g-binenv.ads’)
==============================================

Provides access to key=value associations captured at bind time.  These
associations can be specified using the ‘-V’ binder command line switch.


File: gnat_rm.info,  Node: GNAT Branch_Prediction g-brapre ads,  Next: GNAT Bounded_Buffers g-boubuf ads,  Prev: GNAT Bind_Environment g-binenv ads,  Up: The GNAT Library

12.46 ‘GNAT.Branch_Prediction’ (‘g-brapre.ads’)
===============================================

Provides routines giving hints to the branch predictor of the code
generator.


File: gnat_rm.info,  Node: GNAT Bounded_Buffers g-boubuf ads,  Next: GNAT Bounded_Mailboxes g-boumai ads,  Prev: GNAT Branch_Prediction g-brapre ads,  Up: The GNAT Library

12.47 ‘GNAT.Bounded_Buffers’ (‘g-boubuf.ads’)
=============================================

Provides a concurrent generic bounded buffer abstraction.  Instances are
useful directly or as parts of the implementations of other
abstractions, such as mailboxes.


File: gnat_rm.info,  Node: GNAT Bounded_Mailboxes g-boumai ads,  Next: GNAT Bubble_Sort g-bubsor ads,  Prev: GNAT Bounded_Buffers g-boubuf ads,  Up: The GNAT Library

12.48 ‘GNAT.Bounded_Mailboxes’ (‘g-boumai.ads’)
===============================================

Provides a thread-safe asynchronous intertask mailbox communication
facility.


File: gnat_rm.info,  Node: GNAT Bubble_Sort g-bubsor ads,  Next: GNAT Bubble_Sort_A g-busora ads,  Prev: GNAT Bounded_Mailboxes g-boumai ads,  Up: The GNAT Library

12.49 ‘GNAT.Bubble_Sort’ (‘g-bubsor.ads’)
=========================================

Provides a general implementation of bubble sort usable for sorting
arbitrary data items.  Exchange and comparison procedures are provided
by passing access-to-procedure values.


File: gnat_rm.info,  Node: GNAT Bubble_Sort_A g-busora ads,  Next: GNAT Bubble_Sort_G g-busorg ads,  Prev: GNAT Bubble_Sort g-bubsor ads,  Up: The GNAT Library

12.50 ‘GNAT.Bubble_Sort_A’ (‘g-busora.ads’)
===========================================

Provides a general implementation of bubble sort usable for sorting
arbitrary data items.  Move and comparison procedures are provided by
passing access-to-procedure values.  This is an older version, retained
for compatibility.  Usually ‘GNAT.Bubble_Sort’ will be preferable.


File: gnat_rm.info,  Node: GNAT Bubble_Sort_G g-busorg ads,  Next: GNAT Byte_Order_Mark g-byorma ads,  Prev: GNAT Bubble_Sort_A g-busora ads,  Up: The GNAT Library

12.51 ‘GNAT.Bubble_Sort_G’ (‘g-busorg.ads’)
===========================================

Similar to ‘Bubble_Sort_A’ except that the move and sorting procedures
are provided as generic parameters, this improves efficiency, especially
if the procedures can be inlined, at the expense of duplicating code for
multiple instantiations.


File: gnat_rm.info,  Node: GNAT Byte_Order_Mark g-byorma ads,  Next: GNAT Byte_Swapping g-bytswa ads,  Prev: GNAT Bubble_Sort_G g-busorg ads,  Up: The GNAT Library

12.52 ‘GNAT.Byte_Order_Mark’ (‘g-byorma.ads’)
=============================================

Provides a routine which given a string, reads the start of the string
to see whether it is one of the standard byte order marks (BOM’s) which
signal the encoding of the string.  The routine includes detection of
special XML sequences for various UCS input formats.


File: gnat_rm.info,  Node: GNAT Byte_Swapping g-bytswa ads,  Next: GNAT Calendar g-calend ads,  Prev: GNAT Byte_Order_Mark g-byorma ads,  Up: The GNAT Library

12.53 ‘GNAT.Byte_Swapping’ (‘g-bytswa.ads’)
===========================================

General routines for swapping the bytes in 2-, 4-, and 8-byte
quantities.  Machine-specific implementations are available in some
cases.


File: gnat_rm.info,  Node: GNAT Calendar g-calend ads,  Next: GNAT Calendar Time_IO g-catiio ads,  Prev: GNAT Byte_Swapping g-bytswa ads,  Up: The GNAT Library

12.54 ‘GNAT.Calendar’ (‘g-calend.ads’)
======================================

Extends the facilities provided by ‘Ada.Calendar’ to include handling of
days of the week, an extended ‘Split’ and ‘Time_Of’ capability.  Also
provides conversion of ‘Ada.Calendar.Time’ values to and from the C
‘timeval’ format.


File: gnat_rm.info,  Node: GNAT Calendar Time_IO g-catiio ads,  Next: GNAT CRC32 g-crc32 ads,  Prev: GNAT Calendar g-calend ads,  Up: The GNAT Library

12.55 ‘GNAT.Calendar.Time_IO’ (‘g-catiio.ads’)
==============================================


File: gnat_rm.info,  Node: GNAT CRC32 g-crc32 ads,  Next: GNAT Case_Util g-casuti ads,  Prev: GNAT Calendar Time_IO g-catiio ads,  Up: The GNAT Library

12.56 ‘GNAT.CRC32’ (‘g-crc32.ads’)
==================================

This package implements the CRC-32 algorithm.  For a full description of
this algorithm see `Computation of Cyclic Redundancy Checks via Table
Look-Up', ‘Communications of the ACM’, Vol.  31 No.  8, pp.  1008-1013,
Aug.  1988.  Sarwate, D.V.


File: gnat_rm.info,  Node: GNAT Case_Util g-casuti ads,  Next: GNAT CGI g-cgi ads,  Prev: GNAT CRC32 g-crc32 ads,  Up: The GNAT Library

12.57 ‘GNAT.Case_Util’ (‘g-casuti.ads’)
=======================================

A set of simple routines for handling upper and lower casing of strings
without the overhead of the full casing tables in
‘Ada.Characters.Handling’.


File: gnat_rm.info,  Node: GNAT CGI g-cgi ads,  Next: GNAT CGI Cookie g-cgicoo ads,  Prev: GNAT Case_Util g-casuti ads,  Up: The GNAT Library

12.58 ‘GNAT.CGI’ (‘g-cgi.ads’)
==============================

This is a package for interfacing a GNAT program with a Web server via
the Common Gateway Interface (CGI). Basically this package parses the
CGI parameters, which are a set of key/value pairs sent by the Web
server.  It builds a table whose index is the key and provides some
services to deal with this table.


File: gnat_rm.info,  Node: GNAT CGI Cookie g-cgicoo ads,  Next: GNAT CGI Debug g-cgideb ads,  Prev: GNAT CGI g-cgi ads,  Up: The GNAT Library

12.59 ‘GNAT.CGI.Cookie’ (‘g-cgicoo.ads’)
========================================

This is a package to interface a GNAT program with a Web server via the
Common Gateway Interface (CGI). It exports services to deal with Web
cookies (piece of information kept in the Web client software).


File: gnat_rm.info,  Node: GNAT CGI Debug g-cgideb ads,  Next: GNAT Command_Line g-comlin ads,  Prev: GNAT CGI Cookie g-cgicoo ads,  Up: The GNAT Library

12.60 ‘GNAT.CGI.Debug’ (‘g-cgideb.ads’)
=======================================

This is a package to help debugging CGI (Common Gateway Interface)
programs written in Ada.


File: gnat_rm.info,  Node: GNAT Command_Line g-comlin ads,  Next: GNAT Compiler_Version g-comver ads,  Prev: GNAT CGI Debug g-cgideb ads,  Up: The GNAT Library

12.61 ‘GNAT.Command_Line’ (‘g-comlin.ads’)
==========================================

Provides a high level interface to ‘Ada.Command_Line’ facilities,
including the ability to scan for named switches with optional
parameters and expand file names using wildcard notations.


File: gnat_rm.info,  Node: GNAT Compiler_Version g-comver ads,  Next: GNAT Ctrl_C g-ctrl_c ads,  Prev: GNAT Command_Line g-comlin ads,  Up: The GNAT Library

12.62 ‘GNAT.Compiler_Version’ (‘g-comver.ads’)
==============================================

Provides a routine for obtaining the version of the compiler used to
compile the program.  More accurately this is the version of the binder
used to bind the program (this will normally be the same as the version
of the compiler if a consistent tool set is used to compile all units of
a partition).


File: gnat_rm.info,  Node: GNAT Ctrl_C g-ctrl_c ads,  Next: GNAT Current_Exception g-curexc ads,  Prev: GNAT Compiler_Version g-comver ads,  Up: The GNAT Library

12.63 ‘GNAT.Ctrl_C’ (‘g-ctrl_c.ads’)
====================================

Provides a simple interface to handle Ctrl-C keyboard events.


File: gnat_rm.info,  Node: GNAT Current_Exception g-curexc ads,  Next: GNAT Debug_Pools g-debpoo ads,  Prev: GNAT Ctrl_C g-ctrl_c ads,  Up: The GNAT Library

12.64 ‘GNAT.Current_Exception’ (‘g-curexc.ads’)
===============================================

Provides access to information on the current exception that has been
raised without the need for using the Ada 95 / Ada 2005 exception choice
parameter specification syntax.  This is particularly useful in
simulating typical facilities for obtaining information about exceptions
provided by Ada 83 compilers.


File: gnat_rm.info,  Node: GNAT Debug_Pools g-debpoo ads,  Next: GNAT Debug_Utilities g-debuti ads,  Prev: GNAT Current_Exception g-curexc ads,  Up: The GNAT Library

12.65 ‘GNAT.Debug_Pools’ (‘g-debpoo.ads’)
=========================================

Provide a debugging storage pools that helps tracking memory corruption
problems.  See ‘The GNAT Debug_Pool Facility’ section in the ‘GNAT
User’s Guide’.


File: gnat_rm.info,  Node: GNAT Debug_Utilities g-debuti ads,  Next: GNAT Decode_String g-decstr ads,  Prev: GNAT Debug_Pools g-debpoo ads,  Up: The GNAT Library

12.66 ‘GNAT.Debug_Utilities’ (‘g-debuti.ads’)
=============================================

Provides a few useful utilities for debugging purposes, including
conversion to and from string images of address values.  Supports both C
and Ada formats for hexadecimal literals.


File: gnat_rm.info,  Node: GNAT Decode_String g-decstr ads,  Next: GNAT Decode_UTF8_String g-deutst ads,  Prev: GNAT Debug_Utilities g-debuti ads,  Up: The GNAT Library

12.67 ‘GNAT.Decode_String’ (‘g-decstr.ads’)
===========================================

A generic package providing routines for decoding wide character and
wide wide character strings encoded as sequences of 8-bit characters
using a specified encoding method.  Includes validation routines, and
also routines for stepping to next or previous encoded character in an
encoded string.  Useful in conjunction with Unicode character coding.
Note there is a preinstantiation for UTF-8.  See next entry.


File: gnat_rm.info,  Node: GNAT Decode_UTF8_String g-deutst ads,  Next: GNAT Directory_Operations g-dirope ads,  Prev: GNAT Decode_String g-decstr ads,  Up: The GNAT Library

12.68 ‘GNAT.Decode_UTF8_String’ (‘g-deutst.ads’)
================================================

A preinstantiation of GNAT.Decode_Strings for UTF-8 encoding.


File: gnat_rm.info,  Node: GNAT Directory_Operations g-dirope ads,  Next: GNAT Directory_Operations Iteration g-diopit ads,  Prev: GNAT Decode_UTF8_String g-deutst ads,  Up: The GNAT Library

12.69 ‘GNAT.Directory_Operations’ (‘g-dirope.ads’)
==================================================

Provides a set of routines for manipulating directories, including
changing the current directory, making new directories, and scanning the
files in a directory.


File: gnat_rm.info,  Node: GNAT Directory_Operations Iteration g-diopit ads,  Next: GNAT Dynamic_HTables g-dynhta ads,  Prev: GNAT Directory_Operations g-dirope ads,  Up: The GNAT Library

12.70 ‘GNAT.Directory_Operations.Iteration’ (‘g-diopit.ads’)
============================================================

A child unit of GNAT.Directory_Operations providing additional
operations for iterating through directories.


File: gnat_rm.info,  Node: GNAT Dynamic_HTables g-dynhta ads,  Next: GNAT Dynamic_Tables g-dyntab ads,  Prev: GNAT Directory_Operations Iteration g-diopit ads,  Up: The GNAT Library

12.71 ‘GNAT.Dynamic_HTables’ (‘g-dynhta.ads’)
=============================================

A generic implementation of hash tables that can be used to hash
arbitrary data.  Provided in two forms, a simple form with built in hash
functions, and a more complex form in which the hash function is
supplied.

This package provides a facility similar to that of ‘GNAT.HTable’,
except that this package declares a type that can be used to define
dynamic instances of the hash table, while an instantiation of
‘GNAT.HTable’ creates a single instance of the hash table.


File: gnat_rm.info,  Node: GNAT Dynamic_Tables g-dyntab ads,  Next: GNAT Encode_String g-encstr ads,  Prev: GNAT Dynamic_HTables g-dynhta ads,  Up: The GNAT Library

12.72 ‘GNAT.Dynamic_Tables’ (‘g-dyntab.ads’)
============================================

A generic package providing a single dimension array abstraction where
the length of the array can be dynamically modified.

This package provides a facility similar to that of ‘GNAT.Table’, except
that this package declares a type that can be used to define dynamic
instances of the table, while an instantiation of ‘GNAT.Table’ creates a
single instance of the table type.


File: gnat_rm.info,  Node: GNAT Encode_String g-encstr ads,  Next: GNAT Encode_UTF8_String g-enutst ads,  Prev: GNAT Dynamic_Tables g-dyntab ads,  Up: The GNAT Library

12.73 ‘GNAT.Encode_String’ (‘g-encstr.ads’)
===========================================

A generic package providing routines for encoding wide character and
wide wide character strings as sequences of 8-bit characters using a
specified encoding method.  Useful in conjunction with Unicode character
coding.  Note there is a preinstantiation for UTF-8.  See next entry.


File: gnat_rm.info,  Node: GNAT Encode_UTF8_String g-enutst ads,  Next: GNAT Exception_Actions g-excact ads,  Prev: GNAT Encode_String g-encstr ads,  Up: The GNAT Library

12.74 ‘GNAT.Encode_UTF8_String’ (‘g-enutst.ads’)
================================================

A preinstantiation of GNAT.Encode_Strings for UTF-8 encoding.


File: gnat_rm.info,  Node: GNAT Exception_Actions g-excact ads,  Next: GNAT Exception_Traces g-exctra ads,  Prev: GNAT Encode_UTF8_String g-enutst ads,  Up: The GNAT Library

12.75 ‘GNAT.Exception_Actions’ (‘g-excact.ads’)
===============================================

Provides callbacks when an exception is raised.  Callbacks can be
registered for specific exceptions, or when any exception is raised.
This can be used for instance to force a core dump to ease debugging.


File: gnat_rm.info,  Node: GNAT Exception_Traces g-exctra ads,  Next: GNAT Exceptions g-except ads,  Prev: GNAT Exception_Actions g-excact ads,  Up: The GNAT Library

12.76 ‘GNAT.Exception_Traces’ (‘g-exctra.ads’)
==============================================

Provides an interface allowing to control automatic output upon
exception occurrences.


File: gnat_rm.info,  Node: GNAT Exceptions g-except ads,  Next: GNAT Expect g-expect ads,  Prev: GNAT Exception_Traces g-exctra ads,  Up: The GNAT Library

12.77 ‘GNAT.Exceptions’ (‘g-except.ads’)
========================================

Normally it is not possible to raise an exception with a message from a
subprogram in a pure package, since the necessary types and subprograms
are in ‘Ada.Exceptions’ which is not a pure unit.  ‘GNAT.Exceptions’
provides a facility for getting around this limitation for a few
predefined exceptions, and for example allow raising ‘Constraint_Error’
with a message from a pure subprogram.


File: gnat_rm.info,  Node: GNAT Expect g-expect ads,  Next: GNAT Expect TTY g-exptty ads,  Prev: GNAT Exceptions g-except ads,  Up: The GNAT Library

12.78 ‘GNAT.Expect’ (‘g-expect.ads’)
====================================

Provides a set of subprograms similar to what is available with the
standard Tcl Expect tool.  It allows you to easily spawn and communicate
with an external process.  You can send commands or inputs to the
process, and compare the output with some expected regular expression.
Currently ‘GNAT.Expect’ is implemented on all native GNAT ports.  It is
not implemented for cross ports, and in particular is not implemented
for VxWorks or LynxOS.


File: gnat_rm.info,  Node: GNAT Expect TTY g-exptty ads,  Next: GNAT Float_Control g-flocon ads,  Prev: GNAT Expect g-expect ads,  Up: The GNAT Library

12.79 ‘GNAT.Expect.TTY’ (‘g-exptty.ads’)
========================================

As GNAT.Expect but using pseudo-terminal.  Currently ‘GNAT.Expect.TTY’
is implemented on all native GNAT ports.  It is not implemented for
cross ports, and in particular is not implemented for VxWorks or LynxOS.


File: gnat_rm.info,  Node: GNAT Float_Control g-flocon ads,  Next: GNAT Formatted_String g-forstr ads,  Prev: GNAT Expect TTY g-exptty ads,  Up: The GNAT Library

12.80 ‘GNAT.Float_Control’ (‘g-flocon.ads’)
===========================================

Provides an interface for resetting the floating-point processor into
the mode required for correct semantic operation in Ada.  Some third
party library calls may cause this mode to be modified, and the Reset
procedure in this package can be used to reestablish the required mode.


File: gnat_rm.info,  Node: GNAT Formatted_String g-forstr ads,  Next: GNAT Heap_Sort g-heasor ads,  Prev: GNAT Float_Control g-flocon ads,  Up: The GNAT Library

12.81 ‘GNAT.Formatted_String’ (‘g-forstr.ads’)
==============================================

Provides support for C/C++ printf() formatted strings.  The format is
copied from the printf() routine and should therefore gives identical
output.  Some generic routines are provided to be able to use types
derived from Integer, Float or enumerations as values for the formatted
string.


File: gnat_rm.info,  Node: GNAT Heap_Sort g-heasor ads,  Next: GNAT Heap_Sort_A g-hesora ads,  Prev: GNAT Formatted_String g-forstr ads,  Up: The GNAT Library

12.82 ‘GNAT.Heap_Sort’ (‘g-heasor.ads’)
=======================================

Provides a general implementation of heap sort usable for sorting
arbitrary data items.  Exchange and comparison procedures are provided
by passing access-to-procedure values.  The algorithm used is a modified
heap sort that performs approximately N*log(N) comparisons in the worst
case.


File: gnat_rm.info,  Node: GNAT Heap_Sort_A g-hesora ads,  Next: GNAT Heap_Sort_G g-hesorg ads,  Prev: GNAT Heap_Sort g-heasor ads,  Up: The GNAT Library

12.83 ‘GNAT.Heap_Sort_A’ (‘g-hesora.ads’)
=========================================

Provides a general implementation of heap sort usable for sorting
arbitrary data items.  Move and comparison procedures are provided by
passing access-to-procedure values.  The algorithm used is a modified
heap sort that performs approximately N*log(N) comparisons in the worst
case.  This differs from ‘GNAT.Heap_Sort’ in having a less convenient
interface, but may be slightly more efficient.


File: gnat_rm.info,  Node: GNAT Heap_Sort_G g-hesorg ads,  Next: GNAT HTable g-htable ads,  Prev: GNAT Heap_Sort_A g-hesora ads,  Up: The GNAT Library

12.84 ‘GNAT.Heap_Sort_G’ (‘g-hesorg.ads’)
=========================================

Similar to ‘Heap_Sort_A’ except that the move and sorting procedures are
provided as generic parameters, this improves efficiency, especially if
the procedures can be inlined, at the expense of duplicating code for
multiple instantiations.


File: gnat_rm.info,  Node: GNAT HTable g-htable ads,  Next: GNAT IO g-io ads,  Prev: GNAT Heap_Sort_G g-hesorg ads,  Up: The GNAT Library

12.85 ‘GNAT.HTable’ (‘g-htable.ads’)
====================================

A generic implementation of hash tables that can be used to hash
arbitrary data.  Provides two approaches, one a simple static approach,
and the other allowing arbitrary dynamic hash tables.


File: gnat_rm.info,  Node: GNAT IO g-io ads,  Next: GNAT IO_Aux g-io_aux ads,  Prev: GNAT HTable g-htable ads,  Up: The GNAT Library

12.86 ‘GNAT.IO’ (‘g-io.ads’)
============================

A simple preelaborable input-output package that provides a subset of
simple Text_IO functions for reading characters and strings from
Standard_Input, and writing characters, strings and integers to either
Standard_Output or Standard_Error.


File: gnat_rm.info,  Node: GNAT IO_Aux g-io_aux ads,  Next: GNAT Lock_Files g-locfil ads,  Prev: GNAT IO g-io ads,  Up: The GNAT Library

12.87 ‘GNAT.IO_Aux’ (‘g-io_aux.ads’)
====================================

Provides some auxiliary functions for use with Text_IO, including a test
for whether a file exists, and functions for reading a line of text.


File: gnat_rm.info,  Node: GNAT Lock_Files g-locfil ads,  Next: GNAT MBBS_Discrete_Random g-mbdira ads,  Prev: GNAT IO_Aux g-io_aux ads,  Up: The GNAT Library

12.88 ‘GNAT.Lock_Files’ (‘g-locfil.ads’)
========================================

Provides a general interface for using files as locks.  Can be used for
providing program level synchronization.


File: gnat_rm.info,  Node: GNAT MBBS_Discrete_Random g-mbdira ads,  Next: GNAT MBBS_Float_Random g-mbflra ads,  Prev: GNAT Lock_Files g-locfil ads,  Up: The GNAT Library

12.89 ‘GNAT.MBBS_Discrete_Random’ (‘g-mbdira.ads’)
==================================================

The original implementation of ‘Ada.Numerics.Discrete_Random’.  Uses a
modified version of the Blum-Blum-Shub generator.


File: gnat_rm.info,  Node: GNAT MBBS_Float_Random g-mbflra ads,  Next: GNAT MD5 g-md5 ads,  Prev: GNAT MBBS_Discrete_Random g-mbdira ads,  Up: The GNAT Library

12.90 ‘GNAT.MBBS_Float_Random’ (‘g-mbflra.ads’)
===============================================

The original implementation of ‘Ada.Numerics.Float_Random’.  Uses a
modified version of the Blum-Blum-Shub generator.


File: gnat_rm.info,  Node: GNAT MD5 g-md5 ads,  Next: GNAT Memory_Dump g-memdum ads,  Prev: GNAT MBBS_Float_Random g-mbflra ads,  Up: The GNAT Library

12.91 ‘GNAT.MD5’ (‘g-md5.ads’)
==============================

Implements the MD5 Message-Digest Algorithm as described in RFC 1321,
and the HMAC-MD5 message authentication function as described in RFC
2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT Memory_Dump g-memdum ads,  Next: GNAT Most_Recent_Exception g-moreex ads,  Prev: GNAT MD5 g-md5 ads,  Up: The GNAT Library

12.92 ‘GNAT.Memory_Dump’ (‘g-memdum.ads’)
=========================================

Provides a convenient routine for dumping raw memory to either the
standard output or standard error files.  Uses GNAT.IO for actual
output.


File: gnat_rm.info,  Node: GNAT Most_Recent_Exception g-moreex ads,  Next: GNAT OS_Lib g-os_lib ads,  Prev: GNAT Memory_Dump g-memdum ads,  Up: The GNAT Library

12.93 ‘GNAT.Most_Recent_Exception’ (‘g-moreex.ads’)
===================================================

Provides access to the most recently raised exception.  Can be used for
various logging purposes, including duplicating functionality of some
Ada 83 implementation dependent extensions.


File: gnat_rm.info,  Node: GNAT OS_Lib g-os_lib ads,  Next: GNAT Perfect_Hash_Generators g-pehage ads,  Prev: GNAT Most_Recent_Exception g-moreex ads,  Up: The GNAT Library

12.94 ‘GNAT.OS_Lib’ (‘g-os_lib.ads’)
====================================

Provides a range of target independent operating system interface
functions, including time/date management, file operations, subprocess
management, including a portable spawn procedure, and access to
environment variables and error return codes.


File: gnat_rm.info,  Node: GNAT Perfect_Hash_Generators g-pehage ads,  Next: GNAT Random_Numbers g-rannum ads,  Prev: GNAT OS_Lib g-os_lib ads,  Up: The GNAT Library

12.95 ‘GNAT.Perfect_Hash_Generators’ (‘g-pehage.ads’)
=====================================================

Provides a generator of static minimal perfect hash functions.  No
collisions occur and each item can be retrieved from the table in one
probe (perfect property).  The hash table size corresponds to the exact
size of the key set and no larger (minimal property).  The key set has
to be know in advance (static property).  The hash functions are also
order preserving.  If w2 is inserted after w1 in the generator, their
hashcode are in the same order.  These hashing functions are very
convenient for use with realtime applications.


File: gnat_rm.info,  Node: GNAT Random_Numbers g-rannum ads,  Next: GNAT Regexp g-regexp ads,  Prev: GNAT Perfect_Hash_Generators g-pehage ads,  Up: The GNAT Library

12.96 ‘GNAT.Random_Numbers’ (‘g-rannum.ads’)
============================================

Provides random number capabilities which extend those available in the
standard Ada library and are more convenient to use.


File: gnat_rm.info,  Node: GNAT Regexp g-regexp ads,  Next: GNAT Registry g-regist ads,  Prev: GNAT Random_Numbers g-rannum ads,  Up: The GNAT Library

12.97 ‘GNAT.Regexp’ (‘g-regexp.ads’)
====================================

A simple implementation of regular expressions, using a subset of
regular expression syntax copied from familiar Unix style utilities.
This is the simplest of the three pattern matching packages provided,
and is particularly suitable for ‘file globbing’ applications.


File: gnat_rm.info,  Node: GNAT Registry g-regist ads,  Next: GNAT Regpat g-regpat ads,  Prev: GNAT Regexp g-regexp ads,  Up: The GNAT Library

12.98 ‘GNAT.Registry’ (‘g-regist.ads’)
======================================

This is a high level binding to the Windows registry.  It is possible to
do simple things like reading a key value, creating a new key.  For full
registry API, but at a lower level of abstraction, refer to the
Win32.Winreg package provided with the Win32Ada binding


File: gnat_rm.info,  Node: GNAT Regpat g-regpat ads,  Next: GNAT Rewrite_Data g-rewdat ads,  Prev: GNAT Registry g-regist ads,  Up: The GNAT Library

12.99 ‘GNAT.Regpat’ (‘g-regpat.ads’)
====================================

A complete implementation of Unix-style regular expression matching,
copied from the original V7 style regular expression library written in
C by Henry Spencer (and binary compatible with this C library).


File: gnat_rm.info,  Node: GNAT Rewrite_Data g-rewdat ads,  Next: GNAT Secondary_Stack_Info g-sestin ads,  Prev: GNAT Regpat g-regpat ads,  Up: The GNAT Library

12.100 ‘GNAT.Rewrite_Data’ (‘g-rewdat.ads’)
===========================================

A unit to rewrite on-the-fly string occurrences in a stream of data.
The implementation has a very minimal memory footprint as the full
content to be processed is not loaded into memory all at once.  This
makes this interface usable for large files or socket streams.


File: gnat_rm.info,  Node: GNAT Secondary_Stack_Info g-sestin ads,  Next: GNAT Semaphores g-semaph ads,  Prev: GNAT Rewrite_Data g-rewdat ads,  Up: The GNAT Library

12.101 ‘GNAT.Secondary_Stack_Info’ (‘g-sestin.ads’)
===================================================

Provide the capability to query the high water mark of the current
task’s secondary stack.


File: gnat_rm.info,  Node: GNAT Semaphores g-semaph ads,  Next: GNAT Serial_Communications g-sercom ads,  Prev: GNAT Secondary_Stack_Info g-sestin ads,  Up: The GNAT Library

12.102 ‘GNAT.Semaphores’ (‘g-semaph.ads’)
=========================================

Provides classic counting and binary semaphores using protected types.


File: gnat_rm.info,  Node: GNAT Serial_Communications g-sercom ads,  Next: GNAT SHA1 g-sha1 ads,  Prev: GNAT Semaphores g-semaph ads,  Up: The GNAT Library

12.103 ‘GNAT.Serial_Communications’ (‘g-sercom.ads’)
====================================================

Provides a simple interface to send and receive data over a serial port.
This is only supported on GNU/Linux and Windows.


File: gnat_rm.info,  Node: GNAT SHA1 g-sha1 ads,  Next: GNAT SHA224 g-sha224 ads,  Prev: GNAT Serial_Communications g-sercom ads,  Up: The GNAT Library

12.104 ‘GNAT.SHA1’ (‘g-sha1.ads’)
=================================

Implements the SHA-1 Secure Hash Algorithm as described in FIPS PUB
180-3 and RFC 3174, and the HMAC-SHA1 message authentication function as
described in RFC 2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT SHA224 g-sha224 ads,  Next: GNAT SHA256 g-sha256 ads,  Prev: GNAT SHA1 g-sha1 ads,  Up: The GNAT Library

12.105 ‘GNAT.SHA224’ (‘g-sha224.ads’)
=====================================

Implements the SHA-224 Secure Hash Algorithm as described in FIPS PUB
180-3, and the HMAC-SHA224 message authentication function as described
in RFC 2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT SHA256 g-sha256 ads,  Next: GNAT SHA384 g-sha384 ads,  Prev: GNAT SHA224 g-sha224 ads,  Up: The GNAT Library

12.106 ‘GNAT.SHA256’ (‘g-sha256.ads’)
=====================================

Implements the SHA-256 Secure Hash Algorithm as described in FIPS PUB
180-3, and the HMAC-SHA256 message authentication function as described
in RFC 2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT SHA384 g-sha384 ads,  Next: GNAT SHA512 g-sha512 ads,  Prev: GNAT SHA256 g-sha256 ads,  Up: The GNAT Library

12.107 ‘GNAT.SHA384’ (‘g-sha384.ads’)
=====================================

Implements the SHA-384 Secure Hash Algorithm as described in FIPS PUB
180-3, and the HMAC-SHA384 message authentication function as described
in RFC 2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT SHA512 g-sha512 ads,  Next: GNAT Signals g-signal ads,  Prev: GNAT SHA384 g-sha384 ads,  Up: The GNAT Library

12.108 ‘GNAT.SHA512’ (‘g-sha512.ads’)
=====================================

Implements the SHA-512 Secure Hash Algorithm as described in FIPS PUB
180-3, and the HMAC-SHA512 message authentication function as described
in RFC 2104 and FIPS PUB 198.


File: gnat_rm.info,  Node: GNAT Signals g-signal ads,  Next: GNAT Sockets g-socket ads,  Prev: GNAT SHA512 g-sha512 ads,  Up: The GNAT Library

12.109 ‘GNAT.Signals’ (‘g-signal.ads’)
======================================

Provides the ability to manipulate the blocked status of signals on
supported targets.


File: gnat_rm.info,  Node: GNAT Sockets g-socket ads,  Next: GNAT Source_Info g-souinf ads,  Prev: GNAT Signals g-signal ads,  Up: The GNAT Library

12.110 ‘GNAT.Sockets’ (‘g-socket.ads’)
======================================

A high level and portable interface to develop sockets based
applications.  This package is based on the sockets thin binding found
in ‘GNAT.Sockets.Thin’.  Currently ‘GNAT.Sockets’ is implemented on all
native GNAT ports and on VxWorks cross prots.  It is not implemented for
the LynxOS cross port.


File: gnat_rm.info,  Node: GNAT Source_Info g-souinf ads,  Next: GNAT Spelling_Checker g-speche ads,  Prev: GNAT Sockets g-socket ads,  Up: The GNAT Library

12.111 ‘GNAT.Source_Info’ (‘g-souinf.ads’)
==========================================

Provides subprograms that give access to source code information known
at compile time, such as the current file name and line number.  Also
provides subprograms yielding the date and time of the current
compilation (like the C macros ‘__DATE__’ and ‘__TIME__’)


File: gnat_rm.info,  Node: GNAT Spelling_Checker g-speche ads,  Next: GNAT Spelling_Checker_Generic g-spchge ads,  Prev: GNAT Source_Info g-souinf ads,  Up: The GNAT Library

12.112 ‘GNAT.Spelling_Checker’ (‘g-speche.ads’)
===============================================

Provides a function for determining whether one string is a plausible
near misspelling of another string.


File: gnat_rm.info,  Node: GNAT Spelling_Checker_Generic g-spchge ads,  Next: GNAT Spitbol Patterns g-spipat ads,  Prev: GNAT Spelling_Checker g-speche ads,  Up: The GNAT Library

12.113 ‘GNAT.Spelling_Checker_Generic’ (‘g-spchge.ads’)
=======================================================

Provides a generic function that can be instantiated with a string type
for determining whether one string is a plausible near misspelling of
another string.


File: gnat_rm.info,  Node: GNAT Spitbol Patterns g-spipat ads,  Next: GNAT Spitbol g-spitbo ads,  Prev: GNAT Spelling_Checker_Generic g-spchge ads,  Up: The GNAT Library

12.114 ‘GNAT.Spitbol.Patterns’ (‘g-spipat.ads’)
===============================================

A complete implementation of SNOBOL4 style pattern matching.  This is
the most elaborate of the pattern matching packages provided.  It fully
duplicates the SNOBOL4 dynamic pattern construction and matching
capabilities, using the efficient algorithm developed by Robert Dewar
for the SPITBOL system.


File: gnat_rm.info,  Node: GNAT Spitbol g-spitbo ads,  Next: GNAT Spitbol Table_Boolean g-sptabo ads,  Prev: GNAT Spitbol Patterns g-spipat ads,  Up: The GNAT Library

12.115 ‘GNAT.Spitbol’ (‘g-spitbo.ads’)
======================================

The top level package of the collection of SPITBOL-style functionality,
this package provides basic SNOBOL4 string manipulation functions, such
as Pad, Reverse, Trim, Substr capability, as well as a generic table
function useful for constructing arbitrary mappings from strings in the
style of the SNOBOL4 TABLE function.


File: gnat_rm.info,  Node: GNAT Spitbol Table_Boolean g-sptabo ads,  Next: GNAT Spitbol Table_Integer g-sptain ads,  Prev: GNAT Spitbol g-spitbo ads,  Up: The GNAT Library

12.116 ‘GNAT.Spitbol.Table_Boolean’ (‘g-sptabo.ads’)
====================================================

A library level of instantiation of ‘GNAT.Spitbol.Patterns.Table’ for
type ‘Standard.Boolean’, giving an implementation of sets of string
values.


File: gnat_rm.info,  Node: GNAT Spitbol Table_Integer g-sptain ads,  Next: GNAT Spitbol Table_VString g-sptavs ads,  Prev: GNAT Spitbol Table_Boolean g-sptabo ads,  Up: The GNAT Library

12.117 ‘GNAT.Spitbol.Table_Integer’ (‘g-sptain.ads’)
====================================================

A library level of instantiation of ‘GNAT.Spitbol.Patterns.Table’ for
type ‘Standard.Integer’, giving an implementation of maps from string to
integer values.


File: gnat_rm.info,  Node: GNAT Spitbol Table_VString g-sptavs ads,  Next: GNAT SSE g-sse ads,  Prev: GNAT Spitbol Table_Integer g-sptain ads,  Up: The GNAT Library

12.118 ‘GNAT.Spitbol.Table_VString’ (‘g-sptavs.ads’)
====================================================

A library level of instantiation of ‘GNAT.Spitbol.Patterns.Table’ for a
variable length string type, giving an implementation of general maps
from strings to strings.


File: gnat_rm.info,  Node: GNAT SSE g-sse ads,  Next: GNAT SSE Vector_Types g-ssvety ads,  Prev: GNAT Spitbol Table_VString g-sptavs ads,  Up: The GNAT Library

12.119 ‘GNAT.SSE’ (‘g-sse.ads’)
===============================

Root of a set of units aimed at offering Ada bindings to a subset of the
Intel(r) Streaming SIMD Extensions with GNAT on the x86 family of
targets.  It exposes vector component types together with a general
introduction to the binding contents and use.


File: gnat_rm.info,  Node: GNAT SSE Vector_Types g-ssvety ads,  Next: GNAT String_Hash g-strhas ads,  Prev: GNAT SSE g-sse ads,  Up: The GNAT Library

12.120 ‘GNAT.SSE.Vector_Types’ (‘g-ssvety.ads’)
===============================================

SSE vector types for use with SSE related intrinsics.


File: gnat_rm.info,  Node: GNAT String_Hash g-strhas ads,  Next: GNAT Strings g-string ads,  Prev: GNAT SSE Vector_Types g-ssvety ads,  Up: The GNAT Library

12.121 ‘GNAT.String_Hash’ (‘g-strhas.ads’)
==========================================

Provides a generic hash function working on arrays of scalars.  Both the
scalar type and the hash result type are parameters.


File: gnat_rm.info,  Node: GNAT Strings g-string ads,  Next: GNAT String_Split g-strspl ads,  Prev: GNAT String_Hash g-strhas ads,  Up: The GNAT Library

12.122 ‘GNAT.Strings’ (‘g-string.ads’)
======================================

Common String access types and related subprograms.  Basically it
defines a string access and an array of string access types.


File: gnat_rm.info,  Node: GNAT String_Split g-strspl ads,  Next: GNAT Table g-table ads,  Prev: GNAT Strings g-string ads,  Up: The GNAT Library

12.123 ‘GNAT.String_Split’ (‘g-strspl.ads’)
===========================================

Useful string manipulation routines: given a set of separators, split a
string wherever the separators appear, and provide direct access to the
resulting slices.  This package is instantiated from ‘GNAT.Array_Split’.


File: gnat_rm.info,  Node: GNAT Table g-table ads,  Next: GNAT Task_Lock g-tasloc ads,  Prev: GNAT String_Split g-strspl ads,  Up: The GNAT Library

12.124 ‘GNAT.Table’ (‘g-table.ads’)
===================================

A generic package providing a single dimension array abstraction where
the length of the array can be dynamically modified.

This package provides a facility similar to that of
‘GNAT.Dynamic_Tables’, except that this package declares a single
instance of the table type, while an instantiation of
‘GNAT.Dynamic_Tables’ creates a type that can be used to define dynamic
instances of the table.


File: gnat_rm.info,  Node: GNAT Task_Lock g-tasloc ads,  Next: GNAT Time_Stamp g-timsta ads,  Prev: GNAT Table g-table ads,  Up: The GNAT Library

12.125 ‘GNAT.Task_Lock’ (‘g-tasloc.ads’)
========================================

A very simple facility for locking and unlocking sections of code using
a single global task lock.  Appropriate for use in situations where
contention between tasks is very rarely expected.


File: gnat_rm.info,  Node: GNAT Time_Stamp g-timsta ads,  Next: GNAT Threads g-thread ads,  Prev: GNAT Task_Lock g-tasloc ads,  Up: The GNAT Library

12.126 ‘GNAT.Time_Stamp’ (‘g-timsta.ads’)
=========================================

Provides a simple function that returns a string YYYY-MM-DD HH:MM:SS.SS
that represents the current date and time in ISO 8601 format.  This is a
very simple routine with minimal code and there are no dependencies on
any other unit.


File: gnat_rm.info,  Node: GNAT Threads g-thread ads,  Next: GNAT Traceback g-traceb ads,  Prev: GNAT Time_Stamp g-timsta ads,  Up: The GNAT Library

12.127 ‘GNAT.Threads’ (‘g-thread.ads’)
======================================

Provides facilities for dealing with foreign threads which need to be
known by the GNAT run-time system.  Consult the documentation of this
package for further details if your program has threads that are created
by a non-Ada environment which then accesses Ada code.


File: gnat_rm.info,  Node: GNAT Traceback g-traceb ads,  Next: GNAT Traceback Symbolic g-trasym ads,  Prev: GNAT Threads g-thread ads,  Up: The GNAT Library

12.128 ‘GNAT.Traceback’ (‘g-traceb.ads’)
========================================

Provides a facility for obtaining non-symbolic traceback information,
useful in various debugging situations.


File: gnat_rm.info,  Node: GNAT Traceback Symbolic g-trasym ads,  Next: GNAT UTF_32 g-table ads,  Prev: GNAT Traceback g-traceb ads,  Up: The GNAT Library

12.129 ‘GNAT.Traceback.Symbolic’ (‘g-trasym.ads’)
=================================================


File: gnat_rm.info,  Node: GNAT UTF_32 g-table ads,  Next: GNAT Wide_Spelling_Checker g-u3spch ads,  Prev: GNAT Traceback Symbolic g-trasym ads,  Up: The GNAT Library

12.130 ‘GNAT.UTF_32’ (‘g-table.ads’)
====================================

This is a package intended to be used in conjunction with the
‘Wide_Character’ type in Ada 95 and the ‘Wide_Wide_Character’ type in
Ada 2005 (available in ‘GNAT’ in Ada 2005 mode).  This package contains
Unicode categorization routines, as well as lexical categorization
routines corresponding to the Ada 2005 lexical rules for identifiers and
strings, and also a lower case to upper case fold routine corresponding
to the Ada 2005 rules for identifier equivalence.


File: gnat_rm.info,  Node: GNAT Wide_Spelling_Checker g-u3spch ads,  Next: GNAT Wide_Spelling_Checker g-wispch ads,  Prev: GNAT UTF_32 g-table ads,  Up: The GNAT Library

12.131 ‘GNAT.Wide_Spelling_Checker’ (‘g-u3spch.ads’)
====================================================

Provides a function for determining whether one wide wide string is a
plausible near misspelling of another wide wide string, where the
strings are represented using the UTF_32_String type defined in
System.Wch_Cnv.


File: gnat_rm.info,  Node: GNAT Wide_Spelling_Checker g-wispch ads,  Next: GNAT Wide_String_Split g-wistsp ads,  Prev: GNAT Wide_Spelling_Checker g-u3spch ads,  Up: The GNAT Library

12.132 ‘GNAT.Wide_Spelling_Checker’ (‘g-wispch.ads’)
====================================================

Provides a function for determining whether one wide string is a
plausible near misspelling of another wide string.


File: gnat_rm.info,  Node: GNAT Wide_String_Split g-wistsp ads,  Next: GNAT Wide_Wide_Spelling_Checker g-zspche ads,  Prev: GNAT Wide_Spelling_Checker g-wispch ads,  Up: The GNAT Library

12.133 ‘GNAT.Wide_String_Split’ (‘g-wistsp.ads’)
================================================

Useful wide string manipulation routines: given a set of separators,
split a wide string wherever the separators appear, and provide direct
access to the resulting slices.  This package is instantiated from
‘GNAT.Array_Split’.


File: gnat_rm.info,  Node: GNAT Wide_Wide_Spelling_Checker g-zspche ads,  Next: GNAT Wide_Wide_String_Split g-zistsp ads,  Prev: GNAT Wide_String_Split g-wistsp ads,  Up: The GNAT Library

12.134 ‘GNAT.Wide_Wide_Spelling_Checker’ (‘g-zspche.ads’)
=========================================================

Provides a function for determining whether one wide wide string is a
plausible near misspelling of another wide wide string.


File: gnat_rm.info,  Node: GNAT Wide_Wide_String_Split g-zistsp ads,  Next: Interfaces C Extensions i-cexten ads,  Prev: GNAT Wide_Wide_Spelling_Checker g-zspche ads,  Up: The GNAT Library

12.135 ‘GNAT.Wide_Wide_String_Split’ (‘g-zistsp.ads’)
=====================================================

Useful wide wide string manipulation routines: given a set of
separators, split a wide wide string wherever the separators appear, and
provide direct access to the resulting slices.  This package is
instantiated from ‘GNAT.Array_Split’.


File: gnat_rm.info,  Node: Interfaces C Extensions i-cexten ads,  Next: Interfaces C Streams i-cstrea ads,  Prev: GNAT Wide_Wide_String_Split g-zistsp ads,  Up: The GNAT Library

12.136 ‘Interfaces.C.Extensions’ (‘i-cexten.ads’)
=================================================

This package contains additional C-related definitions, intended for use
with either manually or automatically generated bindings to C libraries.


File: gnat_rm.info,  Node: Interfaces C Streams i-cstrea ads,  Next: Interfaces Packed_Decimal i-pacdec ads,  Prev: Interfaces C Extensions i-cexten ads,  Up: The GNAT Library

12.137 ‘Interfaces.C.Streams’ (‘i-cstrea.ads’)
==============================================

This package is a binding for the most commonly used operations on C
streams.


File: gnat_rm.info,  Node: Interfaces Packed_Decimal i-pacdec ads,  Next: Interfaces VxWorks i-vxwork ads,  Prev: Interfaces C Streams i-cstrea ads,  Up: The GNAT Library

12.138 ‘Interfaces.Packed_Decimal’ (‘i-pacdec.ads’)
===================================================

This package provides a set of routines for conversions to and from a
packed decimal format compatible with that used on IBM mainframes.


File: gnat_rm.info,  Node: Interfaces VxWorks i-vxwork ads,  Next: Interfaces VxWorks Int_Connection i-vxinco ads,  Prev: Interfaces Packed_Decimal i-pacdec ads,  Up: The GNAT Library

12.139 ‘Interfaces.VxWorks’ (‘i-vxwork.ads’)
============================================

This package provides a limited binding to the VxWorks API. In
particular, it interfaces with the VxWorks hardware interrupt
facilities.


File: gnat_rm.info,  Node: Interfaces VxWorks Int_Connection i-vxinco ads,  Next: Interfaces VxWorks IO i-vxwoio ads,  Prev: Interfaces VxWorks i-vxwork ads,  Up: The GNAT Library

12.140 ‘Interfaces.VxWorks.Int_Connection’ (‘i-vxinco.ads’)
===========================================================

This package provides a way for users to replace the use of intConnect()
with a custom routine for installing interrupt handlers.


File: gnat_rm.info,  Node: Interfaces VxWorks IO i-vxwoio ads,  Next: System Address_Image s-addima ads,  Prev: Interfaces VxWorks Int_Connection i-vxinco ads,  Up: The GNAT Library

12.141 ‘Interfaces.VxWorks.IO’ (‘i-vxwoio.ads’)
===============================================

This package provides a binding to the ioctl (IO/Control) function of
VxWorks, defining a set of option values and function codes.  A
particular use of this package is to enable the use of Get_Immediate
under VxWorks.


File: gnat_rm.info,  Node: System Address_Image s-addima ads,  Next: System Assertions s-assert ads,  Prev: Interfaces VxWorks IO i-vxwoio ads,  Up: The GNAT Library

12.142 ‘System.Address_Image’ (‘s-addima.ads’)
==============================================

This function provides a useful debugging function that gives an
(implementation dependent) string which identifies an address.


File: gnat_rm.info,  Node: System Assertions s-assert ads,  Next: System Atomic_Counters s-atocou ads,  Prev: System Address_Image s-addima ads,  Up: The GNAT Library

12.143 ‘System.Assertions’ (‘s-assert.ads’)
===========================================

This package provides the declaration of the exception raised by an
run-time assertion failure, as well as the routine that is used
internally to raise this assertion.


File: gnat_rm.info,  Node: System Atomic_Counters s-atocou ads,  Next: System Memory s-memory ads,  Prev: System Assertions s-assert ads,  Up: The GNAT Library

12.144 ‘System.Atomic_Counters’ (‘s-atocou.ads’)
================================================

This package provides the declaration of an atomic counter type,
together with efficient routines (using hardware synchronization
primitives) for incrementing, decrementing, and testing of these
counters.  This package is implemented on most targets, including all
Alpha, AARCH64, ARM, ia64, PowerPC, SPARC V9, x86, and x86_64 platforms.


File: gnat_rm.info,  Node: System Memory s-memory ads,  Next: System Multiprocessors s-multip ads,  Prev: System Atomic_Counters s-atocou ads,  Up: The GNAT Library

12.145 ‘System.Memory’ (‘s-memory.ads’)
=======================================

This package provides the interface to the low level routines used by
the generated code for allocation and freeing storage for the default
storage pool (analogous to the C routines malloc and free.  It also
provides a reallocation interface analogous to the C routine realloc.
The body of this unit may be modified to provide alternative allocation
mechanisms for the default pool, and in addition, direct calls to this
unit may be made for low level allocation uses (for example see the body
of ‘GNAT.Tables’).


File: gnat_rm.info,  Node: System Multiprocessors s-multip ads,  Next: System Multiprocessors Dispatching_Domains s-mudido ads,  Prev: System Memory s-memory ads,  Up: The GNAT Library

12.146 ‘System.Multiprocessors’ (‘s-multip.ads’)
================================================

This is an Ada 2012 unit defined in the Ada 2012 Reference Manual, but
in GNAT we also make it available in Ada 95 and Ada 2005 (where it is
technically an implementation-defined addition).


File: gnat_rm.info,  Node: System Multiprocessors Dispatching_Domains s-mudido ads,  Next: System Partition_Interface s-parint ads,  Prev: System Multiprocessors s-multip ads,  Up: The GNAT Library

12.147 ‘System.Multiprocessors.Dispatching_Domains’ (‘s-mudido.ads’)
====================================================================

This is an Ada 2012 unit defined in the Ada 2012 Reference Manual, but
in GNAT we also make it available in Ada 95 and Ada 2005 (where it is
technically an implementation-defined addition).


File: gnat_rm.info,  Node: System Partition_Interface s-parint ads,  Next: System Pool_Global s-pooglo ads,  Prev: System Multiprocessors Dispatching_Domains s-mudido ads,  Up: The GNAT Library

12.148 ‘System.Partition_Interface’ (‘s-parint.ads’)
====================================================

This package provides facilities for partition interfacing.  It is used
primarily in a distribution context when using Annex E with ‘GLADE’.


File: gnat_rm.info,  Node: System Pool_Global s-pooglo ads,  Next: System Pool_Local s-pooloc ads,  Prev: System Partition_Interface s-parint ads,  Up: The GNAT Library

12.149 ‘System.Pool_Global’ (‘s-pooglo.ads’)
============================================

This package provides a storage pool that is equivalent to the default
storage pool used for access types for which no pool is specifically
declared.  It uses malloc/free to allocate/free and does not attempt to
do any automatic reclamation.


File: gnat_rm.info,  Node: System Pool_Local s-pooloc ads,  Next: System Restrictions s-restri ads,  Prev: System Pool_Global s-pooglo ads,  Up: The GNAT Library

12.150 ‘System.Pool_Local’ (‘s-pooloc.ads’)
===========================================

This package provides a storage pool that is intended for use with
locally defined access types.  It uses malloc/free for allocate/free,
and maintains a list of allocated blocks, so that all storage allocated
for the pool can be freed automatically when the pool is finalized.


File: gnat_rm.info,  Node: System Restrictions s-restri ads,  Next: System Rident s-rident ads,  Prev: System Pool_Local s-pooloc ads,  Up: The GNAT Library

12.151 ‘System.Restrictions’ (‘s-restri.ads’)
=============================================

This package provides facilities for accessing at run time the status of
restrictions specified at compile time for the partition.  Information
is available both with regard to actual restrictions specified, and with
regard to compiler determined information on which restrictions are
violated by one or more packages in the partition.


File: gnat_rm.info,  Node: System Rident s-rident ads,  Next: System Strings Stream_Ops s-ststop ads,  Prev: System Restrictions s-restri ads,  Up: The GNAT Library

12.152 ‘System.Rident’ (‘s-rident.ads’)
=======================================

This package provides definitions of the restrictions identifiers
supported by GNAT, and also the format of the restrictions provided in
package System.Restrictions.  It is not normally necessary to ‘with’
this generic package since the necessary instantiation is included in
package System.Restrictions.


File: gnat_rm.info,  Node: System Strings Stream_Ops s-ststop ads,  Next: System Unsigned_Types s-unstyp ads,  Prev: System Rident s-rident ads,  Up: The GNAT Library

12.153 ‘System.Strings.Stream_Ops’ (‘s-ststop.ads’)
===================================================

This package provides a set of stream subprograms for standard string
types.  It is intended primarily to support implicit use of such
subprograms when stream attributes are applied to string types, but the
subprograms in this package can be used directly by application
programs.


File: gnat_rm.info,  Node: System Unsigned_Types s-unstyp ads,  Next: System Wch_Cnv s-wchcnv ads,  Prev: System Strings Stream_Ops s-ststop ads,  Up: The GNAT Library

12.154 ‘System.Unsigned_Types’ (‘s-unstyp.ads’)
===============================================

This package contains definitions of standard unsigned types that
correspond in size to the standard signed types declared in Standard,
and (unlike the types in Interfaces) have corresponding names.  It also
contains some related definitions for other specialized types used by
the compiler in connection with packed array types.


File: gnat_rm.info,  Node: System Wch_Cnv s-wchcnv ads,  Next: System Wch_Con s-wchcon ads,  Prev: System Unsigned_Types s-unstyp ads,  Up: The GNAT Library

12.155 ‘System.Wch_Cnv’ (‘s-wchcnv.ads’)
========================================

This package provides routines for converting between wide and wide wide
characters and a representation as a value of type ‘Standard.String’,
using a specified wide character encoding method.  It uses definitions
in package ‘System.Wch_Con’.


File: gnat_rm.info,  Node: System Wch_Con s-wchcon ads,  Prev: System Wch_Cnv s-wchcnv ads,  Up: The GNAT Library

12.156 ‘System.Wch_Con’ (‘s-wchcon.ads’)
========================================

This package provides definitions and descriptions of the various
methods used for encoding wide characters in ordinary strings.  These
definitions are used by the package ‘System.Wch_Cnv’.


File: gnat_rm.info,  Node: Interfacing to Other Languages,  Next: Specialized Needs Annexes,  Prev: The GNAT Library,  Up: Top

13 Interfacing to Other Languages
*********************************

The facilities in Annex B of the Ada Reference Manual are fully
implemented in GNAT, and in addition, a full interface to C++ is
provided.

* Menu:

* Interfacing to C::
* Interfacing to C++::
* Interfacing to COBOL::
* Interfacing to Fortran::
* Interfacing to non-GNAT Ada code::


File: gnat_rm.info,  Node: Interfacing to C,  Next: Interfacing to C++,  Up: Interfacing to Other Languages

13.1 Interfacing to C
=====================

Interfacing to C with GNAT can use one of two approaches:

   * The types in the package ‘Interfaces.C’ may be used.

   * Standard Ada types may be used directly.  This may be less portable
     to other compilers, but will work on all GNAT compilers, which
     guarantee correspondence between the C and Ada types.

Pragma ‘Convention C’ may be applied to Ada types, but mostly has no
effect, since this is the default.  The following table shows the
correspondence between Ada scalar types and the corresponding C types.

Ada Type                     C Type
                             
----------------------------------------------------------------------------------------------------
                             
‘Integer’                    ‘int’
                             
                             
‘Short_Integer’              ‘short’
                             
                             
‘Short_Short_Integer’        ‘signed char’
                             
                             
‘Long_Integer’               ‘long’
                             
                             
‘Long_Long_Integer’          ‘long long’
                             
                             
‘Short_Float’                ‘float’
                             
                             
‘Float’                      ‘float’
                             
                             
‘Long_Float’                 ‘double’
                             
                             
‘Long_Long_Float’            This is the longest floating-point type supported by the hardware.
                             

Additionally, there are the following general correspondences between
Ada and C types:

   * Ada enumeration types map to C enumeration types directly if pragma
     ‘Convention C’ is specified, which causes them to have a length of
     32 bits, except for boolean types which map to C99 ‘bool’ and for
     which the length is 8 bits.  Without pragma ‘Convention C’, Ada
     enumeration types map to 8, 16, or 32 bits (i.e., C types ‘signed
     char’, ‘short’, ‘int’, respectively) depending on the number of
     values passed.  This is the only case in which pragma ‘Convention
     C’ affects the representation of an Ada type.

   * Ada access types map to C pointers, except for the case of pointers
     to unconstrained types in Ada, which have no direct C equivalent.

   * Ada arrays map directly to C arrays.

   * Ada records map directly to C structures.

   * Packed Ada records map to C structures where all members are bit
     fields of the length corresponding to the ‘type'Size’ value in Ada.


File: gnat_rm.info,  Node: Interfacing to C++,  Next: Interfacing to COBOL,  Prev: Interfacing to C,  Up: Interfacing to Other Languages

13.2 Interfacing to C++
=======================

The interface to C++ makes use of the following pragmas, which are
primarily intended to be constructed automatically using a binding
generator tool, although it is possible to construct them by hand.

Using these pragmas it is possible to achieve complete inter-operability
between Ada tagged types and C++ class definitions.  See *note
Implementation Defined Pragmas: 7, for more details.

‘pragma CPP_Class ([Entity =>] `LOCAL_NAME')’

     The argument denotes an entity in the current declarative region
     that is declared as a tagged or untagged record type.  It indicates
     that the type corresponds to an externally declared C++ class type,
     and is to be laid out the same way that C++ would lay out the type.

     Note: Pragma ‘CPP_Class’ is currently obsolete.  It is supported
     for backward compatibility but its functionality is available using
     pragma ‘Import’ with ‘Convention’ = ‘CPP’.

‘pragma CPP_Constructor ([Entity =>] `LOCAL_NAME')’

     This pragma identifies an imported function (imported in the usual
     way with pragma ‘Import’) as corresponding to a C++ constructor.

A few restrictions are placed on the use of the ‘Access’ attribute in
conjunction with subprograms subject to convention ‘CPP’: the attribute
may be used neither on primitive operations of a tagged record type with
convention ‘CPP’, imported or not, nor on subprograms imported with
pragma ‘CPP_Constructor’.

In addition, C++ exceptions are propagated and can be handled in an
‘others’ choice of an exception handler.  The corresponding Ada
occurrence has no message, and the simple name of the exception identity
contains ‘Foreign_Exception’.  Finalization and awaiting dependent tasks
works properly when such foreign exceptions are propagated.

It is also possible to import a C++ exception using the following
syntax:

     LOCAL_NAME : exception;
     pragma Import (Cpp,
       [Entity =>] LOCAL_NAME,
       [External_Name =>] static_string_EXPRESSION);

The ‘External_Name’ is the name of the C++ RTTI symbol.  You can then
cover a specific C++ exception in an exception handler.


File: gnat_rm.info,  Node: Interfacing to COBOL,  Next: Interfacing to Fortran,  Prev: Interfacing to C++,  Up: Interfacing to Other Languages

13.3 Interfacing to COBOL
=========================

Interfacing to COBOL is achieved as described in section B.4 of the Ada
Reference Manual.


File: gnat_rm.info,  Node: Interfacing to Fortran,  Next: Interfacing to non-GNAT Ada code,  Prev: Interfacing to COBOL,  Up: Interfacing to Other Languages

13.4 Interfacing to Fortran
===========================

Interfacing to Fortran is achieved as described in section B.5 of the
Ada Reference Manual.  The pragma ‘Convention Fortran’, applied to a
multi-dimensional array causes the array to be stored in column-major
order as required for convenient interface to Fortran.


File: gnat_rm.info,  Node: Interfacing to non-GNAT Ada code,  Prev: Interfacing to Fortran,  Up: Interfacing to Other Languages

13.5 Interfacing to non-GNAT Ada code
=====================================

It is possible to specify the convention ‘Ada’ in a pragma ‘Import’ or
pragma ‘Export’.  However this refers to the calling conventions used by
GNAT, which may or may not be similar enough to those used by some other
Ada 83 / Ada 95 / Ada 2005 compiler to allow interoperation.

If arguments types are kept simple, and if the foreign compiler
generally follows system calling conventions, then it may be possible to
integrate files compiled by other Ada compilers, provided that the
elaboration issues are adequately addressed (for example by eliminating
the need for any load time elaboration).

In particular, GNAT running on VMS is designed to be highly compatible
with the DEC Ada 83 compiler, so this is one case in which it is
possible to import foreign units of this type, provided that the data
items passed are restricted to simple scalar values or simple record
types without variants, or simple array types with fixed bounds.


File: gnat_rm.info,  Node: Specialized Needs Annexes,  Next: Implementation of Specific Ada Features,  Prev: Interfacing to Other Languages,  Up: Top

14 Specialized Needs Annexes
****************************

Ada 95, Ada 2005, and Ada 2012 define a number of Specialized Needs
Annexes, which are not required in all implementations.  However, as
described in this chapter, GNAT implements all of these annexes:

`Systems Programming (Annex C)'

     The Systems Programming Annex is fully implemented.

`Real-Time Systems (Annex D)'

     The Real-Time Systems Annex is fully implemented.

`Distributed Systems (Annex E)'

     Stub generation is fully implemented in the GNAT compiler.  In
     addition, a complete compatible PCS is available as part of the
     GLADE system, a separate product.  When the two products are used
     in conjunction, this annex is fully implemented.

`Information Systems (Annex F)'

     The Information Systems annex is fully implemented.

`Numerics (Annex G)'

     The Numerics Annex is fully implemented.

`Safety and Security / High-Integrity Systems (Annex H)'

     The Safety and Security Annex (termed the High-Integrity Systems
     Annex in Ada 2005) is fully implemented.


File: gnat_rm.info,  Node: Implementation of Specific Ada Features,  Next: Implementation of Ada 2012 Features,  Prev: Specialized Needs Annexes,  Up: Top

15 Implementation of Specific Ada Features
******************************************

This chapter describes the GNAT implementation of several Ada language
facilities.

* Menu:

* Machine Code Insertions::
* GNAT Implementation of Tasking::
* GNAT Implementation of Shared Passive Packages::
* Code Generation for Array Aggregates::
* The Size of Discriminated Records with Default Discriminants::
* Image Values For Nonscalar Types::
* Strict Conformance to the Ada Reference Manual::


File: gnat_rm.info,  Node: Machine Code Insertions,  Next: GNAT Implementation of Tasking,  Up: Implementation of Specific Ada Features

15.1 Machine Code Insertions
============================

Package ‘Machine_Code’ provides machine code support as described in the
Ada Reference Manual in two separate forms:

   * Machine code statements, consisting of qualified expressions that
     fit the requirements of RM section 13.8.

   * An intrinsic callable procedure, providing an alternative mechanism
     of including machine instructions in a subprogram.

The two features are similar, and both are closely related to the
mechanism provided by the asm instruction in the GNU C compiler.  Full
understanding and use of the facilities in this package requires
understanding the asm instruction, see the section on Extended Asm in
‘Using_the_GNU_Compiler_Collection_(GCC)’.

Calls to the function ‘Asm’ and the procedure ‘Asm’ have identical
semantic restrictions and effects as described below.  Both are provided
so that the procedure call can be used as a statement, and the function
call can be used to form a code_statement.

Consider this C ‘asm’ instruction:

     asm ("fsinx %1 %0" : "=f" (result) : "f" (angle));

The equivalent can be written for GNAT as:

     Asm ("fsinx %1 %0",
          My_Float'Asm_Output ("=f", result),
          My_Float'Asm_Input  ("f",  angle));

The first argument to ‘Asm’ is the assembler template, and is identical
to what is used in GNU C. This string must be a static expression.  The
second argument is the output operand list.  It is either a single
‘Asm_Output’ attribute reference, or a list of such references enclosed
in parentheses (technically an array aggregate of such references).

The ‘Asm_Output’ attribute denotes a function that takes two parameters.
The first is a string, the second is the name of a variable of the type
designated by the attribute prefix.  The first (string) argument is
required to be a static expression and designates the constraint (see
the section on Constraints in ‘Using_the_GNU_Compiler_Collection_(GCC)’)
for the parameter; e.g., what kind of register is required.  The second
argument is the variable to be written or updated with the result.  The
possible values for constraint are the same as those used in the RTL,
and are dependent on the configuration file used to build the GCC back
end.  If there are no output operands, then this argument may either be
omitted, or explicitly given as ‘No_Output_Operands’.  No support is
provided for GNU C’s symbolic names for output parameters.

The second argument of ‘my_float'Asm_Output’ functions as though it were
an ‘out’ parameter, which is a little curious, but all names have the
form of expressions, so there is no syntactic irregularity, even though
normally functions would not be permitted ‘out’ parameters.  The third
argument is the list of input operands.  It is either a single
‘Asm_Input’ attribute reference, or a list of such references enclosed
in parentheses (technically an array aggregate of such references).

The ‘Asm_Input’ attribute denotes a function that takes two parameters.
The first is a string, the second is an expression of the type
designated by the prefix.  The first (string) argument is required to be
a static expression, and is the constraint for the parameter, (e.g.,
what kind of register is required).  The second argument is the value to
be used as the input argument.  The possible values for the constraint
are the same as those used in the RTL, and are dependent on the
configuration file used to built the GCC back end.  No support is
provided for GNU C’s symbolic names for input parameters.

If there are no input operands, this argument may either be omitted, or
explicitly given as ‘No_Input_Operands’.  The fourth argument, not
present in the above example, is a list of register names, called the
`clobber' argument.  This argument, if given, must be a static string
expression, and is a space or comma separated list of names of registers
that must be considered destroyed as a result of the ‘Asm’ call.  If
this argument is the null string (the default value), then the code
generator assumes that no additional registers are destroyed.  In
addition to registers, the special clobbers ‘memory’ and ‘cc’ as
described in the GNU C docs are both supported.

The fifth argument, not present in the above example, called the
`volatile' argument, is by default ‘False’.  It can be set to the
literal value ‘True’ to indicate to the code generator that all
optimizations with respect to the instruction specified should be
suppressed, and in particular an instruction that has outputs will still
be generated, even if none of the outputs are used.  See
‘Using_the_GNU_Compiler_Collection_(GCC)’ for the full description.
Generally it is strongly advisable to use Volatile for any ASM statement
that is missing either input or output operands or to avoid unwanted
optimizations.  A warning is generated if this advice is not followed.

No support is provided for GNU C’s ‘asm goto’ feature.

The ‘Asm’ subprograms may be used in two ways.  First the procedure
forms can be used anywhere a procedure call would be valid, and
correspond to what the RM calls ‘intrinsic’ routines.  Such calls can be
used to intersperse machine instructions with other Ada statements.
Second, the function forms, which return a dummy value of the limited
private type ‘Asm_Insn’, can be used in code statements, and indeed this
is the only context where such calls are allowed.  Code statements
appear as aggregates of the form:

     Asm_Insn'(Asm (...));
     Asm_Insn'(Asm_Volatile (...));

In accordance with RM rules, such code statements are allowed only
within subprograms whose entire body consists of such statements.  It is
not permissible to intermix such statements with other Ada statements.

Typically the form using intrinsic procedure calls is more convenient
and more flexible.  The code statement form is provided to meet the RM
suggestion that such a facility should be made available.  The following
is the exact syntax of the call to ‘Asm’.  As usual, if named notation
is used, the arguments may be given in arbitrary order, following the
normal rules for use of positional and named arguments:

     ASM_CALL ::= Asm (
                      [Template =>] static_string_EXPRESSION
                    [,[Outputs  =>] OUTPUT_OPERAND_LIST      ]
                    [,[Inputs   =>] INPUT_OPERAND_LIST       ]
                    [,[Clobber  =>] static_string_EXPRESSION ]
                    [,[Volatile =>] static_boolean_EXPRESSION] )

     OUTPUT_OPERAND_LIST ::=
       [PREFIX.]No_Output_Operands
     | OUTPUT_OPERAND_ATTRIBUTE
     | (OUTPUT_OPERAND_ATTRIBUTE {,OUTPUT_OPERAND_ATTRIBUTE})

     OUTPUT_OPERAND_ATTRIBUTE ::=
       SUBTYPE_MARK'Asm_Output (static_string_EXPRESSION, NAME)

     INPUT_OPERAND_LIST ::=
       [PREFIX.]No_Input_Operands
     | INPUT_OPERAND_ATTRIBUTE
     | (INPUT_OPERAND_ATTRIBUTE {,INPUT_OPERAND_ATTRIBUTE})

     INPUT_OPERAND_ATTRIBUTE ::=
       SUBTYPE_MARK'Asm_Input (static_string_EXPRESSION, EXPRESSION)

The identifiers ‘No_Input_Operands’ and ‘No_Output_Operands’ are
declared in the package ‘Machine_Code’ and must be referenced according
to normal visibility rules.  In particular if there is no ‘use’ clause
for this package, then appropriate package name qualification is
required.


File: gnat_rm.info,  Node: GNAT Implementation of Tasking,  Next: GNAT Implementation of Shared Passive Packages,  Prev: Machine Code Insertions,  Up: Implementation of Specific Ada Features

15.2 GNAT Implementation of Tasking
===================================

This chapter outlines the basic GNAT approach to tasking (in particular,
a multi-layered library for portability) and discusses issues related to
compliance with the Real-Time Systems Annex.

* Menu:

* Mapping Ada Tasks onto the Underlying Kernel Threads::
* Ensuring Compliance with the Real-Time Annex::
* Support for Locking Policies::


File: gnat_rm.info,  Node: Mapping Ada Tasks onto the Underlying Kernel Threads,  Next: Ensuring Compliance with the Real-Time Annex,  Up: GNAT Implementation of Tasking

15.2.1 Mapping Ada Tasks onto the Underlying Kernel Threads
-----------------------------------------------------------

GNAT’s run-time support comprises two layers:

   * GNARL (GNAT Run-time Layer)

   * GNULL (GNAT Low-level Library)

In GNAT, Ada’s tasking services rely on a platform and OS independent
layer known as GNARL. This code is responsible for implementing the
correct semantics of Ada’s task creation, rendezvous, protected
operations etc.

GNARL decomposes Ada’s tasking semantics into simpler lower level
operations such as create a thread, set the priority of a thread, yield,
create a lock, lock/unlock, etc.  The spec for these low-level
operations constitutes GNULLI, the GNULL Interface.  This interface is
directly inspired from the POSIX real-time API.

If the underlying executive or OS implements the POSIX standard
faithfully, the GNULL Interface maps as is to the services offered by
the underlying kernel.  Otherwise, some target dependent glue code maps
the services offered by the underlying kernel to the semantics expected
by GNARL.

Whatever the underlying OS (VxWorks, UNIX, Windows, etc.)  the key point
is that each Ada task is mapped on a thread in the underlying kernel.
For example, in the case of VxWorks, one Ada task = one VxWorks task.

In addition Ada task priorities map onto the underlying thread
priorities.  Mapping Ada tasks onto the underlying kernel threads has
several advantages:

   * The underlying scheduler is used to schedule the Ada tasks.  This
     makes Ada tasks as efficient as kernel threads from a scheduling
     standpoint.

   * Interaction with code written in C containing threads is eased
     since at the lowest level Ada tasks and C threads map onto the same
     underlying kernel concept.

   * When an Ada task is blocked during I/O the remaining Ada tasks are
     able to proceed.

   * On multiprocessor systems Ada tasks can execute in parallel.

Some threads libraries offer a mechanism to fork a new process, with the
child process duplicating the threads from the parent.  GNAT does not
support this functionality when the parent contains more than one task.


File: gnat_rm.info,  Node: Ensuring Compliance with the Real-Time Annex,  Next: Support for Locking Policies,  Prev: Mapping Ada Tasks onto the Underlying Kernel Threads,  Up: GNAT Implementation of Tasking

15.2.2 Ensuring Compliance with the Real-Time Annex
---------------------------------------------------

Although mapping Ada tasks onto the underlying threads has significant
advantages, it does create some complications when it comes to
respecting the scheduling semantics specified in the real-time annex
(Annex D).

For instance the Annex D requirement for the ‘FIFO_Within_Priorities’
scheduling policy states:

     `When the active priority of a ready task that is not running
     changes, or the setting of its base priority takes effect, the task
     is removed from the ready queue for its old active priority and is
     added at the tail of the ready queue for its new active priority,
     except in the case where the active priority is lowered due to the
     loss of inherited priority, in which case the task is added at the
     head of the ready queue for its new active priority.'

While most kernels do put tasks at the end of the priority queue when a
task changes its priority, (which respects the main
FIFO_Within_Priorities requirement), almost none keep a thread at the
beginning of its priority queue when its priority drops from the loss of
inherited priority.

As a result most vendors have provided incomplete Annex D
implementations.

The GNAT run-time, has a nice cooperative solution to this problem which
ensures that accurate FIFO_Within_Priorities semantics are respected.

The principle is as follows.  When an Ada task T is about to start
running, it checks whether some other Ada task R with the same priority
as T has been suspended due to the loss of priority inheritance.  If
this is the case, T yields and is placed at the end of its priority
queue.  When R arrives at the front of the queue it executes.

Note that this simple scheme preserves the relative order of the tasks
that were ready to execute in the priority queue where R has been placed
at the end.


File: gnat_rm.info,  Node: Support for Locking Policies,  Prev: Ensuring Compliance with the Real-Time Annex,  Up: GNAT Implementation of Tasking

15.2.3 Support for Locking Policies
-----------------------------------

This section specifies which policies specified by pragma Locking_Policy
are supported on which platforms.

GNAT supports the standard ‘Ceiling_Locking’ policy, and the
implementation defined ‘Inheritance_Locking’ and
‘Concurrent_Readers_Locking’ policies.

‘Ceiling_Locking’ is supported on all platforms if the operating system
supports it.  In particular, ‘Ceiling_Locking’ is not supported on
VxWorks.  ‘Inheritance_Locking’ is supported on Linux, Darwin (Mac OS
X), LynxOS 178, and VxWorks.  ‘Concurrent_Readers_Locking’ is supported
on Linux.

Notes about ‘Ceiling_Locking’ on Linux: If the process is running as
‘root’, ceiling locking is used.  If the capabilities facility is
installed (“sudo apt-get –assume-yes install libcap-dev” on Ubuntu, for
example), and the program is linked against that library (“-largs
-lcap”), and the executable file has the cap_sys_nice capability (“sudo
/sbin/setcap cap_sys_nice=ep executable_file_name”), then ceiling
locking is used.  Otherwise, the ‘Ceiling_Locking’ policy is ignored.


File: gnat_rm.info,  Node: GNAT Implementation of Shared Passive Packages,  Next: Code Generation for Array Aggregates,  Prev: GNAT Implementation of Tasking,  Up: Implementation of Specific Ada Features

15.3 GNAT Implementation of Shared Passive Packages
===================================================

GNAT fully implements the pragma ‘Shared_Passive’ for the purpose of
designating shared passive packages.  This allows the use of passive
partitions in the context described in the Ada Reference Manual; i.e.,
for communication between separate partitions of a distributed
application using the features in Annex E.

However, the implementation approach used by GNAT provides for more
extensive usage as follows:

`Communication between separate programs'

     This allows separate programs to access the data in passive
     partitions, using protected objects for synchronization where
     needed.  The only requirement is that the two programs have a
     common shared file system.  It is even possible for programs
     running on different machines with different architectures (e.g.,
     different endianness) to communicate via the data in a passive
     partition.

`Persistence between program runs'

     The data in a passive package can persist from one run of a program
     to another, so that a later program sees the final values stored by
     a previous run of the same program.

The implementation approach used is to store the data in files.  A
separate stream file is created for each object in the package, and an
access to an object causes the corresponding file to be read or written.

The environment variable ‘SHARED_MEMORY_DIRECTORY’ should be set to the
directory to be used for these files.  The files in this directory have
names that correspond to their fully qualified names.  For example, if
we have the package

     package X is
       pragma Shared_Passive (X);
       Y : Integer;
       Z : Float;
     end X;

and the environment variable is set to ‘/stemp/’, then the files created
will have the names:

     /stemp/x.y
     /stemp/x.z

These files are created when a value is initially written to the object,
and the files are retained until manually deleted.  This provides the
persistence semantics.  If no file exists, it means that no partition
has assigned a value to the variable; in this case the initial value
declared in the package will be used.  This model ensures that there are
no issues in synchronizing the elaboration process, since elaboration of
passive packages elaborates the initial values, but does not create the
files.

The files are written using normal ‘Stream_IO’ access.  If you want to
be able to communicate between programs or partitions running on
different architectures, then you should use the XDR versions of the
stream attribute routines, since these are architecture independent.

If active synchronization is required for access to the variables in the
shared passive package, then as described in the Ada Reference Manual,
the package may contain protected objects used for this purpose.  In
this case a lock file (whose name is ‘___lock’ (three underscores) is
created in the shared memory directory.

This is used to provide the required locking semantics for proper
protected object synchronization.


File: gnat_rm.info,  Node: Code Generation for Array Aggregates,  Next: The Size of Discriminated Records with Default Discriminants,  Prev: GNAT Implementation of Shared Passive Packages,  Up: Implementation of Specific Ada Features

15.4 Code Generation for Array Aggregates
=========================================

Aggregates have a rich syntax and allow the user to specify the values
of complex data structures by means of a single construct.  As a result,
the code generated for aggregates can be quite complex and involve
loops, case statements and multiple assignments.  In the simplest cases,
however, the compiler will recognize aggregates whose components and
constraints are fully static, and in those cases the compiler will
generate little or no executable code.  The following is an outline of
the code that GNAT generates for various aggregate constructs.  For
further details, you will find it useful to examine the output produced
by the -gnatG flag to see the expanded source that is input to the code
generator.  You may also want to examine the assembly code generated at
various levels of optimization.

The code generated for aggregates depends on the context, the component
values, and the type.  In the context of an object declaration the code
generated is generally simpler than in the case of an assignment.  As a
general rule, static component values and static subtypes also lead to
simpler code.

* Menu:

* Static constant aggregates with static bounds::
* Constant aggregates with unconstrained nominal types::
* Aggregates with static bounds::
* Aggregates with nonstatic bounds::
* Aggregates in assignment statements::


File: gnat_rm.info,  Node: Static constant aggregates with static bounds,  Next: Constant aggregates with unconstrained nominal types,  Up: Code Generation for Array Aggregates

15.4.1 Static constant aggregates with static bounds
----------------------------------------------------

For the declarations:

     type One_Dim is array (1..10) of integer;
     ar0 : constant One_Dim := (1, 2, 3, 4, 5, 6, 7, 8, 9, 0);

GNAT generates no executable code: the constant ar0 is placed in static
memory.  The same is true for constant aggregates with named
associations:

     Cr1 : constant One_Dim := (4 => 16, 2 => 4, 3 => 9, 1 => 1, 5 .. 10 => 0);
     Cr3 : constant One_Dim := (others => 7777);

The same is true for multidimensional constant arrays such as:

     type two_dim is array (1..3, 1..3) of integer;
     Unit : constant two_dim := ( (1,0,0), (0,1,0), (0,0,1));

The same is true for arrays of one-dimensional arrays: the following are
static:

     type ar1b  is array (1..3) of boolean;
     type ar_ar is array (1..3) of ar1b;
     None  : constant ar1b := (others => false);     --  fully static
     None2 : constant ar_ar := (1..3 => None);       --  fully static

However, for multidimensional aggregates with named associations, GNAT
will generate assignments and loops, even if all associations are
static.  The following two declarations generate a loop for the first
dimension, and individual component assignments for the second
dimension:

     Zero1: constant two_dim := (1..3 => (1..3 => 0));
     Zero2: constant two_dim := (others => (others => 0));


File: gnat_rm.info,  Node: Constant aggregates with unconstrained nominal types,  Next: Aggregates with static bounds,  Prev: Static constant aggregates with static bounds,  Up: Code Generation for Array Aggregates

15.4.2 Constant aggregates with unconstrained nominal types
-----------------------------------------------------------

In such cases the aggregate itself establishes the subtype, so that
associations with ‘others’ cannot be used.  GNAT determines the bounds
for the actual subtype of the aggregate, and allocates the aggregate
statically as well.  No code is generated for the following:

     type One_Unc is array (natural range <>) of integer;
     Cr_Unc : constant One_Unc := (12,24,36);


File: gnat_rm.info,  Node: Aggregates with static bounds,  Next: Aggregates with nonstatic bounds,  Prev: Constant aggregates with unconstrained nominal types,  Up: Code Generation for Array Aggregates

15.4.3 Aggregates with static bounds
------------------------------------

In all previous examples the aggregate was the initial (and immutable)
value of a constant.  If the aggregate initializes a variable, then code
is generated for it as a combination of individual assignments and loops
over the target object.  The declarations

     Cr_Var1 : One_Dim := (2, 5, 7, 11, 0, 0, 0, 0, 0, 0);
     Cr_Var2 : One_Dim := (others > -1);

generate the equivalent of

     Cr_Var1 (1) := 2;
     Cr_Var1 (2) := 3;
     Cr_Var1 (3) := 5;
     Cr_Var1 (4) := 11;

     for I in Cr_Var2'range loop
        Cr_Var2 (I) := -1;
     end loop;


File: gnat_rm.info,  Node: Aggregates with nonstatic bounds,  Next: Aggregates in assignment statements,  Prev: Aggregates with static bounds,  Up: Code Generation for Array Aggregates

15.4.4 Aggregates with nonstatic bounds
---------------------------------------

If the bounds of the aggregate are not statically compatible with the
bounds of the nominal subtype of the target, then constraint checks have
to be generated on the bounds.  For a multidimensional array, constraint
checks may have to be applied to sub-arrays individually, if they do not
have statically compatible subtypes.


File: gnat_rm.info,  Node: Aggregates in assignment statements,  Prev: Aggregates with nonstatic bounds,  Up: Code Generation for Array Aggregates

15.4.5 Aggregates in assignment statements
------------------------------------------

In general, aggregate assignment requires the construction of a
temporary, and a copy from the temporary to the target of the
assignment.  This is because it is not always possible to convert the
assignment into a series of individual component assignments.  For
example, consider the simple case:

     A := (A(2), A(1));

This cannot be converted into:

     A(1) := A(2);
     A(2) := A(1);

So the aggregate has to be built first in a separate location, and then
copied into the target.  GNAT recognizes simple cases where this
intermediate step is not required, and the assignments can be performed
in place, directly into the target.  The following sufficient criteria
are applied:

   * The bounds of the aggregate are static, and the associations are
     static.

   * The components of the aggregate are static constants, names of
     simple variables that are not renamings, or expressions not
     involving indexed components whose operands obey these rules.

If any of these conditions are violated, the aggregate will be built in
a temporary (created either by the front-end or the code generator) and
then that temporary will be copied onto the target.


File: gnat_rm.info,  Node: The Size of Discriminated Records with Default Discriminants,  Next: Image Values For Nonscalar Types,  Prev: Code Generation for Array Aggregates,  Up: Implementation of Specific Ada Features

15.5 The Size of Discriminated Records with Default Discriminants
=================================================================

If a discriminated type ‘T’ has discriminants with default values, it is
possible to declare an object of this type without providing an explicit
constraint:

     type Size is range 1..100;

     type Rec (D : Size := 15) is record
        Name : String (1..D);
     end T;

     Word : Rec;

Such an object is said to be `unconstrained'.  The discriminant of the
object can be modified by a full assignment to the object, as long as it
preserves the relation between the value of the discriminant, and the
value of the components that depend on it:

     Word := (3, "yes");

     Word := (5, "maybe");

     Word := (5, "no"); -- raises Constraint_Error

In order to support this behavior efficiently, an unconstrained object
is given the maximum size that any value of the type requires.  In the
case above, ‘Word’ has storage for the discriminant and for a ‘String’
of length 100.  It is important to note that unconstrained objects do
not require dynamic allocation.  It would be an improper implementation
to place on the heap those components whose size depends on
discriminants.  (This improper implementation was used by some Ada83
compilers, where the ‘Name’ component above would have been stored as a
pointer to a dynamic string).  Following the principle that dynamic
storage management should never be introduced implicitly, an Ada
compiler should reserve the full size for an unconstrained declared
object, and place it on the stack.

This maximum size approach has been a source of surprise to some users,
who expect the default values of the discriminants to determine the size
reserved for an unconstrained object: “If the default is 15, why should
the object occupy a larger size?” The answer, of course, is that the
discriminant may be later modified, and its full range of values must be
taken into account.  This is why the declaration:

     type Rec (D : Positive := 15) is record
        Name : String (1..D);
     end record;

     Too_Large : Rec;

is flagged by the compiler with a warning: an attempt to create
‘Too_Large’ will raise ‘Storage_Error’, because the required size
includes ‘Positive'Last’ bytes.  As the first example indicates, the
proper approach is to declare an index type of ‘reasonable’ range so
that unconstrained objects are not too large.

One final wrinkle: if the object is declared to be ‘aliased’, or if it
is created in the heap by means of an allocator, then it is `not'
unconstrained: it is constrained by the default values of the
discriminants, and those values cannot be modified by full assignment.
This is because in the presence of aliasing all views of the object
(which may be manipulated by different tasks, say) must be consistent,
so it is imperative that the object, once created, remain invariant.


File: gnat_rm.info,  Node: Image Values For Nonscalar Types,  Next: Strict Conformance to the Ada Reference Manual,  Prev: The Size of Discriminated Records with Default Discriminants,  Up: Implementation of Specific Ada Features

15.6 Image Values For Nonscalar Types
=====================================

Ada 2022 defines the Image, Wide_Image, and Wide_Wide image attributes
for nonscalar types; earlier Ada versions defined these attributes only
for scalar types.  Ada RM 4.10 provides some general guidance regarding
the default implementation of these attributes and the GNAT compiler
follows that guidance.  However, beyond that the precise details of the
image text generated in these cases are deliberately not documented and
are subject to change.  In particular, users should not rely on
formatting details (such as spaces or line breaking), record field
order, image values for access types, image values for types that have
ancestor or subcomponent types declared in non-Ada2022 code, image
values for predefined types, or the compiler’s choices regarding the
implementation permissions described in Ada RM 4.10.  This list is not
intended to be exhaustive.  If more precise control of image text is
required for some type T, then T’Put_Image should be explicitly
specified.


File: gnat_rm.info,  Node: Strict Conformance to the Ada Reference Manual,  Prev: Image Values For Nonscalar Types,  Up: Implementation of Specific Ada Features

15.7 Strict Conformance to the Ada Reference Manual
===================================================

The dynamic semantics defined by the Ada Reference Manual impose a set
of run-time checks to be generated.  By default, the GNAT compiler will
insert many run-time checks into the compiled code, including most of
those required by the Ada Reference Manual.  However, there are two
checks that are not enabled in the default mode for efficiency reasons:
checks for access before elaboration on subprogram calls, and stack
overflow checking (most operating systems do not perform this check by
default).

Strict conformance to the Ada Reference Manual can be achieved by adding
two compiler options for dynamic checks for access-before-elaboration on
subprogram calls and generic instantiations (`-gnatE'), and stack
overflow checking (`-fstack-check').

Note that the result of a floating point arithmetic operation in
overflow and invalid situations, when the ‘Machine_Overflows’ attribute
of the result type is ‘False’, is to generate IEEE NaN and infinite
values.  This is the case for machines compliant with the IEEE
floating-point standard, but on machines that are not fully compliant
with this standard, such as Alpha, the `-mieee' compiler flag must be
used for achieving IEEE confirming behavior (although at the cost of a
significant performance penalty), so infinite and NaN values are
properly generated.


File: gnat_rm.info,  Node: Implementation of Ada 2012 Features,  Next: Security Hardening Features,  Prev: Implementation of Specific Ada Features,  Up: Top

16 Implementation of Ada 2012 Features
**************************************

This chapter contains a complete list of Ada 2012 features that have
been implemented.  Generally, these features are only available if the
`-gnat12' (Ada 2012 features enabled) option is set, which is the
default behavior, or if the configuration pragma ‘Ada_2012’ is used.

However, new pragmas, attributes, and restrictions are unconditionally
available, since the Ada 95 standard allows the addition of new pragmas,
attributes, and restrictions (there are exceptions, which are documented
in the individual descriptions), and also certain packages were made
available in earlier versions of Ada.

An ISO date (YYYY-MM-DD) appears in parentheses on the description line.
This date shows the implementation date of the feature.  Any wavefront
subsequent to this date will contain the indicated feature, as will any
subsequent releases.  A date of 0000-00-00 means that GNAT has always
implemented the feature, or implemented it as soon as it appeared as a
binding interpretation.

Each feature corresponds to an Ada Issue (‘AI’) approved by the Ada
standardization group (ISO/IEC JTC1/SC22/WG9) for inclusion in Ada 2012.
The features are ordered based on the relevant sections of the Ada
Reference Manual (“RM”).  When a given AI relates to multiple points in
the RM, the earliest is used.

A complete description of the AIs may be found in
‘http://www.ada-auth.org/ai05-summary.html’.

   * `AI-0176 Quantified expressions (2010-09-29)'

     Both universally and existentially quantified expressions are
     implemented.  They use the new syntax for iterators proposed in
     AI05-139-2, as well as the standard Ada loop syntax.

     RM References: 1.01.04 (12) 2.09 (2/2) 4.04 (7) 4.05.09 (0)

   * `AI-0079 Allow other_format characters in source (2010-07-10)'

     Wide characters in the unicode category `other_format' are now
     allowed in source programs between tokens, but not within a token
     such as an identifier.

     RM References: 2.01 (4/2) 2.02 (7)

   * `AI-0091 Do not allow other_format in identifiers (0000-00-00)'

     Wide characters in the unicode category `other_format' are not
     permitted within an identifier, since this can be a security
     problem.  The error message for this case has been improved to be
     more specific, but GNAT has never allowed such characters to appear
     in identifiers.

     RM References: 2.03 (3.1/2) 2.03 (4/2) 2.03 (5/2) 2.03 (5.1/2) 2.03
     (5.2/2) 2.03 (5.3/2) 2.09 (2/2)

   * `AI-0100 Placement of pragmas (2010-07-01)'

     This AI is an earlier version of AI-163.  It simplifies the rules
     for legal placement of pragmas.  In the case of lists that allow
     pragmas, if the list may have no elements, then the list may
     consist solely of pragmas.

     RM References: 2.08 (7)

   * `AI-0163 Pragmas in place of null (2010-07-01)'

     A statement sequence may be composed entirely of pragmas.  It is no
     longer necessary to add a dummy ‘null’ statement to make the
     sequence legal.

     RM References: 2.08 (7) 2.08 (16)

   * `AI-0080 ‘View of’ not needed if clear from context (0000-00-00)'

     This is an editorial change only, described as non-testable in the
     AI.

     RM References: 3.01 (7)

   * `AI-0183 Aspect specifications (2010-08-16)'

     Aspect specifications have been fully implemented except for pre
     and post- conditions, and type invariants, which have their own
     separate AI’s.  All forms of declarations listed in the AI are
     supported.  The following is a list of the aspects supported (with
     GNAT implementation aspects marked)

Supported Aspect                         Source
                                         
---------------------------------------------------------
                                         
‘Ada_2005’                               – GNAT
                                         
                                         
‘Ada_2012’                               – GNAT
                                         
                                         
‘Address’

‘Alignment’

‘Atomic’

‘Atomic_Components’

‘Bit_Order’

‘Component_Size’

‘Contract_Cases’                         – GNAT
                                         
                                         
‘Discard_Names’

‘External_Tag’

‘Favor_Top_Level’                        – GNAT
                                         
                                         
‘Inline’

‘Inline_Always’                          – GNAT
                                         
                                         
‘Invariant’                              – GNAT
                                         
                                         
‘Machine_Radix’

‘No_Return’

‘Object_Size’                            – GNAT
                                         
                                         
‘Pack’

‘Persistent_BSS’                         – GNAT
                                         
                                         
‘Post’

‘Pre’

‘Predicate’

‘Preelaborable_Initialization’

‘Pure_Function’                          – GNAT
                                         
                                         
‘Remote_Access_Type’                     – GNAT
                                         
                                         
‘Shared’                                 – GNAT
                                         
                                         
‘Size’

‘Storage_Pool’

‘Storage_Size’

‘Stream_Size’

‘Suppress’

‘Suppress_Debug_Info’                    – GNAT
                                         
                                         
‘Test_Case’                              – GNAT
                                         
                                         
‘Thread_Local_Storage’                   – GNAT
                                         
                                         
‘Type_Invariant’

‘Unchecked_Union’

‘Universal_Aliasing’                     – GNAT
                                         
                                         
‘Unmodified’                             – GNAT
                                         
                                         
‘Unreferenced’                           – GNAT
                                         
                                         
‘Unreferenced_Objects’                   – GNAT
                                         
                                         
‘Unsuppress’

‘Value_Size’                             – GNAT
                                         
                                         
‘Volatile’

‘Volatile_Components’

‘Warnings’                               – GNAT
                                         

     Note that for aspects with an expression, e.g.  ‘Size’, the
     expression is treated like a default expression (visibility is
     analyzed at the point of occurrence of the aspect, but evaluation
     of the expression occurs at the freeze point of the entity
     involved).

     RM References: 3.02.01 (3) 3.02.02 (2) 3.03.01 (2/2) 3.08 (6)
     3.09.03 (1.1/2) 6.01 (2/2) 6.07 (2/2) 9.05.02 (2/2) 7.01 (3) 7.03
     (2) 7.03 (3) 9.01 (2/2) 9.01 (3/2) 9.04 (2/2) 9.04 (3/2) 9.05.02
     (2/2) 11.01 (2) 12.01 (3) 12.03 (2/2) 12.04 (2/2) 12.05 (2) 12.06
     (2.1/2) 12.06 (2.2/2) 12.07 (2) 13.01 (0.1/2) 13.03 (5/1) 13.03.01
     (0)

   * `AI-0128 Inequality is a primitive operation (0000-00-00)'

     If an equality operator (“=”) is declared for a type, then the
     implicitly declared inequality operator (“/=”) is a primitive
     operation of the type.  This is the only reasonable interpretation,
     and is the one always implemented by GNAT, but the RM was not
     entirely clear in making this point.

     RM References: 3.02.03 (6) 6.06 (6)

   * `AI-0003 Qualified expressions as names (2010-07-11)'

     In Ada 2012, a qualified expression is considered to be
     syntactically a name, meaning that constructs such as ‘A'(F(X)).B’
     are now legal.  This is useful in disambiguating some cases of
     overloading.

     RM References: 3.03 (11) 3.03 (21) 4.01 (2) 4.04 (7) 4.07 (3) 5.04
     (7)

   * `AI-0120 Constant instance of protected object (0000-00-00)'

     This is an RM editorial change only.  The section that lists
     objects that are constant failed to include the current instance of
     a protected object within a protected function.  This has always
     been treated as a constant in GNAT.

     RM References: 3.03 (21)

   * `AI-0008 General access to constrained objects (0000-00-00)'

     The wording in the RM implied that if you have a general access to
     a constrained object, it could be used to modify the discriminants.
     This was obviously not intended.  ‘Constraint_Error’ should be
     raised, and GNAT has always done so in this situation.

     RM References: 3.03 (23) 3.10.02 (26/2) 4.01 (9) 6.04.01 (17)
     8.05.01 (5/2)

   * `AI-0093 Additional rules use immutably limited (0000-00-00)'

     This is an editorial change only, to make more widespread use of
     the Ada 2012 ‘immutably limited’.

     RM References: 3.03 (23.4/3)

   * `AI-0096 Deriving from formal private types (2010-07-20)'

     In general it is illegal for a type derived from a formal limited
     type to be nonlimited.  This AI makes an exception to this rule:
     derivation is legal if it appears in the private part of the
     generic, and the formal type is not tagged.  If the type is tagged,
     the legality check must be applied to the private part of the
     package.

     RM References: 3.04 (5.1/2) 6.02 (7)

   * `AI-0181 Soft hyphen is a non-graphic character (2010-07-23)'

     From Ada 2005 on, soft hyphen is considered a non-graphic
     character, which means that it has a special name (‘SOFT_HYPHEN’)
     in conjunction with the ‘Image’ and ‘Value’ attributes for the
     character types.  Strictly speaking this is an inconsistency with
     Ada 95, but in practice the use of these attributes is so obscure
     that it will not cause problems.

     RM References: 3.05.02 (2/2) A.01 (35/2) A.03.03 (21)

   * `AI-0182 Additional forms for' ‘Character'Value’ `(0000-00-00)'

     This AI allows ‘Character'Value’ to accept the string ‘'?'’ where
     ‘?’ is any character including non-graphic control characters.
     GNAT has always accepted such strings.  It also allows strings such
     as ‘HEX_00000041’ to be accepted, but GNAT does not take advantage
     of this permission and raises ‘Constraint_Error’, as is certainly
     still permitted.

     RM References: 3.05 (56/2)

   * `AI-0214 Defaulted discriminants for limited tagged (2010-10-01)'

     Ada 2012 relaxes the restriction that forbids discriminants of
     tagged types to have default expressions by allowing them when the
     type is limited.  It is often useful to define a default value for
     a discriminant even though it can’t be changed by assignment.

     RM References: 3.07 (9.1/2) 3.07.02 (3)

   * `AI-0102 Some implicit conversions are illegal (0000-00-00)'

     It is illegal to assign an anonymous access constant to an
     anonymous access variable.  The RM did not have a clear rule to
     prevent this, but GNAT has always generated an error for this
     usage.

     RM References: 3.07 (16) 3.07.01 (9) 6.04.01 (6) 8.06 (27/2)

   * `AI-0158 Generalizing membership tests (2010-09-16)'

     This AI extends the syntax of membership tests to simplify complex
     conditions that can be expressed as membership in a subset of
     values of any type.  It introduces syntax for a list of expressions
     that may be used in loop contexts as well.

     RM References: 3.08.01 (5) 4.04 (3) 4.05.02 (3) 4.05.02 (5) 4.05.02
     (27)

   * `AI-0173 Testing if tags represent abstract types (2010-07-03)'

     The function ‘Ada.Tags.Type_Is_Abstract’ returns ‘True’ if invoked
     with the tag of an abstract type, and ‘False’ otherwise.

     RM References: 3.09 (7.4/2) 3.09 (12.4/2)

   * `AI-0076 function with controlling result (0000-00-00)'

     This is an editorial change only.  The RM defines calls with
     controlling results, but uses the term ‘function with controlling
     result’ without an explicit definition.

     RM References: 3.09.02 (2/2)

   * `AI-0126 Dispatching with no declared operation (0000-00-00)'

     This AI clarifies dispatching rules, and simply confirms that
     dispatching executes the operation of the parent type when there is
     no explicitly or implicitly declared operation for the descendant
     type.  This has always been the case in all versions of GNAT.

     RM References: 3.09.02 (20/2) 3.09.02 (20.1/2) 3.09.02 (20.2/2)

   * `AI-0097 Treatment of abstract null extension (2010-07-19)'

     The RM as written implied that in some cases it was possible to
     create an object of an abstract type, by having an abstract
     extension inherit a non- abstract constructor from its parent type.
     This mistake has been corrected in GNAT and in the RM, and this
     construct is now illegal.

     RM References: 3.09.03 (4/2)

   * `AI-0203 Extended return cannot be abstract (0000-00-00)'

     A return_subtype_indication cannot denote an abstract subtype.
     GNAT has never permitted such usage.

     RM References: 3.09.03 (8/3)

   * `AI-0198 Inheriting abstract operators (0000-00-00)'

     This AI resolves a conflict between two rules involving inherited
     abstract operations and predefined operators.  If a derived numeric
     type inherits an abstract operator, it overrides the predefined
     one.  This interpretation was always the one implemented in GNAT.

     RM References: 3.09.03 (4/3)

   * `AI-0073 Functions returning abstract types (2010-07-10)'

     This AI covers a number of issues regarding returning abstract
     types.  In particular generic functions cannot have abstract result
     types or access result types designated an abstract type.  There
     are some other cases which are detailed in the AI. Note that this
     binding interpretation has not been retrofitted to operate before
     Ada 2012 mode, since it caused a significant number of regressions.

     RM References: 3.09.03 (8) 3.09.03 (10) 6.05 (8/2)

   * `AI-0070 Elaboration of interface types (0000-00-00)'

     This is an editorial change only, there are no testable
     consequences short of checking for the absence of generated code
     for an interface declaration.

     RM References: 3.09.04 (18/2)

   * `AI-0208 Characteristics of incomplete views (0000-00-00)'

     The wording in the Ada 2005 RM concerning characteristics of
     incomplete views was incorrect and implied that some programs
     intended to be legal were now illegal.  GNAT had never considered
     such programs illegal, so it has always implemented the intent of
     this AI.

     RM References: 3.10.01 (2.4/2) 3.10.01 (2.6/2)

   * `AI-0162 Incomplete type completed by partial view (2010-09-15)'

     Incomplete types are made more useful by allowing them to be
     completed by private types and private extensions.

     RM References: 3.10.01 (2.5/2) 3.10.01 (2.6/2) 3.10.01 (3) 3.10.01
     (4/2)

   * `AI-0098 Anonymous subprogram access restrictions (0000-00-00)'

     An unintentional omission in the RM implied some inconsistent
     restrictions on the use of anonymous access to subprogram values.
     These restrictions were not intentional, and have never been
     enforced by GNAT.

     RM References: 3.10.01 (6) 3.10.01 (9.2/2)

   * `AI-0199 Aggregate with anonymous access components (2010-07-14)'

     A choice list in a record aggregate can include several components
     of (distinct) anonymous access types as long as they have matching
     designated subtypes.

     RM References: 4.03.01 (16)

   * `AI-0220 Needed components for aggregates (0000-00-00)'

     This AI addresses a wording problem in the RM that appears to
     permit some complex cases of aggregates with nonstatic
     discriminants.  GNAT has always implemented the intended semantics.

     RM References: 4.03.01 (17)

   * `AI-0147 Conditional expressions (2009-03-29)'

     Conditional expressions are permitted.  The form of such an
     expression is:

          (if expr then expr {elsif expr then expr} [else expr])

     The parentheses can be omitted in contexts where parentheses are
     present anyway, such as subprogram arguments and pragma arguments.
     If the `else' clause is omitted, `else' `True' is assumed; thus
     ‘(if A then B)’ is a way to conveniently represent `(A implies B)'
     in standard logic.

     RM References: 4.03.03 (15) 4.04 (1) 4.04 (7) 4.05.07 (0) 4.07 (2)
     4.07 (3) 4.09 (12) 4.09 (33) 5.03 (3) 5.03 (4) 7.05 (2.1/2)

   * `AI-0037 Out-of-range box associations in aggregate (0000-00-00)'

     This AI confirms that an association of the form ‘Indx => <>’ in an
     array aggregate must raise ‘Constraint_Error’ if ‘Indx’ is out of
     range.  The RM specified a range check on other associations, but
     not when the value of the association was defaulted.  GNAT has
     always inserted a constraint check on the index value.

     RM References: 4.03.03 (29)

   * `AI-0123 Composability of equality (2010-04-13)'

     Equality of untagged record composes, so that the predefined
     equality for a composite type that includes a component of some
     untagged record type ‘R’ uses the equality operation of ‘R’ (which
     may be user-defined or predefined).  This makes the behavior of
     untagged records identical to that of tagged types in this respect.

     This change is an incompatibility with previous versions of Ada,
     but it corrects a non-uniformity that was often a source of
     confusion.  Analysis of a large number of industrial programs
     indicates that in those rare cases where a composite type had an
     untagged record component with a user-defined equality, either
     there was no use of the composite equality, or else the code
     expected the same composability as for tagged types, and thus had a
     bug that would be fixed by this change.

     RM References: 4.05.02 (9.7/2) 4.05.02 (14) 4.05.02 (15) 4.05.02
     (24) 8.05.04 (8)

   * `AI-0088 The value of exponentiation (0000-00-00)'

     This AI clarifies the equivalence rule given for the dynamic
     semantics of exponentiation: the value of the operation can be
     obtained by repeated multiplication, but the operation can be
     implemented otherwise (for example using the familiar
     divide-by-two-and-square algorithm, even if this is less accurate),
     and does not imply repeated reads of a volatile base.

     RM References: 4.05.06 (11)

   * `AI-0188 Case expressions (2010-01-09)'

     Case expressions are permitted.  This allows use of constructs such
     as:

          X := (case Y is when 1 => 2, when 2 => 3, when others => 31)

     RM References: 4.05.07 (0) 4.05.08 (0) 4.09 (12) 4.09 (33)

   * `AI-0104 Null exclusion and uninitialized allocator (2010-07-15)'

     The assignment ‘Ptr := new not null Some_Ptr;’ will raise
     ‘Constraint_Error’ because the default value of the allocated
     object is `null'.  This useless construct is illegal in Ada 2012.

     RM References: 4.08 (2)

   * `AI-0157 Allocation/Deallocation from empty pool (2010-07-11)'

     Allocation and Deallocation from an empty storage pool (i.e.
     allocation or deallocation of a pointer for which a static storage
     size clause of zero has been given) is now illegal and is detected
     as such.  GNAT previously gave a warning but not an error.

     RM References: 4.08 (5.3/2) 13.11.02 (4) 13.11.02 (17)

   * `AI-0179 Statement not required after label (2010-04-10)'

     It is not necessary to have a statement following a label, so a
     label can appear at the end of a statement sequence without the
     need for putting a null statement afterwards, but it is not
     allowable to have only labels and no real statements in a statement
     sequence.

     RM References: 5.01 (2)

   * `AI-0139-2 Syntactic sugar for iterators (2010-09-29)'

     The new syntax for iterating over arrays and containers is now
     implemented.  Iteration over containers is for now limited to
     read-only iterators.  Only default iterators are supported, with
     the syntax: ‘for Elem of C’.

     RM References: 5.05

   * `AI-0134 Profiles must match for full conformance (0000-00-00)'

     For full conformance, the profiles of
     anonymous-access-to-subprogram parameters must match.  GNAT has
     always enforced this rule.

     RM References: 6.03.01 (18)

   * `AI-0207 Mode conformance and access constant (0000-00-00)'

     This AI confirms that access_to_constant indication must match for
     mode conformance.  This was implemented in GNAT when the qualifier
     was originally introduced in Ada 2005.

     RM References: 6.03.01 (16/2)

   * `AI-0046 Null exclusion match for full conformance (2010-07-17)'

     For full conformance, in the case of access parameters, the null
     exclusion must match (either both or neither must have ‘not null’).

     RM References: 6.03.02 (18)

   * `AI-0118 The association of parameter associations (0000-00-00)'

     This AI clarifies the rules for named associations in subprogram
     calls and generic instantiations.  The rules have been in place
     since Ada 83.

     RM References: 6.04.01 (2) 12.03 (9)

   * `AI-0196 Null exclusion tests for out parameters (0000-00-00)'

     Null exclusion checks are not made for ‘out’ parameters when
     evaluating the actual parameters.  GNAT has never generated these
     checks.

     RM References: 6.04.01 (13)

   * `AI-0015 Constant return objects (0000-00-00)'

     The return object declared in an `extended_return_statement' may be
     declared constant.  This was always intended, and GNAT has always
     allowed it.

     RM References: 6.05 (2.1/2) 3.03 (10/2) 3.03 (21) 6.05 (5/2) 6.05
     (5.7/2)

   * `AI-0032 Extended return for class-wide functions (0000-00-00)'

     If a function returns a class-wide type, the object of an extended
     return statement can be declared with a specific type that is
     covered by the class- wide type.  This has been implemented in GNAT
     since the introduction of extended returns.  Note AI-0103
     complements this AI by imposing matching rules for constrained
     return types.

     RM References: 6.05 (5.2/2) 6.05 (5.3/2) 6.05 (5.6/2) 6.05 (5.8/2)
     6.05 (8/2)

   * `AI-0103 Static matching for extended return (2010-07-23)'

     If the return subtype of a function is an elementary type or a
     constrained type, the subtype indication in an extended return
     statement must match statically this return subtype.

     RM References: 6.05 (5.2/2)

   * `AI-0058 Abnormal completion of an extended return (0000-00-00)'

     The RM had some incorrect wording implying wrong treatment of
     abnormal completion in an extended return.  GNAT has always
     implemented the intended correct semantics as described by this AI.

     RM References: 6.05 (22/2)

   * `AI-0050 Raising Constraint_Error early for function call
     (0000-00-00)'

     The implementation permissions for raising ‘Constraint_Error’ early
     on a function call when it was clear an exception would be raised
     were over-permissive and allowed mishandling of discriminants in
     some cases.  GNAT did not take advantage of these incorrect
     permissions in any case.

     RM References: 6.05 (24/2)

   * `AI-0125 Nonoverridable operations of an ancestor (2010-09-28)'

     In Ada 2012, the declaration of a primitive operation of a type
     extension or private extension can also override an inherited
     primitive that is not visible at the point of this declaration.

     RM References: 7.03.01 (6) 8.03 (23) 8.03.01 (5/2) 8.03.01 (6/2)

   * `AI-0062 Null exclusions and deferred constants (0000-00-00)'

     A full constant may have a null exclusion even if its associated
     deferred constant does not.  GNAT has always allowed this.

     RM References: 7.04 (6/2) 7.04 (7.1/2)

   * `AI-0178 Incomplete views are limited (0000-00-00)'

     This AI clarifies the role of incomplete views and plugs an
     omission in the RM. GNAT always correctly restricted the use of
     incomplete views and types.

     RM References: 7.05 (3/2) 7.05 (6/2)

   * `AI-0087 Actual for formal nonlimited derived type (2010-07-15)'

     The actual for a formal nonlimited derived type cannot be limited.
     In particular, a formal derived type that extends a limited
     interface but which is not explicitly limited cannot be
     instantiated with a limited type.

     RM References: 7.05 (5/2) 12.05.01 (5.1/2)

   * `AI-0099 Tag determines whether finalization needed (0000-00-00)'

     This AI clarifies that ‘needs finalization’ is part of dynamic
     semantics, and therefore depends on the run-time characteristics of
     an object (i.e.  its tag) and not on its nominal type.  As the AI
     indicates: “we do not expect this to affect any implementation’’.

     RM References: 7.06.01 (6) 7.06.01 (7) 7.06.01 (8) 7.06.01 (9/2)

   * `AI-0064 Redundant finalization rule (0000-00-00)'

     This is an editorial change only.  The intended behavior is already
     checked by an existing ACATS test, which GNAT has always executed
     correctly.

     RM References: 7.06.01 (17.1/1)

   * `AI-0026 Missing rules for Unchecked_Union (2010-07-07)'

     Record representation clauses concerning Unchecked_Union types
     cannot mention the discriminant of the type.  The type of a
     component declared in the variant part of an Unchecked_Union cannot
     be controlled, have controlled components, nor have protected or
     task parts.  If an Unchecked_Union type is declared within the body
     of a generic unit or its descendants, then the type of a component
     declared in the variant part cannot be a formal private type or a
     formal private extension declared within the same generic unit.

     RM References: 7.06 (9.4/2) B.03.03 (9/2) B.03.03 (10/2)

   * `AI-0205 Extended return declares visible name (0000-00-00)'

     This AI corrects a simple omission in the RM. Return objects have
     always been visible within an extended return statement.

     RM References: 8.03 (17)

   * `AI-0042 Overriding versus implemented-by (0000-00-00)'

     This AI fixes a wording gap in the RM. An operation of a
     synchronized interface can be implemented by a protected or task
     entry, but the abstract operation is not being overridden in the
     usual sense, and it must be stated separately that this
     implementation is legal.  This has always been the case in GNAT.

     RM References: 9.01 (9.2/2) 9.04 (11.1/2)

   * `AI-0030 Requeue on synchronized interfaces (2010-07-19)'

     Requeue is permitted to a protected, synchronized or task interface
     primitive providing it is known that the overriding operation is an
     entry.  Otherwise the requeue statement has the same effect as a
     procedure call.  Use of pragma ‘Implemented’ provides a way to
     impose a static requirement on the overriding operation by adhering
     to one of the implementation kinds: entry, protected procedure or
     any of the above.

     RM References: 9.05 (9) 9.05.04 (2) 9.05.04 (3) 9.05.04 (5) 9.05.04
     (6) 9.05.04 (7) 9.05.04 (12)

   * `AI-0201 Independence of atomic object components (2010-07-22)'

     If an Atomic object has a pragma ‘Pack’ or a ‘Component_Size’
     attribute, then individual components may not be addressable by
     independent tasks.  However, if the representation clause has no
     effect (is confirming), then independence is not compromised.
     Furthermore, in GNAT, specification of other appropriately
     addressable component sizes (e.g.  16 for 8-bit characters) also
     preserves independence.  GNAT now gives very clear warnings both
     for the declaration of such a type, and for any assignment to its
     components.

     RM References: 9.10 (1/3) C.06 (22/2) C.06 (23/2)

   * `AI-0009 Pragma Independent[_Components] (2010-07-23)'

     This AI introduces the new pragmas ‘Independent’ and
     ‘Independent_Components’, which control guaranteeing independence
     of access to objects and components.  The AI also requires
     independence not unaffected by confirming rep clauses.

     RM References: 9.10 (1) 13.01 (15/1) 13.02 (9) 13.03 (13) C.06 (2)
     C.06 (4) C.06 (6) C.06 (9) C.06 (13) C.06 (14)

   * `AI-0072 Task signalling using ‘Terminated (0000-00-00)'

     This AI clarifies that task signalling for reading ‘'Terminated’
     only occurs if the result is True.  GNAT semantics has always been
     consistent with this notion of task signalling.

     RM References: 9.10 (6.1/1)

   * `AI-0108 Limited incomplete view and discriminants (0000-00-00)'

     This AI confirms that an incomplete type from a limited view does
     not have discriminants.  This has always been the case in GNAT.

     RM References: 10.01.01 (12.3/2)

   * `AI-0129 Limited views and incomplete types (0000-00-00)'

     This AI clarifies the description of limited views: a limited view
     of a package includes only one view of a type that has an
     incomplete declaration and a full declaration (there is no possible
     ambiguity in a client package).  This AI also fixes an omission: a
     nested package in the private part has no limited view.  GNAT
     always implemented this correctly.

     RM References: 10.01.01 (12.2/2) 10.01.01 (12.3/2)

   * `AI-0077 Limited withs and scope of declarations (0000-00-00)'

     This AI clarifies that a declaration does not include a context
     clause, and confirms that it is illegal to have a context in which
     both a limited and a nonlimited view of a package are accessible.
     Such double visibility was always rejected by GNAT.

     RM References: 10.01.02 (12/2) 10.01.02 (21/2) 10.01.02 (22/2)

   * `AI-0122 Private with and children of generics (0000-00-00)'

     This AI clarifies the visibility of private children of generic
     units within instantiations of a parent.  GNAT has always handled
     this correctly.

     RM References: 10.01.02 (12/2)

   * `AI-0040 Limited with clauses on descendant (0000-00-00)'

     This AI confirms that a limited with clause in a child unit cannot
     name an ancestor of the unit.  This has always been checked in
     GNAT.

     RM References: 10.01.02 (20/2)

   * `AI-0132 Placement of library unit pragmas (0000-00-00)'

     This AI fills a gap in the description of library unit pragmas.
     The pragma clearly must apply to a library unit, even if it does
     not carry the name of the enclosing unit.  GNAT has always enforced
     the required check.

     RM References: 10.01.05 (7)

   * `AI-0034 Categorization of limited views (0000-00-00)'

     The RM makes certain limited with clauses illegal because of
     categorization considerations, when the corresponding normal with
     would be legal.  This is not intended, and GNAT has always
     implemented the recommended behavior.

     RM References: 10.02.01 (11/1) 10.02.01 (17/2)

   * `AI-0035 Inconsistencies with Pure units (0000-00-00)'

     This AI remedies some inconsistencies in the legality rules for
     Pure units.  Derived access types are legal in a pure unit (on the
     assumption that the rule for a zero storage pool size has been
     enforced on the ancestor type).  The rules are enforced in generic
     instances and in subunits.  GNAT has always implemented the
     recommended behavior.

     RM References: 10.02.01 (15.1/2) 10.02.01 (15.4/2) 10.02.01
     (15.5/2) 10.02.01 (17/2)

   * `AI-0219 Pure permissions and limited parameters (2010-05-25)'

     This AI refines the rules for the cases with limited parameters
     which do not allow the implementations to omit ‘redundant’.  GNAT
     now properly conforms to the requirements of this binding
     interpretation.

     RM References: 10.02.01 (18/2)

   * `AI-0043 Rules about raising exceptions (0000-00-00)'

     This AI covers various omissions in the RM regarding the raising of
     exceptions.  GNAT has always implemented the intended semantics.

     RM References: 11.04.01 (10.1/2) 11 (2)

   * `AI-0200 Mismatches in formal package declarations (0000-00-00)'

     This AI plugs a gap in the RM which appeared to allow some
     obviously intended illegal instantiations.  GNAT has never allowed
     these instantiations.

     RM References: 12.07 (16)

   * `AI-0112 Detection of duplicate pragmas (2010-07-24)'

     This AI concerns giving names to various representation aspects,
     but the practical effect is simply to make the use of duplicate
     ‘Atomic[_Components]’, ‘Volatile[_Components]’, and
     ‘Independent[_Components]’ pragmas illegal, and GNAT now performs
     this required check.

     RM References: 13.01 (8)

   * `AI-0106 No representation pragmas on generic formals (0000-00-00)'

     The RM appeared to allow representation pragmas on generic formal
     parameters, but this was not intended, and GNAT has never permitted
     this usage.

     RM References: 13.01 (9.1/1)

   * `AI-0012 Pack/Component_Size for aliased/atomic (2010-07-15)'

     It is now illegal to give an inappropriate component size or a
     pragma ‘Pack’ that attempts to change the component size in the
     case of atomic or aliased components.  Previously GNAT ignored such
     an attempt with a warning.

     RM References: 13.02 (6.1/2) 13.02 (7) C.06 (10) C.06 (11) C.06
     (21)

   * `AI-0039 Stream attributes cannot be dynamic (0000-00-00)'

     The RM permitted the use of dynamic expressions (such as
     ‘ptr.all’)‘ for stream attributes, but these were never useful and
     are now illegal.  GNAT has always regarded such expressions as
     illegal.

     RM References: 13.03 (4) 13.03 (6) 13.13.02 (38/2)

   * `AI-0095 Address of intrinsic subprograms (0000-00-00)'

     The prefix of ‘'Address’ cannot statically denote a subprogram with
     convention ‘Intrinsic’.  The use of the ‘Address’ attribute raises
     ‘Program_Error’ if the prefix denotes a subprogram with convention
     ‘Intrinsic’.

     RM References: 13.03 (11/1)

   * `AI-0116 Alignment of class-wide objects (0000-00-00)'

     This AI requires that the alignment of a class-wide object be no
     greater than the alignment of any type in the class.  GNAT has
     always followed this recommendation.

     RM References: 13.03 (29) 13.11 (16)

   * `AI-0146 Type invariants (2009-09-21)'

     Type invariants may be specified for private types using the aspect
     notation.  Aspect ‘Type_Invariant’ may be specified for any private
     type, ‘Type_Invariant'Class’ can only be specified for tagged
     types, and is inherited by any descendent of the tagged types.  The
     invariant is a boolean expression that is tested for being true in
     the following situations: conversions to the private type, object
     declarations for the private type that are default initialized, and
     [`in'] `out' parameters and returned result on return from any
     primitive operation for the type that is visible to a client.  GNAT
     defines the synonyms ‘Invariant’ for ‘Type_Invariant’ and
     ‘Invariant'Class’ for ‘Type_Invariant'Class’.

     RM References: 13.03.03 (00)

   * `AI-0078 Relax Unchecked_Conversion alignment rules (0000-00-00)'

     In Ada 2012, compilers are required to support unchecked conversion
     where the target alignment is a multiple of the source alignment.
     GNAT always supported this case (and indeed all cases of differing
     alignments, doing copies where required if the alignment was
     reduced).

     RM References: 13.09 (7)

   * `AI-0195 Invalid value handling is implementation defined
     (2010-07-03)'

     The handling of invalid values is now designated to be
     implementation defined.  This is a documentation change only,
     requiring Annex M in the GNAT Reference Manual to document this
     handling.  In GNAT, checks for invalid values are made only when
     necessary to avoid erroneous behavior.  Operations like assignments
     which cannot cause erroneous behavior ignore the possibility of
     invalid values and do not do a check.  The date given above applies
     only to the documentation change, this behavior has always been
     implemented by GNAT.

     RM References: 13.09.01 (10)

   * `AI-0193 Alignment of allocators (2010-09-16)'

     This AI introduces a new attribute ‘Max_Alignment_For_Allocation’,
     analogous to ‘Max_Size_In_Storage_Elements’, but for alignment
     instead of size.

     RM References: 13.11 (16) 13.11 (21) 13.11.01 (0) 13.11.01 (1)
     13.11.01 (2) 13.11.01 (3)

   * `AI-0177 Parameterized expressions (2010-07-10)'

     The new Ada 2012 notion of parameterized expressions is
     implemented.  The form is:

          function-specification is (expression)

     This is exactly equivalent to the corresponding function body that
     returns the expression, but it can appear in a package spec.  Note
     that the expression must be parenthesized.

     RM References: 13.11.01 (3/2)

   * `AI-0033 Attach/Interrupt_Handler in generic (2010-07-24)'

     Neither of these two pragmas may appear within a generic template,
     because the generic might be instantiated at other than the library
     level.

     RM References: 13.11.02 (16) C.03.01 (7/2) C.03.01 (8/2)

   * `AI-0161 Restriction No_Default_Stream_Attributes (2010-09-11)'

     A new restriction ‘No_Default_Stream_Attributes’ prevents the use
     of any of the default stream attributes for elementary types.  If
     this restriction is in force, then it is necessary to provide
     explicit subprograms for any stream attributes used.

     RM References: 13.12.01 (4/2) 13.13.02 (40/2) 13.13.02 (52/2)

   * `AI-0194 Value of Stream_Size attribute (0000-00-00)'

     The ‘Stream_Size’ attribute returns the default number of bits in
     the stream representation of the given type.  This value is not
     affected by the presence of stream subprogram attributes for the
     type.  GNAT has always implemented this interpretation.

     RM References: 13.13.02 (1.2/2)

   * `AI-0109 Redundant check in S’Class’Input (0000-00-00)'

     This AI is an editorial change only.  It removes the need for a tag
     check that can never fail.

     RM References: 13.13.02 (34/2)

   * `AI-0007 Stream read and private scalar types (0000-00-00)'

     The RM as written appeared to limit the possibilities of declaring
     read attribute procedures for private scalar types.  This
     limitation was not intended, and has never been enforced by GNAT.

     RM References: 13.13.02 (50/2) 13.13.02 (51/2)

   * `AI-0065 Remote access types and external streaming (0000-00-00)'

     This AI clarifies the fact that all remote access types support
     external streaming.  This fixes an obvious oversight in the
     definition of the language, and GNAT always implemented the
     intended correct rules.

     RM References: 13.13.02 (52/2)

   * `AI-0019 Freezing of primitives for tagged types (0000-00-00)'

     The RM suggests that primitive subprograms of a specific tagged
     type are frozen when the tagged type is frozen.  This would be an
     incompatible change and is not intended.  GNAT has never attempted
     this kind of freezing and its behavior is consistent with the
     recommendation of this AI.

     RM References: 13.14 (2) 13.14 (3/1) 13.14 (8.1/1) 13.14 (10) 13.14
     (14) 13.14 (15.1/2)

   * `AI-0017 Freezing and incomplete types (0000-00-00)'

     So-called ‘Taft-amendment types’ (i.e., types that are completed in
     package bodies) are not frozen by the occurrence of bodies in the
     enclosing declarative part.  GNAT always implemented this properly.

     RM References: 13.14 (3/1)

   * `AI-0060 Extended definition of remote access types (0000-00-00)'

     This AI extends the definition of remote access types to include
     access to limited, synchronized, protected or task class-wide
     interface types.  GNAT already implemented this extension.

     RM References: A (4) E.02.02 (9/1) E.02.02 (9.2/1) E.02.02 (14/2)
     E.02.02 (18)

   * `AI-0114 Classification of letters (0000-00-00)'

     The code points 170 (‘FEMININE ORDINAL INDICATOR’), 181 (‘MICRO
     SIGN’), and 186 (‘MASCULINE ORDINAL INDICATOR’) are technically
     considered lower case letters by Unicode.  However, they are not
     allowed in identifiers, and they return ‘False’ to
     ‘Ada.Characters.Handling.Is_Letter/Is_Lower’.  This behavior is
     consistent with that defined in Ada 95.

     RM References: A.03.02 (59) A.04.06 (7)

   * `AI-0185 Ada.Wide_[Wide_]Characters.Handling (2010-07-06)'

     Two new packages ‘Ada.Wide_[Wide_]Characters.Handling’ provide
     classification functions for ‘Wide_Character’ and
     ‘Wide_Wide_Character’, as well as providing case folding routines
     for ‘Wide_[Wide_]Character’ and ‘Wide_[Wide_]String’.

     RM References: A.03.05 (0) A.03.06 (0)

   * `AI-0031 Add From parameter to Find_Token (2010-07-25)'

     A new version of ‘Find_Token’ is added to all relevant string
     packages, with an extra parameter ‘From’.  Instead of starting at
     the first character of the string, the search for a matching Token
     starts at the character indexed by the value of ‘From’.  These
     procedures are available in all versions of Ada but if used in
     versions earlier than Ada 2012 they will generate a warning that an
     Ada 2012 subprogram is being used.

     RM References: A.04.03 (16) A.04.03 (67) A.04.03 (68/1) A.04.04
     (51) A.04.05 (46)

   * `AI-0056 Index on null string returns zero (0000-00-00)'

     The wording in the Ada 2005 RM implied an incompatible handling of
     the ‘Index’ functions, resulting in raising an exception instead of
     returning zero in some situations.  This was not intended and has
     been corrected.  GNAT always returned zero, and is thus consistent
     with this AI.

     RM References: A.04.03 (56.2/2) A.04.03 (58.5/2)

   * `AI-0137 String encoding package (2010-03-25)'

     The packages ‘Ada.Strings.UTF_Encoding’, together with its child
     packages, ‘Conversions’, ‘Strings’, ‘Wide_Strings’, and
     ‘Wide_Wide_Strings’ have been implemented.  These packages (whose
     documentation can be found in the spec files ‘a-stuten.ads’,
     ‘a-suenco.ads’, ‘a-suenst.ads’, ‘a-suewst.ads’, ‘a-suezst.ads’)
     allow encoding and decoding of ‘String’, ‘Wide_String’, and
     ‘Wide_Wide_String’ values using UTF coding schemes (including
     UTF-8, UTF-16LE, UTF-16BE, and UTF-16), as well as conversions
     between the different UTF encodings.  With the exception of
     ‘Wide_Wide_Strings’, these packages are available in Ada 95 and Ada
     2005 mode as well as Ada 2012 mode.  The ‘Wide_Wide_Strings’
     package is available in Ada 2005 mode as well as Ada 2012 mode (but
     not in Ada 95 mode since it uses ‘Wide_Wide_Character’).

     RM References: A.04.11

   * `AI-0038 Minor errors in Text_IO (0000-00-00)'

     These are minor errors in the description on three points.  The
     intent on all these points has always been clear, and GNAT has
     always implemented the correct intended semantics.

     RM References: A.10.05 (37) A.10.07 (8/1) A.10.07 (10) A.10.07 (12)
     A.10.08 (10) A.10.08 (24)

   * `AI-0044 Restrictions on container instantiations (0000-00-00)'

     This AI places restrictions on allowed instantiations of generic
     containers.  These restrictions are not checked by the compiler, so
     there is nothing to change in the implementation.  This affects
     only the RM documentation.

     RM References: A.18 (4/2) A.18.02 (231/2) A.18.03 (145/2) A.18.06
     (56/2) A.18.08 (66/2) A.18.09 (79/2) A.18.26 (5/2) A.18.26 (9/2)

   * `AI-0127 Adding Locale Capabilities (2010-09-29)'

     This package provides an interface for identifying the current
     locale.

     RM References: A.19 A.19.01 A.19.02 A.19.03 A.19.05 A.19.06 A.19.07
     A.19.08 A.19.09 A.19.10 A.19.11 A.19.12 A.19.13

   * `AI-0002 Export C with unconstrained arrays (0000-00-00)'

     The compiler is not required to support exporting an Ada subprogram
     with convention C if there are parameters or a return type of an
     unconstrained array type (such as ‘String’).  GNAT allows such
     declarations but generates warnings.  It is possible, but
     complicated, to write the corresponding C code and certainly such
     code would be specific to GNAT and non-portable.

     RM References: B.01 (17) B.03 (62) B.03 (71.1/2)

   * `AI-0216 No_Task_Hierarchy forbids local tasks (0000-00-00)'

     It is clearly the intention that ‘No_Task_Hierarchy’ is intended to
     forbid tasks declared locally within subprograms, or functions
     returning task objects, and that is the implementation that GNAT
     has always provided.  However the language in the RM was not
     sufficiently clear on this point.  Thus this is a documentation
     change in the RM only.

     RM References: D.07 (3/3)

   * `AI-0211 No_Relative_Delays forbids Set_Handler use (2010-07-09)'

     The restriction ‘No_Relative_Delays’ forbids any calls to the
     subprogram ‘Ada.Real_Time.Timing_Events.Set_Handler’.

     RM References: D.07 (5) D.07 (10/2) D.07 (10.4/2) D.07 (10.7/2)

   * `AI-0190 pragma Default_Storage_Pool (2010-09-15)'

     This AI introduces a new pragma ‘Default_Storage_Pool’, which can
     be used to control storage pools globally.  In particular, you can
     force every access type that is used for allocation (`new') to have
     an explicit storage pool, or you can declare a pool globally to be
     used for all access types that lack an explicit one.

     RM References: D.07 (8)

   * `AI-0189 No_Allocators_After_Elaboration (2010-01-23)'

     This AI introduces a new restriction
     ‘No_Allocators_After_Elaboration’, which says that no dynamic
     allocation will occur once elaboration is completed.  In general
     this requires a run-time check, which is not required, and which
     GNAT does not attempt.  But the static cases of allocators in a
     task body or in the body of the main program are detected and
     flagged at compile or bind time.

     RM References: D.07 (19.1/2) H.04 (23.3/2)

   * `AI-0171 Pragma CPU and Ravenscar Profile (2010-09-24)'

     A new package ‘System.Multiprocessors’ is added, together with the
     definition of pragma ‘CPU’ for controlling task affinity.  A new no
     dependence restriction, on
     ‘System.Multiprocessors.Dispatching_Domains’, is added to the
     Ravenscar profile.

     RM References: D.13.01 (4/2) D.16

   * `AI-0210 Correct Timing_Events metric (0000-00-00)'

     This is a documentation only issue regarding wording of metric
     requirements, that does not affect the implementation of the
     compiler.

     RM References: D.15 (24/2)

   * `AI-0206 Remote types packages and preelaborate (2010-07-24)'

     Remote types packages are now allowed to depend on preelaborated
     packages.  This was formerly considered illegal.

     RM References: E.02.02 (6)

   * `AI-0152 Restriction No_Anonymous_Allocators (2010-09-08)'

     Restriction ‘No_Anonymous_Allocators’ prevents the use of
     allocators where the type of the returned value is an anonymous
     access type.

     RM References: H.04 (8/1)


File: gnat_rm.info,  Node: Security Hardening Features,  Next: Obsolescent Features,  Prev: Implementation of Ada 2012 Features,  Up: Top

17 Security Hardening Features
******************************

This chapter describes Ada extensions aimed at security hardening that
are provided by GNAT.

* Menu:

* Register Scrubbing::
* Stack Scrubbing::
* Hardened Conditionals::


File: gnat_rm.info,  Node: Register Scrubbing,  Next: Stack Scrubbing,  Up: Security Hardening Features

17.1 Register Scrubbing
=======================

GNAT can generate code to zero-out hardware registers before returning
from a subprogram.

It can be enabled with the `-fzero-call-used-regs' command line option,
to affect all subprograms in a compilation, and with a
‘Machine_Attribute’ pragma, to affect only specific subprograms.

     procedure Foo;
     pragma Machine_Attribute (Foo, "zero_call_used_regs", "used");
     --  Before returning, Foo scrubs only call-clobbered registers
     --  that it uses itself.

     function Bar return Integer;
     pragma Machine_Attribute (Bar, "zero_call_used_regs", "all");
     --  Before returning, Bar scrubs all call-clobbered registers.

For usage and more details on the command line option, and on the
‘zero_call_used_regs’ attribute, see ‘Using the GNU Compiler Collection
(GCC)’.


File: gnat_rm.info,  Node: Stack Scrubbing,  Next: Hardened Conditionals,  Prev: Register Scrubbing,  Up: Security Hardening Features

17.2 Stack Scrubbing
====================

GNAT can generate code to zero-out stack frames used by subprograms.

It can be activated with the ‘Machine_Attribute’ pragma, on specific
subprograms and variables.

     function Foo returns Integer;
     pragma Machine_Attribute (Foo, "strub");
     --  Foo and its callers are modified so as to scrub the stack
     --  space used by Foo after it returns.

     procedure Bar;
     pragma Machine_Attribute (Bar, "strub", "internal");
     --  Bar is turned into a wrapper for its original body,
     --  and they scrub the stack used by the original body.

     Var : Integer;
     pragma Machine_Attribute (Var, "strub");
     --  Reading from Var in a subprogram enables stack scrubbing
     --  of the stack space used by the subprogram.

There are also `-fstrub' command line options to control default
settings.  For usage and more details on the command line option, and on
the ‘strub’ attribute, see ‘Using the GNU Compiler Collection (GCC)’.

Note that Ada secondary stacks are not scrubbed.  The restriction
‘No_Secondary_Stack’ avoids their use, and thus their accidental
preservation of data that should be scrubbed.

Attributes ‘Access’ and ‘Unconstrained_Access’ of variables and
constants with ‘strub’ enabled require types with ‘strub’ enabled; there
is no way to express an access-to-strub type otherwise.
‘Unchecked_Access’ bypasses this constraint, but the resulting access
type designates a non-strub type.

     VI : Integer;
     XsVI : access Integer := VI'Access; -- Error.
     UXsVI : access Integer := VI'Unchecked_Access; -- OK,
     -- UXsVI.all does not enable strub in the enclosing subprogram.

     type Strub_Int is new Integer;
     pragma Machine_Attribute (Strub_Int, "strub");
     VSI : Strub_Int;
     XsVSI : access Strub_Int := VSI'Access; -- OK.
     -- XsVSI.all enables strub in the enclosing subprogram.

Every access-to-subprogram type, renaming, and overriding and overridden
dispatching operations that may refer to a subprogram with an
attribute-modified interface must be annotated with the same
interface-modifying attribute.  Access-to-subprogram types can be
explicitly converted to different strub modes, as long as they are
interface-compatible (i.e., adding or removing ‘at-calls’ is not
allowed).  For example, a ‘strub’-‘disabled’ subprogram can be turned
‘callable’ through such an explicit conversion:

     type TBar is access procedure;

     type TBar_Callable is access procedure;
     pragma Machine_Attribute (TBar_Callable, "strub", "callable");

     Bar_Callable_Ptr : constant TBar_Callable
                := TBar_Callable (TBar'(Bar'Access));

     procedure Bar_Callable renames Bar_Callable_Ptr.all;
     pragma Machine_Attribute (Bar_Callable, "strub", "callable");

Note that the renaming declaration is expanded to a full subprogram
body, it won’t be just an alias.  Only if it is inlined will it be as
efficient as a call by dereferencing the access-to-subprogram constant
Bar_Callable_Ptr.


File: gnat_rm.info,  Node: Hardened Conditionals,  Prev: Stack Scrubbing,  Up: Security Hardening Features

17.3 Hardened Conditionals
==========================

GNAT can harden conditionals to protect against control flow attacks.

This is accomplished by two complementary transformations, each
activated by a separate command-line option.

The option `-fharden-compares' enables hardening of compares that
compute results stored in variables, adding verification that the
reversed compare yields the opposite result.

The option `-fharden-conditional-branches' enables hardening of compares
that guard conditional branches, adding verification of the reversed
compare to both execution paths.

These transformations are introduced late in the compilation pipeline,
long after boolean expressions are decomposed into separate compares,
each one turned into either a conditional branch or a compare whose
result is stored in a boolean variable or temporary.  Compiler
optimizations, if enabled, may also turn conditional branches into
stored compares, and vice-versa, or into operations with implied
conditionals (e.g.  MIN and MAX). Conditionals may also be optimized out
entirely, if their value can be determined at compile time, and
occasionally multiple compares can be combined into one.

It is thus difficult to predict which of these two options will affect a
specific compare operation expressed in source code.  Using both options
ensures that every compare that is neither optimized out nor optimized
into implied conditionals will be hardened.

The addition of reversed compares can be observed by enabling the dump
files of the corresponding passes, through command line options
`-fdump-tree-hardcmp' and `-fdump-tree-hardcbr', respectively.

They are separate options, however, because of the significantly
different performance impact of the hardening transformations.


File: gnat_rm.info,  Node: Obsolescent Features,  Next: Compatibility and Porting Guide,  Prev: Security Hardening Features,  Up: Top

18 Obsolescent Features
***********************

This chapter describes features that are provided by GNAT, but are
considered obsolescent since there are preferred ways of achieving the
same effect.  These features are provided solely for historical
compatibility purposes.

* Menu:

* pragma No_Run_Time::
* pragma Ravenscar::
* pragma Restricted_Run_Time::
* pragma Task_Info::
* package System.Task_Info (s-tasinf.ads): package System Task_Info s-tasinf ads.


File: gnat_rm.info,  Node: pragma No_Run_Time,  Next: pragma Ravenscar,  Up: Obsolescent Features

18.1 pragma No_Run_Time
=======================

The pragma ‘No_Run_Time’ is used to achieve an affect similar to the use
of the “Zero Foot Print” configurable run time, but without requiring a
specially configured run time.  The result of using this pragma, which
must be used for all units in a partition, is to restrict the use of any
language features requiring run-time support code.  The preferred usage
is to use an appropriately configured run-time that includes just those
features that are to be made accessible.


File: gnat_rm.info,  Node: pragma Ravenscar,  Next: pragma Restricted_Run_Time,  Prev: pragma No_Run_Time,  Up: Obsolescent Features

18.2 pragma Ravenscar
=====================

The pragma ‘Ravenscar’ has exactly the same effect as pragma ‘Profile
(Ravenscar)’.  The latter usage is preferred since it is part of the new
Ada 2005 standard.


File: gnat_rm.info,  Node: pragma Restricted_Run_Time,  Next: pragma Task_Info,  Prev: pragma Ravenscar,  Up: Obsolescent Features

18.3 pragma Restricted_Run_Time
===============================

The pragma ‘Restricted_Run_Time’ has exactly the same effect as pragma
‘Profile (Restricted)’.  The latter usage is preferred since the Ada
2005 pragma ‘Profile’ is intended for this kind of implementation
dependent addition.


File: gnat_rm.info,  Node: pragma Task_Info,  Next: package System Task_Info s-tasinf ads,  Prev: pragma Restricted_Run_Time,  Up: Obsolescent Features

18.4 pragma Task_Info
=====================

The functionality provided by pragma ‘Task_Info’ is now part of the Ada
language.  The ‘CPU’ aspect and the package ‘System.Multiprocessors’
offer a less system-dependent way to specify task affinity or to query
the number of processors.

Syntax

     pragma Task_Info (EXPRESSION);

This pragma appears within a task definition (like pragma ‘Priority’)
and applies to the task in which it appears.  The argument must be of
type ‘System.Task_Info.Task_Info_Type’.  The ‘Task_Info’ pragma provides
system dependent control over aspects of tasking implementation, for
example, the ability to map tasks to specific processors.  For details
on the facilities available for the version of GNAT that you are using,
see the documentation in the spec of package System.Task_Info in the
runtime library.


File: gnat_rm.info,  Node: package System Task_Info s-tasinf ads,  Prev: pragma Task_Info,  Up: Obsolescent Features

18.5 package System.Task_Info (‘s-tasinf.ads’)
==============================================

This package provides target dependent functionality that is used to
support the ‘Task_Info’ pragma.  The predefined Ada package
‘System.Multiprocessors’ and the ‘CPU’ aspect now provide a standard
replacement for GNAT’s ‘Task_Info’ functionality.


File: gnat_rm.info,  Node: Compatibility and Porting Guide,  Next: GNU Free Documentation License,  Prev: Obsolescent Features,  Up: Top

19 Compatibility and Porting Guide
**********************************

This chapter presents some guidelines for developing portable Ada code,
describes the compatibility issues that may arise between GNAT and other
Ada compilation systems (including those for Ada 83), and shows how GNAT
can expedite porting applications developed in other Ada environments.

* Menu:

* Writing Portable Fixed-Point Declarations::
* Compatibility with Ada 83::
* Compatibility between Ada 95 and Ada 2005::
* Implementation-dependent characteristics::
* Compatibility with Other Ada Systems::
* Representation Clauses::
* Compatibility with HP Ada 83::


File: gnat_rm.info,  Node: Writing Portable Fixed-Point Declarations,  Next: Compatibility with Ada 83,  Up: Compatibility and Porting Guide

19.1 Writing Portable Fixed-Point Declarations
==============================================

The Ada Reference Manual gives an implementation freedom to choose
bounds that are narrower by ‘Small’ from the given bounds.  For example,
if we write

     type F1 is delta 1.0 range -128.0 .. +128.0;

then the implementation is allowed to choose -128.0 ..  +127.0 if it
likes, but is not required to do so.

This leads to possible portability problems, so let’s have a closer look
at this, and figure out how to avoid these problems.

First, why does this freedom exist, and why would an implementation take
advantage of it?  To answer this, take a closer look at the type
declaration for ‘F1’ above.  If the compiler uses the given bounds, it
would need 9 bits to hold the largest positive value (and typically that
means 16 bits on all machines).  But if the implementation chooses the
+127.0 bound then it can fit values of the type in 8 bits.

Why not make the user write +127.0 if that’s what is wanted?  The
rationale is that if you are thinking of fixed point as a kind of ‘poor
man’s floating-point’, then you don’t want to be thinking about the
scaled integers that are used in its representation.  Let’s take another
example:

     type F2 is delta 2.0**(-15) range -1.0 .. +1.0;

Looking at this declaration, it seems casually as though it should fit
in 16 bits, but again that extra positive value +1.0 has the scaled
integer equivalent of 2**15 which is one too big for signed 16 bits.
The implementation can treat this as:

     type F2 is delta 2.0**(-15) range -1.0 .. +1.0-(2.0**(-15));

and the Ada language design team felt that this was too annoying to
require.  We don’t need to debate this decision at this point, since it
is well established (the rule about narrowing the ranges dates to Ada
83).

But the important point is that an implementation is not required to do
this narrowing, so we have a potential portability problem.  We could
imagine three types of implementation:

  a. those that narrow the range automatically if they can figure out
     that the narrower range will allow storage in a smaller machine
     unit,

  b. those that will narrow only if forced to by a ‘'Size’ clause, and

  c. those that will never narrow.

Now if we are language theoreticians, we can imagine a fourth approach:
to narrow all the time, e.g.  to treat

     type F3 is delta 1.0 range -10.0 .. +23.0;

as though it had been written:

     type F3 is delta 1.0 range -9.0 .. +22.0;

But although technically allowed, such a behavior would be hostile and
silly, and no real compiler would do this.  All real compilers will fall
into one of the categories (a), (b) or (c) above.

So, how do you get the compiler to do what you want?  The answer is give
the actual bounds you want, and then use a ‘'Small’ clause and a ‘'Size’
clause to absolutely pin down what the compiler does.  E.g., for ‘F2’
above, we will write:

     My_Small : constant := 2.0**(-15);
     My_First : constant := -1.0;
     My_Last  : constant := +1.0 - My_Small;

     type F2 is delta My_Small range My_First .. My_Last;

and then add

     for F2'Small use my_Small;
     for F2'Size  use 16;

In practice all compilers will do the same thing here and will give you
what you want, so the above declarations are fully portable.  If you
really want to play language lawyer and guard against ludicrous behavior
by the compiler you could add

     Test1 : constant := 1 / Boolean'Pos (F2'First = My_First);
     Test2 : constant := 1 / Boolean'Pos (F2'Last  = My_Last);

One or other or both are allowed to be illegal if the compiler is
behaving in a silly manner, but at least the silly compiler will not get
away with silently messing with your (very clear) intentions.

If you follow this scheme you will be guaranteed that your fixed-point
types will be portable.


File: gnat_rm.info,  Node: Compatibility with Ada 83,  Next: Compatibility between Ada 95 and Ada 2005,  Prev: Writing Portable Fixed-Point Declarations,  Up: Compatibility and Porting Guide

19.2 Compatibility with Ada 83
==============================

Ada 95 and the subsequent revisions Ada 2005 and Ada 2012 are highly
upwards compatible with Ada 83.  In particular, the design intention was
that the difficulties associated with moving from Ada 83 to later
versions of the standard should be no greater than those that occur when
moving from one Ada 83 system to another.

However, there are a number of points at which there are minor
incompatibilities.  The ‘Ada 95 Annotated Reference Manual’ contains
full details of these issues as they relate to Ada 95, and should be
consulted for a complete treatment.  In practice the following
subsections treat the most likely issues to be encountered.

* Menu:

* Legal Ada 83 programs that are illegal in Ada 95::
* More deterministic semantics::
* Changed semantics::
* Other language compatibility issues::


File: gnat_rm.info,  Node: Legal Ada 83 programs that are illegal in Ada 95,  Next: More deterministic semantics,  Up: Compatibility with Ada 83

19.2.1 Legal Ada 83 programs that are illegal in Ada 95
-------------------------------------------------------

Some legal Ada 83 programs are illegal (i.e., they will fail to compile)
in Ada 95 and later versions of the standard:

   * `Character literals'

     Some uses of character literals are ambiguous.  Since Ada 95 has
     introduced ‘Wide_Character’ as a new predefined character type,
     some uses of character literals that were legal in Ada 83 are
     illegal in Ada 95.  For example:

          for Char in 'A' .. 'Z' loop ... end loop;

     The problem is that ‘A’ and ‘Z’ could be from either ‘Character’ or
     ‘Wide_Character’.  The simplest correction is to make the type
     explicit; e.g.:

          for Char in Character range 'A' .. 'Z' loop ... end loop;

   * `New reserved words'

     The identifiers ‘abstract’, ‘aliased’, ‘protected’, ‘requeue’,
     ‘tagged’, and ‘until’ are reserved in Ada 95.  Existing Ada 83 code
     using any of these identifiers must be edited to use some
     alternative name.

   * `Freezing rules'

     The rules in Ada 95 are slightly different with regard to the point
     at which entities are frozen, and representation pragmas and
     clauses are not permitted past the freeze point.  This shows up
     most typically in the form of an error message complaining that a
     representation item appears too late, and the appropriate
     corrective action is to move the item nearer to the declaration of
     the entity to which it refers.

     A particular case is that representation pragmas cannot be applied
     to a subprogram body.  If necessary, a separate subprogram
     declaration must be introduced to which the pragma can be applied.

   * `Optional bodies for library packages'

     In Ada 83, a package that did not require a package body was
     nevertheless allowed to have one.  This lead to certain surprises
     in compiling large systems (situations in which the body could be
     unexpectedly ignored by the binder).  In Ada 95, if a package does
     not require a body then it is not permitted to have a body.  To fix
     this problem, simply remove a redundant body if it is empty, or, if
     it is non-empty, introduce a dummy declaration into the spec that
     makes the body required.  One approach is to add a private part to
     the package declaration (if necessary), and define a parameterless
     procedure called ‘Requires_Body’, which must then be given a dummy
     procedure body in the package body, which then becomes required.
     Another approach (assuming that this does not introduce elaboration
     circularities) is to add an ‘Elaborate_Body’ pragma to the package
     spec, since one effect of this pragma is to require the presence of
     a package body.

   * `Numeric_Error is the same exception as Constraint_Error'

     In Ada 95, the exception ‘Numeric_Error’ is a renaming of
     ‘Constraint_Error’.  This means that it is illegal to have separate
     exception handlers for the two exceptions.  The fix is simply to
     remove the handler for the ‘Numeric_Error’ case (since even in Ada
     83, a compiler was free to raise ‘Constraint_Error’ in place of
     ‘Numeric_Error’ in all cases).

   * `Indefinite subtypes in generics'

     In Ada 83, it was permissible to pass an indefinite type (e.g,
     ‘String’) as the actual for a generic formal private type, but then
     the instantiation would be illegal if there were any instances of
     declarations of variables of this type in the generic body.  In Ada
     95, to avoid this clear violation of the methodological principle
     known as the ‘contract model’, the generic declaration explicitly
     indicates whether or not such instantiations are permitted.  If a
     generic formal parameter has explicit unknown discriminants,
     indicated by using ‘(<>)’ after the subtype name, then it can be
     instantiated with indefinite types, but no stand-alone variables
     can be declared of this type.  Any attempt to declare such a
     variable will result in an illegality at the time the generic is
     declared.  If the ‘(<>)’ notation is not used, then it is illegal
     to instantiate the generic with an indefinite type.  This is the
     potential incompatibility issue when porting Ada 83 code to Ada 95.
     It will show up as a compile time error, and the fix is usually
     simply to add the ‘(<>)’ to the generic declaration.


File: gnat_rm.info,  Node: More deterministic semantics,  Next: Changed semantics,  Prev: Legal Ada 83 programs that are illegal in Ada 95,  Up: Compatibility with Ada 83

19.2.2 More deterministic semantics
-----------------------------------

   * `Conversions'

     Conversions from real types to integer types round away from 0.  In
     Ada 83 the conversion Integer(2.5) could deliver either 2 or 3 as
     its value.  This implementation freedom was intended to support
     unbiased rounding in statistical applications, but in practice it
     interfered with portability.  In Ada 95 the conversion semantics
     are unambiguous, and rounding away from 0 is required.  Numeric
     code may be affected by this change in semantics.  Note, though,
     that this issue is no worse than already existed in Ada 83 when
     porting code from one vendor to another.

   * `Tasking'

     The Real-Time Annex introduces a set of policies that define the
     behavior of features that were implementation dependent in Ada 83,
     such as the order in which open select branches are executed.


File: gnat_rm.info,  Node: Changed semantics,  Next: Other language compatibility issues,  Prev: More deterministic semantics,  Up: Compatibility with Ada 83

19.2.3 Changed semantics
------------------------

The worst kind of incompatibility is one where a program that is legal
in Ada 83 is also legal in Ada 95 but can have an effect in Ada 95 that
was not possible in Ada 83.  Fortunately this is extremely rare, but the
one situation that you should be alert to is the change in the
predefined type ‘Character’ from 7-bit ASCII to 8-bit Latin-1.

   * `Range of type ‘‘Character‘‘'

     The range of ‘Standard.Character’ is now the full 256 characters of
     Latin-1, whereas in most Ada 83 implementations it was restricted
     to 128 characters.  Although some of the effects of this change
     will be manifest in compile-time rejection of legal Ada 83 programs
     it is possible for a working Ada 83 program to have a different
     effect in Ada 95, one that was not permitted in Ada 83.  As an
     example, the expression ‘Character'Pos(Character'Last)’ returned
     ‘127’ in Ada 83 and now delivers ‘255’ as its value.  In general,
     you should look at the logic of any character-processing Ada 83
     program and see whether it needs to be adapted to work correctly
     with Latin-1.  Note that the predefined Ada 95 API has a character
     handling package that may be relevant if code needs to be adapted
     to account for the additional Latin-1 elements.  The desirable fix
     is to modify the program to accommodate the full character set, but
     in some cases it may be convenient to define a subtype or derived
     type of Character that covers only the restricted range.


File: gnat_rm.info,  Node: Other language compatibility issues,  Prev: Changed semantics,  Up: Compatibility with Ada 83

19.2.4 Other language compatibility issues
------------------------------------------

   * `-gnat83' switch

     All implementations of GNAT provide a switch that causes GNAT to
     operate in Ada 83 mode.  In this mode, some but not all
     compatibility problems of the type described above are handled
     automatically.  For example, the new reserved words introduced in
     Ada 95 and Ada 2005 are treated simply as identifiers as in Ada 83.
     However, in practice, it is usually advisable to make the necessary
     modifications to the program to remove the need for using this
     switch.  See the ‘Compiling Different Versions of Ada’ section in
     the ‘GNAT User’s Guide’.

   * Support for removed Ada 83 pragmas and attributes

     A number of pragmas and attributes from Ada 83 were removed from
     Ada 95, generally because they were replaced by other mechanisms.
     Ada 95 and Ada 2005 compilers are allowed, but not required, to
     implement these missing elements.  In contrast with some other
     compilers, GNAT implements all such pragmas and attributes,
     eliminating this compatibility concern.  These include ‘pragma
     Interface’ and the floating point type attributes (‘Emax’,
     ‘Mantissa’, etc.), among other items.


File: gnat_rm.info,  Node: Compatibility between Ada 95 and Ada 2005,  Next: Implementation-dependent characteristics,  Prev: Compatibility with Ada 83,  Up: Compatibility and Porting Guide

19.3 Compatibility between Ada 95 and Ada 2005
==============================================

Although Ada 2005 was designed to be upwards compatible with Ada 95,
there are a number of incompatibilities.  Several are enumerated below;
for a complete description please see the ‘Annotated Ada 2005 Reference
Manual’, or section 9.1.1 in ‘Rationale for Ada 2005’.

   * `New reserved words.'

     The words ‘interface’, ‘overriding’ and ‘synchronized’ are reserved
     in Ada 2005.  A pre-Ada 2005 program that uses any of these as an
     identifier will be illegal.

   * `New declarations in predefined packages.'

     A number of packages in the predefined environment contain new
     declarations: ‘Ada.Exceptions’, ‘Ada.Real_Time’, ‘Ada.Strings’,
     ‘Ada.Strings.Fixed’, ‘Ada.Strings.Bounded’,
     ‘Ada.Strings.Unbounded’, ‘Ada.Strings.Wide_Fixed’,
     ‘Ada.Strings.Wide_Bounded’, ‘Ada.Strings.Wide_Unbounded’,
     ‘Ada.Tags’, ‘Ada.Text_IO’, and ‘Interfaces.C’.  If an Ada 95
     program does a ‘with’ and ‘use’ of any of these packages, the new
     declarations may cause name clashes.

   * `Access parameters.'

     A nondispatching subprogram with an access parameter cannot be
     renamed as a dispatching operation.  This was permitted in Ada 95.

   * `Access types, discriminants, and constraints.'

     Rule changes in this area have led to some incompatibilities; for
     example, constrained subtypes of some access types are not
     permitted in Ada 2005.

   * `Aggregates for limited types.'

     The allowance of aggregates for limited types in Ada 2005 raises
     the possibility of ambiguities in legal Ada 95 programs, since
     additional types now need to be considered in expression
     resolution.

   * `Fixed-point multiplication and division.'

     Certain expressions involving ‘*’ or ‘/’ for a fixed-point type,
     which were legal in Ada 95 and invoked the predefined versions of
     these operations, are now ambiguous.  The ambiguity may be resolved
     either by applying a type conversion to the expression, or by
     explicitly invoking the operation from package ‘Standard’.

   * `Return-by-reference types.'

     The Ada 95 return-by-reference mechanism has been removed.
     Instead, the user can declare a function returning a value from an
     anonymous access type.


File: gnat_rm.info,  Node: Implementation-dependent characteristics,  Next: Compatibility with Other Ada Systems,  Prev: Compatibility between Ada 95 and Ada 2005,  Up: Compatibility and Porting Guide

19.4 Implementation-dependent characteristics
=============================================

Although the Ada language defines the semantics of each construct as
precisely as practical, in some situations (for example for reasons of
efficiency, or where the effect is heavily dependent on the host or
target platform) the implementation is allowed some freedom.  In porting
Ada 83 code to GNAT, you need to be aware of whether / how the existing
code exercised such implementation dependencies.  Such characteristics
fall into several categories, and GNAT offers specific support in
assisting the transition from certain Ada 83 compilers.

* Menu:

* Implementation-defined pragmas::
* Implementation-defined attributes::
* Libraries::
* Elaboration order::
* Target-specific aspects::


File: gnat_rm.info,  Node: Implementation-defined pragmas,  Next: Implementation-defined attributes,  Up: Implementation-dependent characteristics

19.4.1 Implementation-defined pragmas
-------------------------------------

Ada compilers are allowed to supplement the language-defined pragmas,
and these are a potential source of non-portability.  All GNAT-defined
pragmas are described in *note Implementation Defined Pragmas: 7, and
these include several that are specifically intended to correspond to
other vendors’ Ada 83 pragmas.  For migrating from VADS, the pragma
‘Use_VADS_Size’ may be useful.  For compatibility with HP Ada 83, GNAT
supplies the pragmas ‘Extend_System’, ‘Ident’, ‘Inline_Generic’,
‘Interface_Name’, ‘Passive’, ‘Suppress_All’, and ‘Volatile’.  Other
relevant pragmas include ‘External’ and ‘Link_With’.  Some
vendor-specific Ada 83 pragmas (‘Share_Generic’, ‘Subtitle’, and
‘Title’) are recognized, thus avoiding compiler rejection of units that
contain such pragmas; they are not relevant in a GNAT context and hence
are not otherwise implemented.


File: gnat_rm.info,  Node: Implementation-defined attributes,  Next: Libraries,  Prev: Implementation-defined pragmas,  Up: Implementation-dependent characteristics

19.4.2 Implementation-defined attributes
----------------------------------------

Analogous to pragmas, the set of attributes may be extended by an
implementation.  All GNAT-defined attributes are described in *note
Implementation Defined Attributes: 8, and these include several that are
specifically intended to correspond to other vendors’ Ada 83 attributes.
For migrating from VADS, the attribute ‘VADS_Size’ may be useful.  For
compatibility with HP Ada 83, GNAT supplies the attributes ‘Bit’,
‘Machine_Size’ and ‘Type_Class’.


File: gnat_rm.info,  Node: Libraries,  Next: Elaboration order,  Prev: Implementation-defined attributes,  Up: Implementation-dependent characteristics

19.4.3 Libraries
----------------

Vendors may supply libraries to supplement the standard Ada API. If Ada
83 code uses vendor-specific libraries then there are several ways to
manage this in Ada 95 and later versions of the standard:

   * If the source code for the libraries (specs and bodies) are
     available, then the libraries can be migrated in the same way as
     the application.

   * If the source code for the specs but not the bodies are available,
     then you can reimplement the bodies.

   * Some features introduced by Ada 95 obviate the need for library
     support.  For example most Ada 83 vendors supplied a package for
     unsigned integers.  The Ada 95 modular type feature is the
     preferred way to handle this need, so instead of migrating or
     reimplementing the unsigned integer package it may be preferable to
     retrofit the application using modular types.


File: gnat_rm.info,  Node: Elaboration order,  Next: Target-specific aspects,  Prev: Libraries,  Up: Implementation-dependent characteristics

19.4.4 Elaboration order
------------------------

The implementation can choose any elaboration order consistent with the
unit dependency relationship.  This freedom means that some orders can
result in Program_Error being raised due to an ‘Access Before
Elaboration’: an attempt to invoke a subprogram before its body has been
elaborated, or to instantiate a generic before the generic body has been
elaborated.  By default GNAT attempts to choose a safe order (one that
will not encounter access before elaboration problems) by implicitly
inserting ‘Elaborate’ or ‘Elaborate_All’ pragmas where needed.  However,
this can lead to the creation of elaboration circularities and a
resulting rejection of the program by gnatbind.  This issue is
thoroughly described in the `Elaboration Order Handling in GNAT'
appendix in the ‘GNAT User’s Guide’.  In brief, there are several ways
to deal with this situation:

   * Modify the program to eliminate the circularities, e.g., by moving
     elaboration-time code into explicitly-invoked procedures

   * Constrain the elaboration order by including explicit
     ‘Elaborate_Body’ or ‘Elaborate’ pragmas, and then inhibit the
     generation of implicit ‘Elaborate_All’ pragmas either globally (as
     an effect of the `-gnatE' switch) or locally (by selectively
     suppressing elaboration checks via pragma
     ‘Suppress(Elaboration_Check)’ when it is safe to do so).


File: gnat_rm.info,  Node: Target-specific aspects,  Prev: Elaboration order,  Up: Implementation-dependent characteristics

19.4.5 Target-specific aspects
------------------------------

Low-level applications need to deal with machine addresses, data
representations, interfacing with assembler code, and similar issues.
If such an Ada 83 application is being ported to different target
hardware (for example where the byte endianness has changed) then you
will need to carefully examine the program logic; the porting effort
will heavily depend on the robustness of the original design.  Moreover,
Ada 95 (and thus Ada 2005 and Ada 2012) are sometimes incompatible with
typical Ada 83 compiler practices regarding implicit packing, the
meaning of the Size attribute, and the size of access values.  GNAT’s
approach to these issues is described in *note Representation Clauses:
467.


File: gnat_rm.info,  Node: Compatibility with Other Ada Systems,  Next: Representation Clauses,  Prev: Implementation-dependent characteristics,  Up: Compatibility and Porting Guide

19.5 Compatibility with Other Ada Systems
=========================================

If programs avoid the use of implementation dependent and implementation
defined features, as documented in the ‘Ada Reference Manual’, there
should be a high degree of portability between GNAT and other Ada
systems.  The following are specific items which have proved troublesome
in moving Ada 95 programs from GNAT to other Ada 95 compilers, but do
not affect porting code to GNAT. (As of January 2007, GNAT is the only
compiler available for Ada 2005; the following issues may or may not
arise for Ada 2005 programs when other compilers appear.)

   * `Ada 83 Pragmas and Attributes'

     Ada 95 compilers are allowed, but not required, to implement the
     missing Ada 83 pragmas and attributes that are no longer defined in
     Ada 95.  GNAT implements all such pragmas and attributes,
     eliminating this as a compatibility concern, but some other Ada 95
     compilers reject these pragmas and attributes.

   * `Specialized Needs Annexes'

     GNAT implements the full set of special needs annexes.  At the
     current time, it is the only Ada 95 compiler to do so.  This means
     that programs making use of these features may not be portable to
     other Ada 95 compilation systems.

   * `Representation Clauses'

     Some other Ada 95 compilers implement only the minimal set of
     representation clauses required by the Ada 95 reference manual.
     GNAT goes far beyond this minimal set, as described in the next
     section.


File: gnat_rm.info,  Node: Representation Clauses,  Next: Compatibility with HP Ada 83,  Prev: Compatibility with Other Ada Systems,  Up: Compatibility and Porting Guide

19.6 Representation Clauses
===========================

The Ada 83 reference manual was quite vague in describing both the
minimal required implementation of representation clauses, and also
their precise effects.  Ada 95 (and thus also Ada 2005) are much more
explicit, but the minimal set of capabilities required is still quite
limited.

GNAT implements the full required set of capabilities in Ada 95 and Ada
2005, but also goes much further, and in particular an effort has been
made to be compatible with existing Ada 83 usage to the greatest extent
possible.

A few cases exist in which Ada 83 compiler behavior is incompatible with
the requirements in Ada 95 (and thus also Ada 2005).  These are
instances of intentional or accidental dependence on specific
implementation dependent characteristics of these Ada 83 compilers.  The
following is a list of the cases most likely to arise in existing Ada 83
code.

   * `Implicit Packing'

     Some Ada 83 compilers allowed a Size specification to cause
     implicit packing of an array or record.  This could cause expensive
     implicit conversions for change of representation in the presence
     of derived types, and the Ada design intends to avoid this
     possibility.  Subsequent AI’s were issued to make it clear that
     such implicit change of representation in response to a Size clause
     is inadvisable, and this recommendation is represented explicitly
     in the Ada 95 (and Ada 2005) Reference Manuals as implementation
     advice that is followed by GNAT. The problem will show up as an
     error message rejecting the size clause.  The fix is simply to
     provide the explicit pragma ‘Pack’, or for more fine tuned control,
     provide a Component_Size clause.

   * `Meaning of Size Attribute'

     The Size attribute in Ada 95 (and Ada 2005) for discrete types is
     defined as the minimal number of bits required to hold values of
     the type.  For example, on a 32-bit machine, the size of ‘Natural’
     will typically be 31 and not 32 (since no sign bit is required).
     Some Ada 83 compilers gave 31, and some 32 in this situation.  This
     problem will usually show up as a compile time error, but not
     always.  It is a good idea to check all uses of the ‘Size attribute
     when porting Ada 83 code.  The GNAT specific attribute Object_Size
     can provide a useful way of duplicating the behavior of some Ada 83
     compiler systems.

   * `Size of Access Types'

     A common assumption in Ada 83 code is that an access type is in
     fact a pointer, and that therefore it will be the same size as a
     System.Address value.  This assumption is true for GNAT in most
     cases with one exception.  For the case of a pointer to an
     unconstrained array type (where the bounds may vary from one value
     of the access type to another), the default is to use a ‘fat
     pointer’, which is represented as two separate pointers, one to the
     bounds, and one to the array.  This representation has a number of
     advantages, including improved efficiency.  However, it may cause
     some difficulties in porting existing Ada 83 code which makes the
     assumption that, for example, pointers fit in 32 bits on a machine
     with 32-bit addressing.

     To get around this problem, GNAT also permits the use of ‘thin
     pointers’ for access types in this case (where the designated type
     is an unconstrained array type).  These thin pointers are indeed
     the same size as a System.Address value.  To specify a thin
     pointer, use a size clause for the type, for example:

          type X is access all String;
          for X'Size use Standard'Address_Size;

     which will cause the type X to be represented using a single
     pointer.  When using this representation, the bounds are right
     behind the array.  This representation is slightly less efficient,
     and does not allow quite such flexibility in the use of foreign
     pointers or in using the Unrestricted_Access attribute to create
     pointers to non-aliased objects.  But for any standard portable use
     of the access type it will work in a functionally correct manner
     and allow porting of existing code.  Note that another way of
     forcing a thin pointer representation is to use a component size
     clause for the element size in an array, or a record representation
     clause for an access field in a record.

     See the documentation of Unrestricted_Access in the GNAT RM for a
     full discussion of possible problems using this attribute in
     conjunction with thin pointers.


File: gnat_rm.info,  Node: Compatibility with HP Ada 83,  Prev: Representation Clauses,  Up: Compatibility and Porting Guide

19.7 Compatibility with HP Ada 83
=================================

All the HP Ada 83 pragmas and attributes are recognized, although only a
subset of them can sensibly be implemented.  The description of pragmas
in *note Implementation Defined Pragmas: 7. indicates whether or not
they are applicable to GNAT.

   * `Default floating-point representation'

     In GNAT, the default floating-point format is IEEE, whereas in HP
     Ada 83, it is VMS format.

   * `System'

     the package System in GNAT exactly corresponds to the definition in
     the Ada 95 reference manual, which means that it excludes many of
     the HP Ada 83 extensions.  However, a separate package Aux_DEC is
     provided that contains the additional definitions, and a special
     pragma, Extend_System allows this package to be treated
     transparently as an extension of package System.


File: gnat_rm.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Compatibility and Porting Guide,  Up: Top

20 GNU Free Documentation License
*********************************

Version 1.3, 3 November 2008

Copyright 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc
‘https://fsf.org/’

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

`Preamble'

The purpose of this License is to make a manual, textbook, or other
functional and useful document “free” in the sense of freedom: to assure
everyone the effective freedom to copy and redistribute it, with or
without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible for
modifications made by others.

This License is a kind of “copyleft”, which means that derivative works
of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft license
designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free program
should come with manuals providing the same freedoms that the software
does.  But this License is not limited to software manuals; it can be
used for any textual work, regardless of subject matter or whether it is
published as a printed book.  We recommend this License principally for
works whose purpose is instruction or reference.

`1.  APPLICABILITY AND DEFINITIONS'

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The `Document', below, refers
to any such manual or work.  Any member of the public is a licensee, and
is addressed as “`you'”.  You accept the license if you copy, modify or
distribute the work in a way requiring permission under copyright law.

A “`Modified Version'” of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A “`Secondary Section'” is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document’s overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding them.

The “`Invariant Sections'” are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice that
says that the Document is released under this License.  If a section
does not fit the above definition of Secondary then it is not allowed to
be designated as Invariant.  The Document may contain zero Invariant
Sections.  If the Document does not identify any Invariant Sections then
there are none.

The “`Cover Texts'” are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may be
at most 5 words, and a Back-Cover Text may be at most 25 words.

A “`Transparent'” copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the general
public, that is suitable for revising the document straightforwardly
with generic text editors or (for images composed of pixels) generic
paint programs or (for drawings) some widely available drawing editor,
and that is suitable for input to text formatters or for automatic
translation to a variety of formats suitable for input to text
formatters.  A copy made in an otherwise Transparent file format whose
markup, or absence of markup, has been arranged to thwart or discourage
subsequent modification by readers is not Transparent.  An image format
is not Transparent if used for any substantial amount of text.  A copy
that is not “Transparent” is called `Opaque'.

Examples of suitable formats for Transparent copies include plain ASCII
without markup, Texinfo input format, LaTeX input format, SGML or XML
using a publicly available DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the machine-generated
HTML, PostScript or PDF produced by some word processors for output
purposes only.

The “`Title Page'” means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in formats
which do not have any title page as such, “Title Page” means the text
near the most prominent appearance of the work’s title, preceding the
beginning of the body of the text.

The “`publisher'” means any person or entity that distributes copies of
the Document to the public.

A section “`Entitled XYZ'” means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as “`Acknowledgements'”,
“`Dedications'”, “`Endorsements'”, or “`History'”.)  To “`Preserve the
Title'” of such a section when you modify the Document means that it
remains a section “Entitled XYZ” according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this License,
but only as regards disclaiming warranties: any other implication that
these Warranty Disclaimers may have is void and has no effect on the
meaning of this License.

`2.  VERBATIM COPYING'

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies to
the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further copying
of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

`3.  COPYING IN QUANTITY'

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document’s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back
cover.  Both covers must also clearly and legibly identify you as the
publisher of these copies.  The front cover must present the full title
with all words of the title equally prominent and visible.  You may add
other material on the covers in addition.  Copying with changes limited
to the covers, as long as they preserve the title of the Document and
satisfy these conditions, can be treated as verbatim copying in other
respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy a
computer-network location from which the general network-using public
has access to download using public-standard network protocols a
complete Transparent copy of the Document, free of added material.  If
you use the latter option, you must take reasonably prudent steps, when
you begin distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

`4.  MODIFICATIONS'

You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the
Modified Version under precisely this License, with the Modified Version
filling the role of the Document, thus licensing distribution and
modification of the Modified Version to whoever possesses a copy of it.
In addition, you must do these things in the Modified Version:

  A. Use in the Title Page (and on the covers, if any) a title distinct
     from that of the Document, and from those of previous versions
     (which should, if there were any, be listed in the History section
     of the Document).  You may use the same title as a previous version
     if the original publisher of that version gives permission.

  B. List on the Title Page, as authors, one or more persons or entities
     responsible for authorship of the modifications in the Modified
     Version, together with at least five of the principal authors of
     the Document (all of its principal authors, if it has fewer than
     five), unless they release you from this requirement.

  C. State on the Title page the name of the publisher of the Modified
     Version, as the publisher.

  D. Preserve all the copyright notices of the Document.

  E. Add an appropriate copyright notice for your modifications adjacent
     to the other copyright notices.

  F. Include, immediately after the copyright notices, a license notice
     giving the public permission to use the Modified Version under the
     terms of this License, in the form shown in the Addendum below.

  G. Preserve in that license notice the full lists of Invariant
     Sections and required Cover Texts given in the Document’s license
     notice.

  H. Include an unaltered copy of this License.

  I. Preserve the section Entitled “History”, Preserve its Title, and
     add to it an item stating at least the title, year, new authors,
     and publisher of the Modified Version as given on the Title Page.
     If there is no section Entitled “History” in the Document, create
     one stating the title, year, authors, and publisher of the Document
     as given on its Title Page, then add an item describing the
     Modified Version as stated in the previous sentence.

  J. Preserve the network location, if any, given in the Document for
     public access to a Transparent copy of the Document, and likewise
     the network locations given in the Document for previous versions
     it was based on.  These may be placed in the “History” section.
     You may omit a network location for a work that was published at
     least four years before the Document itself, or if the original
     publisher of the version it refers to gives permission.

  K. For any section Entitled “Acknowledgements” or “Dedications”,
     Preserve the Title of the section, and preserve in the section all
     the substance and tone of each of the contributor acknowledgements
     and/or dedications given therein.

  L. Preserve all the Invariant Sections of the Document, unaltered in
     their text and in their titles.  Section numbers or the equivalent
     are not considered part of the section titles.

  M. Delete any section Entitled “Endorsements”.  Such a section may not
     be included in the Modified Version.

  N. Do not retitle any existing section to be Entitled “Endorsements”
     or to conflict in title with any Invariant Section.

  O. Preserve any Warranty Disclaimers.

If the Modified Version includes new front-matter sections or appendices
that qualify as Secondary Sections and contain no material copied from
the Document, you may at your option designate some or all of these
sections as invariant.  To do this, add their titles to the list of
Invariant Sections in the Modified Version’s license notice.  These
titles must be distinct from any other section titles.

You may add a section Entitled “Endorsements”, provided it contains
nothing but endorsements of your Modified Version by various parties—for
example, statements of peer review or that the text has been approved by
an organization as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of Front-Cover
Text and one of Back-Cover Text may be added by (or through arrangements
made by) any one entity.  If the Document already includes a cover text
for the same cover, previously added by you or by arrangement made by
the same entity you are acting on behalf of, you may not add another;
but you may replace the old one, on explicit permission from the
previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

`5.  COMBINING DOCUMENTS'

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its license
notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by adding
at the end of it, in parentheses, the name of the original author or
publisher of that section if known, or else a unique number.  Make the
same adjustment to the section titles in the list of Invariant Sections
in the license notice of the combined work.

In the combination, you must combine any sections Entitled “History” in
the various original documents, forming one section Entitled “History”;
likewise combine any sections Entitled “Acknowledgements”, and any
sections Entitled “Dedications”.  You must delete all sections Entitled
“Endorsements”.

`6.  COLLECTIONS OF DOCUMENTS'

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

`7.  AGGREGATION WITH INDEPENDENT WORKS'

A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or
distribution medium, is called an “aggregate” if the copyright resulting
from the compilation is not used to limit the legal rights of the
compilation’s users beyond what the individual works permit.  When the
Document is included in an aggregate, this License does not apply to the
other works in the aggregate which are not themselves derivative works
of the Document.

If the Cover Text requirement of section 3 is applicable to these copies
of the Document, then if the Document is less than one half of the
entire aggregate, the Document’s Cover Texts may be placed on covers
that bracket the Document within the aggregate, or the electronic
equivalent of covers if the Document is in electronic form.  Otherwise
they must appear on printed covers that bracket the whole aggregate.

`8.  TRANSLATION'

Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4.  Replacing
Invariant Sections with translations requires special permission from
their copyright holders, but you may include translations of some or all
Invariant Sections in addition to the original versions of these
Invariant Sections.  You may include a translation of this License, and
all the license notices in the Document, and any Warranty Disclaimers,
provided that you also include the original English version of this
License and the original versions of those notices and disclaimers.  In
case of a disagreement between the translation and the original version
of this License or a notice or disclaimer, the original version will
prevail.

If a section in the Document is Entitled “Acknowledgements”,
“Dedications”, or “History”, the requirement (section 4) to Preserve its
Title (section 1) will typically require changing the actual title.

`9.  TERMINATION'

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided under this License.  Any attempt otherwise to
copy, modify, sublicense, or distribute it is void, and will
automatically terminate your rights under this License.

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally terminates
your license, and (b) permanently, if the copyright holder fails to
notify you of the violation by some reasonable means prior to 60 days
after the cessation.

Moreover, your license from a particular copyright holder is reinstated
permanently if the copyright holder notifies you of the violation by
some reasonable means, this is the first time you have received notice
of violation of this License (for any work) from that copyright holder,
and you cure the violation prior to 30 days after your receipt of the
notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.

`10.  FUTURE REVISIONS OF THIS LICENSE'

The Free Software Foundation may publish new, revised versions of the
GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
‘https://www.gnu.org/copyleft/’.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License “or any later version” applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document specifies
that a proxy can decide which future versions of this License can be
used, that proxy’s public statement of acceptance of a version
permanently authorizes you to choose that version for the Document.

`11.  RELICENSING'

“Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World
Wide Web server that publishes copyrightable works and also provides
prominent facilities for anybody to edit those works.  A public wiki
that anybody can edit is an example of such a server.  A “Massive
Multiauthor Collaboration” (or “MMC”) contained in the site means any
set of copyrightable works thus published on the MMC site.

“CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

“Incorporate” means to publish or republish a Document, in whole or in
part, as part of another Document.

An MMC is “eligible for relicensing” if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole or
in part into the MMC, (1) had no cover texts or invariant sections, and
(2) were thus incorporated prior to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.

`ADDENDUM: How to use this License for your documents'

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

     Copyright © YEAR YOUR NAME. Permission is granted to copy,
     distribute and/or modify this document under the terms of the GNU
     Free Documentation License, Version 1.3 or any later version
     published by the Free Software Foundation; with no Invariant
     Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of
     the license is included in the section entitled “GNU Free
     Documentation License”.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the “with … Texts.” line with this:

     with the Invariant Sections being LIST THEIR TITLES, with the
     Front-Cover Texts being LIST, and with the Back-Cover Texts being
     LIST.

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: gnat_rm.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* -gnat12 option (gcc):                  Implementation of Ada 2012 Features.
                                                             (line    6)
* -gnatR (gcc):                          Determining the Representations chosen by GNAT.
                                                             (line    6)
* ___lock file (for shared passive packages): GNAT Implementation of Shared Passive Packages.
                                                             (line   72)
* Abort_Signal:                          Attribute Abort_Signal.
                                                             (line    6)
* Abstract_State:                        Aspect Abstract_State.
                                                             (line    6)
* Access:                                Attribute Unrestricted_Access.
                                                             (line    6)
* Access values:                         Attribute Has_Access_Values.
                                                             (line    6)
* Accuracy:                              RM G 2 4 19 Accuracy Requirements.
                                                             (line   17)
* Accuracy requirements:                 RM G 1 2 49 Complex Elementary Functions.
                                                             (line   17)
* Ada 2005 Language Reference Manual:    What This Reference Manual Contains.
                                                             (line   79)
* Ada 2012 implementation status:        Implementation of Ada 2012 Features.
                                                             (line    6)
* Ada 83 attributes:                     Attribute Emax.     (line    6)
* Ada 83 attributes <1>:                 Attribute Epsilon.  (line    6)
* Ada 83 attributes <2>:                 Attribute Large.    (line    6)
* Ada 83 attributes <3>:                 Attribute Mantissa. (line    6)
* Ada 83 attributes <4>:                 Attribute Safe_Emax.
                                                             (line    6)
* Ada 83 attributes <5>:                 Attribute Safe_Large.
                                                             (line    6)
* Ada 83 attributes <6>:                 Attribute Safe_Small.
                                                             (line    6)
* Ada 83 attributes <7>:                 Attribute Small.    (line    6)
* Ada 95 Language Reference Manual:      What This Reference Manual Contains.
                                                             (line   79)
* Ada Extensions:                        Pragma Extensions_Allowed.
                                                             (line    6)
* Ada.Characters.Handling:               RM A 1 52 Names of Predefined Numeric Types.
                                                             (line   13)
* Ada.Characters.Latin_9 (a-chlat9.ads): Ada Characters Latin_9 a-chlat9 ads.
                                                             (line    6)
* Ada.Characters.Wide_Latin_1 (a-cwila1.ads): Ada Characters Wide_Latin_1 a-cwila1 ads.
                                                             (line    6)
* Ada.Characters.Wide_Latin_9 (a-cwila1.ads): Ada Characters Wide_Latin_9 a-cwila1 ads.
                                                             (line    6)
* Ada.Characters.Wide_Wide_Latin_1 (a-chzla1.ads): Ada Characters Wide_Wide_Latin_1 a-chzla1 ads.
                                                             (line    6)
* Ada.Characters.Wide_Wide_Latin_9 (a-chzla9.ads): Ada Characters Wide_Wide_Latin_9 a-chzla9 ads.
                                                             (line    6)
* Ada.Command_Line.Environment (a-colien.ads): Ada Command_Line Environment a-colien ads.
                                                             (line    6)
* Ada.Command_Line.Remove (a-colire.ads): Ada Command_Line Remove a-colire ads.
                                                             (line    6)
* Ada.Command_Line.Response_File (a-clrefi.ads): Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Ada.Containers.Bounded_Holders (a-coboho.ads): Ada Containers Bounded_Holders a-coboho ads.
                                                             (line    6)
* Ada.Containers.Formal_Doubly_Linked_Lists (a-cfdlli.ads): Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads.
                                                             (line    6)
* Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads): Ada Containers Formal_Hashed_Maps a-cfhama ads.
                                                             (line    6)
* Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads): Ada Containers Formal_Hashed_Sets a-cfhase ads.
                                                             (line    6)
* Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads): Ada Containers Formal_Indefinite_Vectors a-cfinve ads.
                                                             (line    6)
* Ada.Containers.Formal_Ordered_Maps (a-cforma.ads): Ada Containers Formal_Ordered_Maps a-cforma ads.
                                                             (line    6)
* Ada.Containers.Formal_Ordered_Sets (a-cforse.ads): Ada Containers Formal_Ordered_Sets a-cforse ads.
                                                             (line    6)
* Ada.Containers.Formal_Vectors (a-cofove.ads): Ada Containers Formal_Vectors a-cofove ads.
                                                             (line    6)
* Ada.Containers.Functional_Maps (a-cofuma.ads): Ada Containers Functional_Maps a-cofuma ads.
                                                             (line    6)
* Ada.Containers.Functional_Sets (a-cofuse.ads): Ada Containers Functional_Sets a-cofuse ads.
                                                             (line    6)
* Ada.Containers.Functional_Vectors (a-cofuve.ads): Ada Containers Functional_Vectors a-cofuve ads.
                                                             (line    6)
* Ada.Direct_IO.C_Streams (a-diocst.ads): Ada Direct_IO C_Streams a-diocst ads.
                                                             (line    6)
* Ada.Exceptions.Is_Null_Occurrence (a-einuoc.ads): Ada Exceptions Is_Null_Occurrence a-einuoc ads.
                                                             (line    6)
* Ada.Exceptions.Last_Chance_Handler (a-elchha.ads): Ada Exceptions Last_Chance_Handler a-elchha ads.
                                                             (line    6)
* Ada.Exceptions.Traceback (a-exctra.ads): Ada Exceptions Traceback a-exctra ads.
                                                             (line    6)
* Ada.Sequential_IO.C_Streams (a-siocst.ads): Ada Sequential_IO C_Streams a-siocst ads.
                                                             (line    6)
* Ada.Streams.Stream_IO.C_Streams (a-ssicst.ads): Ada Streams Stream_IO C_Streams a-ssicst ads.
                                                             (line    6)
* Ada.Strings.Unbounded.Text_IO (a-suteio.ads): Ada Strings Unbounded Text_IO a-suteio ads.
                                                             (line    6)
* Ada.Strings.Wide_Unbounded.Wide_Text_IO (a-swuwti.ads): Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
                                                             (line    6)
* Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Text_IO (a-szuzti.ads): Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
                                                             (line    6)
* Ada.Task_Initialization (a-tasini.ads): Ada Task_Initialization a-tasini ads.
                                                             (line    6)
* Ada.Text_IO.C_Streams (a-tiocst.ads):  Ada Text_IO C_Streams a-tiocst ads.
                                                             (line    6)
* Ada.Text_IO.Reset_Standard_Files (a-tirsfi.ads): Ada Text_IO Reset_Standard_Files a-tirsfi ads.
                                                             (line    6)
* Ada.Wide_Characters.Unicode (a-wichun.ads): Ada Wide_Characters Unicode a-wichun ads.
                                                             (line    6)
* Ada.Wide_Text_IO.C_Streams (a-wtcstr.ads): Ada Wide_Text_IO C_Streams a-wtcstr ads.
                                                             (line    6)
* Ada.Wide_Text_IO.Reset_Standard_Files (a-wrstfi.ads): Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads.
                                                             (line    6)
* Ada.Wide_Wide_Characters.Unicode (a-zchuni.ads): Ada Wide_Wide_Characters Unicode a-zchuni ads.
                                                             (line    6)
* Ada.Wide_Wide_Text_IO.C_Streams (a-ztcstr.ads): Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads.
                                                             (line    6)
* Ada.Wide_Wide_Text_IO.Reset_Standard_Files (a-zrstfi.ads): Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads.
                                                             (line    6)
* Ada_2012 configuration pragma:         Implementation of Ada 2012 Features.
                                                             (line    6)
* Address:                               RM 13 5 3 7-8 Bit Ordering.
                                                             (line   16)
* Address <1>:                           RM 13 7 37 Address as Private.
                                                             (line   10)
* Address Clause:                        Address Clauses.    (line    6)
* Address clauses:                       RM 13 2 6-8 Packed Types.
                                                             (line   32)
* Address image:                         System Address_Image s-addima ads.
                                                             (line    6)
* Address of subprogram code:            Attribute Code_Address.
                                                             (line    6)
* Address_Size:                          Attribute Address_Size.
                                                             (line    6)
* AI-0002 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1133)
* AI-0003 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  231)
* AI-0007 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1000)
* AI-0008 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  250)
* AI-0009 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  735)
* AI-0012 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  868)
* AI-0015 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  581)
* AI-0017 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1028)
* AI-0019 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1017)
* AI-0026 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  678)
* AI-0030 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  708)
* AI-0031 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1065)
* AI-0032 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  590)
* AI-0033 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  967)
* AI-0034 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  805)
* AI-0035 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  814)
* AI-0037 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  456)
* AI-0038 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1106)
* AI-0039 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  878)
* AI-0040 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  788)
* AI-0042 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  698)
* AI-0043 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  835)
* AI-0044 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1115)
* AI-0046 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  558)
* AI-0050 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  618)
* AI-0056 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1078)
* AI-0058 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  610)
* AI-0060 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1036)
* AI-0062 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  637)
* AI-0064 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  670)
* AI-0065 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1008)
* AI-0070 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  389)
* AI-0072 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  745)
* AI-0073 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  378)
* AI-0076 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  335)
* AI-0077 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  771)
* AI-0078 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  920)
* AI-0079 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   41)
* AI-0080 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   77)
* AI-0087 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  652)
* AI-0088 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  486)
* AI-0091 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   49)
* AI-0093 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  260)
* AI-0095 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  887)
* AI-0096 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  267)
* AI-0097 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  352)
* AI-0098 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  415)
* AI-0099 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  661)
* AI-0100 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   60)
* AI-0102 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  309)
* AI-0103 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  602)
* AI-0104 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  506)
* AI-0106 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  860)
* AI-0108 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  753)
* AI-0109 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  993)
* AI-0112 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  850)
* AI-0114 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1045)
* AI-0116 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  896)
* AI-0118 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  565)
* AI-0120 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  241)
* AI-0122 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  780)
* AI-0123 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  466)
* AI-0125 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  629)
* AI-0126 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  343)
* AI-0127 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1125)
* AI-0128 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  221)
* AI-0129 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  760)
* AI-0132 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  796)
* AI-0134 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  542)
* AI-0137 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1088)
* AI-0139-2 (Ada 2012 feature):          Implementation of Ada 2012 Features.
                                                             (line  533)
* AI-0146 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  904)
* AI-0147 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  440)
* AI-0152 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1209)
* AI-0157 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  514)
* AI-0158 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  318)
* AI-0161 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  975)
* AI-0162 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  407)
* AI-0163 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   69)
* AI-0171 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1184)
* AI-0173 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  328)
* AI-0176 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   33)
* AI-0177 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  954)
* AI-0178 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  644)
* AI-0179 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  523)
* AI-0181 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  278)
* AI-0182 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  289)
* AI-0183 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line   84)
* AI-0185 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1056)
* AI-0188 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  497)
* AI-0189 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1172)
* AI-0190 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1162)
* AI-0193 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  945)
* AI-0194 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  984)
* AI-0195 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  930)
* AI-0196 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  573)
* AI-0198 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  369)
* AI-0199 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  424)
* AI-0200 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  842)
* AI-0201 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  721)
* AI-0203 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  362)
* AI-0205 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  691)
* AI-0206 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1202)
* AI-0207 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  550)
* AI-0208 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  397)
* AI-0210 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1194)
* AI-0211 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line 1155)
* AI-0214 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  300)
* AI-0219 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  826)
* AI-0220 (Ada 2012 feature):            Implementation of Ada 2012 Features.
                                                             (line  432)
* AI05-0216 (Ada 2012 feature):          Implementation of Ada 2012 Features.
                                                             (line 1144)
* Alignment:                             Pragma Optimize_Alignment.
                                                             (line    6)
* Alignment <1>:                         Attribute Maximum_Alignment.
                                                             (line    6)
* Alignment <2>:                         Attribute System_Allocator_Alignment.
                                                             (line    6)
* Alignment <3>:                         Alignment Clauses.  (line   83)
* Alignment <4>:                         Alignment Clauses.  (line   87)
* Alignment Clause:                      Alignment Clauses.  (line    6)
* Alignment clauses:                     RM 13 3 14-19 Address Clauses.
                                                             (line   37)
* Alignments of components:              Pragma Component_Alignment.
                                                             (line    6)
* allocator:                             Attribute System_Allocator_Alignment.
                                                             (line    6)
* Alternative Character Sets:            RM 2 8 17-19 Pragmas.
                                                             (line   16)
* AltiVec:                               GNAT Altivec g-altive ads.
                                                             (line    6)
* AltiVec <1>:                           GNAT Altivec Conversions g-altcon ads.
                                                             (line    6)
* AltiVec <2>:                           GNAT Altivec Vector_Operations g-alveop ads.
                                                             (line    6)
* AltiVec <3>:                           GNAT Altivec Vector_Types g-alvety ads.
                                                             (line    6)
* AltiVec <4>:                           GNAT Altivec Vector_Views g-alvevi ads.
                                                             (line    6)
* Annex E:                               GNAT Implementation of Shared Passive Packages.
                                                             (line   12)
* Annotate:                              Aspect Annotate.    (line    6)
* Anonymous access types:                Conventions and Anonymous Access Types.
                                                             (line    6)
* Argument passing mechanisms:           Pragma Export_Function.
                                                             (line    6)
* argument removal:                      Ada Command_Line Remove a-colire ads.
                                                             (line    6)
* Array packing:                         Pragma Implicit_Packing.
                                                             (line   35)
* Array splitter:                        GNAT Array_Split g-arrspl ads.
                                                             (line    6)
* Arrays:                                RM 3 5 7 17 Float Types.
                                                             (line   24)
* Arrays <1>:                            GNAT Dynamic_Tables g-dyntab ads.
                                                             (line    6)
* Arrays <2>:                            GNAT Table g-table ads.
                                                             (line    6)
* as private type:                       RM 13 5 3 7-8 Bit Ordering.
                                                             (line   15)
* Asm_Input:                             Attribute Asm_Input.
                                                             (line    6)
* Asm_Output:                            Attribute Asm_Output.
                                                             (line    6)
* Assertions:                            Pragma Check.       (line    6)
* Assertions <1>:                        Pragma Check_Policy.
                                                             (line    6)
* Assertions <2>:                        System Assertions s-assert ads.
                                                             (line    6)
* Assert_Failure:                        System Assertions s-assert ads.
                                                             (line    6)
* Async_Readers:                         Aspect Async_Readers.
                                                             (line    6)
* Async_Writers:                         Aspect Async_Writers.
                                                             (line    6)
* Atomic Synchronization:                Pragma Disable_Atomic_Synchronization.
                                                             (line    6)
* Atomic Synchronization <1>:            Pragma Enable_Atomic_Synchronization.
                                                             (line    6)
* Atomic_Always_Lock_Free:               Attribute Atomic_Always_Lock_Free.
                                                             (line    6)
* Attribute:                             Address Clauses.    (line   73)
* Attribute Loop_Entry:                  Pragma Unevaluated_Use_Of_Old.
                                                             (line    6)
* Attribute Old:                         Pragma Unevaluated_Use_Of_Old.
                                                             (line    6)
* AWK:                                   GNAT AWK g-awk ads. (line    6)
* Biased representation:                 Biased Representation.
                                                             (line    6)
* Big endian:                            Attribute Default_Bit_Order.
                                                             (line    6)
* Big endian <1>:                        Attribute Default_Scalar_Storage_Order.
                                                             (line    6)
* Bind environment:                      GNAT Bind_Environment g-binenv ads.
                                                             (line    6)
* Bit:                                   Attribute Bit.      (line    6)
* Bit ordering:                          RM 13 5 2 5 Storage Place Attributes.
                                                             (line   15)
* bit ordering:                          Bit_Order Clauses.  (line    6)
* Bit_Order Clause:                      Bit_Order Clauses.  (line    6)
* Bit_Position:                          Attribute Bit_Position.
                                                             (line    6)
* Boolean_Entry_Barriers:                Simple_Barriers.    (line   12)
* Bounded Buffers:                       GNAT Bounded_Buffers g-boubuf ads.
                                                             (line    6)
* Bounded errors:                        RM 1 1 3 31 Child Units.
                                                             (line   11)
* Bounded-length strings:                RM A 3 2 49 Ada Characters Handling.
                                                             (line   12)
* Branch Prediction:                     GNAT Branch_Prediction g-brapre ads.
                                                             (line    6)
* Bubble sort:                           GNAT Bubble_Sort g-bubsor ads.
                                                             (line    6)
* Bubble sort <1>:                       GNAT Bubble_Sort_A g-busora ads.
                                                             (line    6)
* Bubble sort <2>:                       GNAT Bubble_Sort_G g-busorg ads.
                                                             (line    6)
* byte ordering:                         Effect of Bit_Order on Byte Ordering.
                                                             (line    6)
* Byte swapping:                         GNAT Byte_Swapping g-bytswa ads.
                                                             (line    6)
* C:                                     RM B 2 12-13 Package Interfaces.
                                                             (line   22)
* C Streams:                             Ada Direct_IO C_Streams a-diocst ads.
                                                             (line    6)
* C Streams <1>:                         Ada Sequential_IO C_Streams a-siocst ads.
                                                             (line    6)
* C Streams <2>:                         Ada Streams Stream_IO C_Streams a-ssicst ads.
                                                             (line    6)
* C Streams <3>:                         Ada Text_IO C_Streams a-tiocst ads.
                                                             (line    6)
* C Streams <4>:                         Ada Wide_Text_IO C_Streams a-wtcstr ads.
                                                             (line    6)
* C Streams <5>:                         Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads.
                                                             (line    6)
* C streams:                             Interfaces C Streams i-cstrea ads.
                                                             (line    6)
* Calendar:                              GNAT Calendar g-calend ads.
                                                             (line    6)
* Calendar <1>:                          GNAT Calendar Time_IO g-catiio ads.
                                                             (line    6)
* casing:                                Pragma External_Name_Casing.
                                                             (line    6)
* Casing of External names:              Pragma External_Name_Casing.
                                                             (line    6)
* Casing utilities:                      GNAT Case_Util g-casuti ads.
                                                             (line    6)
* CGI (Common Gateway Interface):        GNAT CGI g-cgi ads. (line    6)
* CGI (Common Gateway Interface) cookie support: GNAT CGI Cookie g-cgicoo ads.
                                                             (line    6)
* CGI (Common Gateway Interface) debugging: GNAT CGI Debug g-cgideb ads.
                                                             (line    6)
* Character handling (‘‘GNAT.Case_Util‘‘): GNAT Case_Util g-casuti ads.
                                                             (line    6)
* Character Sets:                        RM 2 8 17-19 Pragmas.
                                                             (line   17)
* Check names:                           Pragma Check_Name.  (line    6)
* Check pragma control:                  Pragma Check_Policy.
                                                             (line    6)
* Checks:                                Pragma Post.        (line    6)
* Checks <1>:                            Pragma Postcondition.
                                                             (line    6)
* Checks <2>:                            Pragma Post_Class.  (line    6)
* Checks <3>:                            Pragma Pre.         (line    6)
* Checks <4>:                            Pragma Precondition.
                                                             (line    6)
* Checks <5>:                            Pragma Pre_Class.   (line    6)
* Checks <6>:                            RM 11 4 1 19 Exception Information.
                                                             (line   23)
* Child Units:                           RM 1 1 3 20 Error Detection.
                                                             (line   12)
* COBOL:                                 RM B 3 63-71 Interfacing with C.
                                                             (line   58)
* COBOL support:                         RM E 5 28-29 Partition Communication Subsystem.
                                                             (line   18)
* Code_Address:                          Attribute Code_Address.
                                                             (line    6)
* Command line:                          Ada Command_Line Remove a-colire ads.
                                                             (line    6)
* Command line <1>:                      Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Command line <2>:                      Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Command line <3>:                      GNAT Command_Line g-comlin ads.
                                                             (line    6)
* Compatibility (between Ada 83 and Ada 95 / Ada 2005 / Ada 2012): Compatibility with Ada 83.
                                                             (line    6)
* Compatibility between Ada 95 and Ada 2005: Compatibility between Ada 95 and Ada 2005.
                                                             (line    6)
* Compilation_Date:                      Compilation_Date.   (line    6)
* Compilation_ISO_Date:                  Compilation_ISO_Date.
                                                             (line    6)
* Compilation_Time:                      Compilation_Time.   (line    6)
* Compiler Version:                      GNAT Compiler_Version g-comver ads.
                                                             (line    6)
* Compiler_Version:                      Attribute Compiler_Version.
                                                             (line    6)
* complex arithmetic:                    RM G 2 4 19 Accuracy Requirements.
                                                             (line   16)
* Complex arithmetic accuracy:           RM G 2 4 19 Accuracy Requirements.
                                                             (line   17)
* Complex elementary functions:          RM G 1 1 56-58 Complex Types.
                                                             (line   53)
* Complex types:                         RM G Numerics.      (line   15)
* Component Clause:                      Record Representation Clauses.
                                                             (line   11)
* Component_Size (in pragma Component_Alignment): Pragma Component_Alignment.
                                                             (line   21)
* Component_Size Clause:                 Component_Size Clauses.
                                                             (line    6)
* Component_Size clauses:                RM 13 3 50-56 Size Clauses.
                                                             (line   39)
* Component_Size_4 (in pragma Component_Alignment): Pragma Component_Alignment.
                                                             (line   31)
* configuration pragma Ada_2012:         Implementation of Ada 2012 Features.
                                                             (line    6)
* Constant_After_Elaboration:            Aspect Constant_After_Elaboration.
                                                             (line    6)
* Constrained:                           Attribute Constrained.
                                                             (line    6)
* Containers:                            RM A 10 7 23 Get_Immediate.
                                                             (line   19)
* Contract cases:                        Pragma Contract_Cases.
                                                             (line    6)
* Contract_Cases:                        Aspect Contract_Cases.
                                                             (line    6)
* control:                               Pragma Check_Policy.
                                                             (line    6)
* Controlling assertions:                Pragma Check_Policy.
                                                             (line    6)
* Convention:                            Effect of Convention on Representation.
                                                             (line    6)
* Convention for anonymous access types: Conventions and Anonymous Access Types.
                                                             (line    6)
* Conventions:                           Conventions.        (line    6)
* Conventions <1>:                       Pragma Convention_Identifier.
                                                             (line    6)
* Conversion:                            System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* Cookie support in CGI:                 GNAT CGI Cookie g-cgicoo ads.
                                                             (line    6)
* CRC32:                                 GNAT CRC32 g-crc32 ads.
                                                             (line    6)
* Current exception:                     GNAT Current_Exception g-curexc ads.
                                                             (line    6)
* Current time:                          GNAT Time_Stamp g-timsta ads.
                                                             (line    6)
* Cyclic Redundancy Check:               GNAT CRC32 g-crc32 ads.
                                                             (line    6)
* Debug pools:                           GNAT Debug_Pools g-debpoo ads.
                                                             (line    6)
* Debugging:                             GNAT Debug_Pools g-debpoo ads.
                                                             (line    6)
* Debugging <1>:                         GNAT Debug_Utilities g-debuti ads.
                                                             (line    6)
* Debugging <2>:                         GNAT Exception_Traces g-exctra ads.
                                                             (line    6)
* debugging with Initialize_Scalars:     Pragma Initialize_Scalars.
                                                             (line    6)
* DEC Ada 83:                            Pragma Extend_System.
                                                             (line    6)
* Dec Ada 83 casing compatibility:       Pragma External_Name_Casing.
                                                             (line    6)
* Decimal radix support:                 RM F 7 COBOL Support.
                                                             (line   15)
* Decoding strings:                      GNAT Decode_String g-decstr ads.
                                                             (line    6)
* Decoding strings <1>:                  GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* Decoding UTF-8 strings:                GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* default:                               Alignment Clauses.  (line   83)
* Default (in pragma Component_Alignment): Pragma Component_Alignment.
                                                             (line   43)
* default settings:                      Pragma Optimize_Alignment.
                                                             (line    6)
* Default_Bit_Order:                     Attribute Default_Bit_Order.
                                                             (line    6)
* Default_Initial_Condition:             Aspect Default_Initial_Condition.
                                                             (line    6)
* Default_Scalar_Storage_Order:          Pragma Default_Scalar_Storage_Order.
                                                             (line    6)
* Default_Scalar_Storage_Order <1>:      Attribute Default_Scalar_Storage_Order.
                                                             (line    6)
* Default_Storage_Pool:                  Pragma Default_Storage_Pool.
                                                             (line    6)
* Deferring aborts:                      Pragma Abort_Defer. (line    6)
* defining:                              Pragma Check_Name.  (line    6)
* Defining check names:                  Pragma Check_Name.  (line    6)
* Depends:                               Aspect Depends.     (line    6)
* Deref:                                 Attribute Deref.    (line    6)
* Descriptor:                            Attribute Descriptor_Size.
                                                             (line    6)
* Descriptor_Size:                       Attribute Descriptor_Size.
                                                             (line    6)
* determination of:                      Determining the Representations chosen by GNAT.
                                                             (line    6)
* Dimension:                             Aspect Dimension.   (line    6)
* Dimension_System:                      Aspect Dimension_System.
                                                             (line    6)
* Directory operations:                  GNAT Directory_Operations g-dirope ads.
                                                             (line    6)
* Directory operations iteration:        GNAT Directory_Operations Iteration g-diopit ads.
                                                             (line    6)
* Disable_Controlled:                    Aspect Disable_Controlled.
                                                             (line    6)
* Discriminants:                         Attribute Has_Discriminants.
                                                             (line    6)
* Distribution Systems Annex:            GNAT Implementation of Shared Passive Packages.
                                                             (line   12)
* Dope vector:                           Attribute Descriptor_Size.
                                                             (line    6)
* Dump Memory:                           GNAT Memory_Dump g-memdum ads.
                                                             (line    6)
* Duration’Small:                        RM 3 6 2 11 Multidimensional Arrays.
                                                             (line   14)
* effect on representation:              Effect of Convention on Representation.
                                                             (line    6)
* Effective_Reads:                       Aspect Effective_Reads.
                                                             (line    6)
* Effective_Writes:                      Aspect Effective_Writes.
                                                             (line    6)
* Elaborated:                            Attribute Elaborated.
                                                             (line    6)
* Elaboration control:                   Pragma Elaboration_Checks.
                                                             (line    6)
* Elab_Body:                             Attribute Elab_Body.
                                                             (line    6)
* Elab_Spec:                             Attribute Elab_Spec.
                                                             (line    6)
* Elab_Subp_Body:                        Attribute Elab_Subp_Body.
                                                             (line    6)
* Elimination of unused subprograms:     Pragma Eliminate.   (line    6)
* Emax:                                  Attribute Emax.     (line    6)
* Enabled:                               Attribute Enabled.  (line    6)
* Enclosing_Entity:                      Enclosing_Entity.   (line    6)
* Encoding strings:                      GNAT Encode_String g-encstr ads.
                                                             (line    6)
* Encoding strings <1>:                  GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* Encoding UTF-8 strings:                GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* Endianness:                            Attribute Scalar_Storage_Order.
                                                             (line    6)
* Endianness <1>:                        GNAT Byte_Swapping g-bytswa ads.
                                                             (line    6)
* Entry queuing policies:                RM D 3 17 Locking Policies.
                                                             (line   12)
* enumeration:                           RM 13 3 71-73 Component Size Clauses.
                                                             (line   23)
* Enumeration representation clauses:    RM 13 3 71-73 Component Size Clauses.
                                                             (line   24)
* Enumeration values:                    RM 3 5 4 29 Integer Types.
                                                             (line   12)
* Enum_Rep:                              Attribute Enum_Rep. (line    6)
* Enum_Val:                              Attribute Enum_Val. (line    6)
* Environment entries:                   Ada Command_Line Environment a-colien ads.
                                                             (line    6)
* Epsilon:                               Attribute Epsilon.  (line    6)
* Error detection:                       Implementation Advice.
                                                             (line   28)
* exception:                             Pragma Prefix_Exception_Messages.
                                                             (line    6)
* Exception:                             GNAT Most_Recent_Exception g-moreex ads.
                                                             (line    6)
* exception <1>:                         System Assertions s-assert ads.
                                                             (line    6)
* Exception actions:                     GNAT Exception_Actions g-excact ads.
                                                             (line    6)
* Exception information:                 RM 10 2 1 12 Consistent Representation.
                                                             (line   18)
* Exception retrieval:                   GNAT Current_Exception g-curexc ads.
                                                             (line    6)
* Exception traces:                      GNAT Exception_Traces g-exctra ads.
                                                             (line    6)
* Exceptions:                            GNAT Exceptions g-except ads.
                                                             (line    6)
* exceptions:                            GNAT Exceptions g-except ads.
                                                             (line    6)
* Exception_Information’:                Exception_Information.
                                                             (line    6)
* Exception_Message:                     Pragma Prefix_Exception_Messages.
                                                             (line    6)
* Exception_Message <1>:                 Exception_Message.  (line    6)
* Exception_Name:                        Exception_Name.     (line    6)
* Export:                                RM A 18 Containers. (line   17)
* Export <1>:                            Address Clauses.    (line  106)
* extendable:                            GNAT Dynamic_Tables g-dyntab ads.
                                                             (line    6)
* extendable <1>:                        GNAT Table g-table ads.
                                                             (line    6)
* extending:                             Pragma Extend_System.
                                                             (line    6)
* extensions for unbounded strings:      Ada Strings Unbounded Text_IO a-suteio ads.
                                                             (line    6)
* extensions for unbounded wide strings: Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
                                                             (line    6)
* extensions for unbounded wide wide strings: Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
                                                             (line    6)
* Extensions_Visible:                    Aspect Extensions_Visible.
                                                             (line    6)
* External Names:                        Pragma External_Name_Casing.
                                                             (line    6)
* Fast_Math:                             Attribute Fast_Math.
                                                             (line    6)
* Favor_Top_Level:                       Aspect Favor_Top_Level.
                                                             (line    6)
* File:                                  File.               (line    6)
* File locking:                          GNAT Lock_Files g-locfil ads.
                                                             (line    6)
* Finalization_Size:                     Attribute Finalization_Size.
                                                             (line    6)
* Fixed_Value:                           Attribute Fixed_Value.
                                                             (line    6)
* Float types:                           RM 3 5 5 8 Enumeration Values.
                                                             (line   15)
* Floating-point overflow:               Pragma Check_Float_Overflow.
                                                             (line    6)
* Floating-Point Processor:              GNAT Float_Control g-flocon ads.
                                                             (line    6)
* foreign:                               GNAT Threads g-thread ads.
                                                             (line    6)
* Foreign threads:                       GNAT Threads g-thread ads.
                                                             (line    6)
* Forking a new process:                 Mapping Ada Tasks onto the Underlying Kernel Threads.
                                                             (line   53)
* Formal container for doubly linked lists: Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads.
                                                             (line    6)
* Formal container for hashed maps:      Ada Containers Formal_Hashed_Maps a-cfhama ads.
                                                             (line    6)
* Formal container for hashed sets:      Ada Containers Formal_Hashed_Sets a-cfhase ads.
                                                             (line    6)
* Formal container for ordered maps:     Ada Containers Formal_Ordered_Maps a-cforma ads.
                                                             (line    6)
* Formal container for ordered sets:     Ada Containers Formal_Ordered_Sets a-cforse ads.
                                                             (line    6)
* Formal container for vectors:          Ada Containers Formal_Vectors a-cofove ads.
                                                             (line    6)
* Formal container for vectors <1>:      Ada Containers Formal_Indefinite_Vectors a-cfinve ads.
                                                             (line    6)
* Formal container for vectors <2>:      Ada Containers Bounded_Holders a-coboho ads.
                                                             (line    6)
* Formatted String:                      GNAT Formatted_String g-forstr ads.
                                                             (line    6)
* Fortran:                               RM B 4 95-98 Interfacing with COBOL.
                                                             (line   28)
* From_Any:                              Attribute From_Any. (line    6)
* Functional maps:                       Ada Containers Functional_Maps a-cofuma ads.
                                                             (line    6)
* Functional sets:                       Ada Containers Functional_Sets a-cofuse ads.
                                                             (line    6)
* Functional vectors:                    Ada Containers Functional_Vectors a-cofuve ads.
                                                             (line    6)
* Get_Immediate:                         RM A 5 2 46-47 Random Number Generation.
                                                             (line   21)
* Get_Immediate <1>:                     Get_Immediate.      (line    6)
* Get_Immediate <2>:                     Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* Get_Immediate <3>:                     Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* Ghost:                                 Aspect Ghost.       (line    6)
* Global:                                Aspect Global.      (line    6)
* global:                                System Pool_Global s-pooglo ads.
                                                             (line    6)
* Global storage pool:                   System Pool_Global s-pooglo ads.
                                                             (line    6)
* GNAT Extensions:                       Pragma Extensions_Allowed.
                                                             (line    6)
* GNAT.Altivec (g-altive.ads):           GNAT Altivec g-altive ads.
                                                             (line    6)
* GNAT.Altivec.Conversions (g-altcon.ads): GNAT Altivec Conversions g-altcon ads.
                                                             (line    6)
* GNAT.Altivec.Vector_Operations (g-alveop.ads): GNAT Altivec Vector_Operations g-alveop ads.
                                                             (line    6)
* GNAT.Altivec.Vector_Types (g-alvety.ads): GNAT Altivec Vector_Types g-alvety ads.
                                                             (line    6)
* GNAT.Altivec.Vector_Views (g-alvevi.ads): GNAT Altivec Vector_Views g-alvevi ads.
                                                             (line    6)
* GNAT.Array_Split (g-arrspl.ads):       GNAT Array_Split g-arrspl ads.
                                                             (line    6)
* GNAT.AWK (g-awk.ads):                  GNAT AWK g-awk ads. (line    6)
* GNAT.Bind_Environment (g-binenv.ads):  GNAT Bind_Environment g-binenv ads.
                                                             (line    6)
* GNAT.Bounded_Buffers (g-boubuf.ads):   GNAT Bounded_Buffers g-boubuf ads.
                                                             (line    6)
* GNAT.Bounded_Mailboxes (g-boumai.ads): GNAT Bounded_Mailboxes g-boumai ads.
                                                             (line    6)
* GNAT.Branch_Prediction (g-brapre.ads): GNAT Branch_Prediction g-brapre ads.
                                                             (line    6)
* GNAT.Bubble_Sort (g-bubsor.ads):       GNAT Bubble_Sort g-bubsor ads.
                                                             (line    6)
* GNAT.Bubble_Sort_A (g-busora.ads):     GNAT Bubble_Sort_A g-busora ads.
                                                             (line    6)
* GNAT.Bubble_Sort_G (g-busorg.ads):     GNAT Bubble_Sort_G g-busorg ads.
                                                             (line    6)
* GNAT.Byte_Order_Mark (g-byorma.ads):   GNAT Byte_Order_Mark g-byorma ads.
                                                             (line    6)
* GNAT.Byte_Swapping (g-bytswa.ads):     GNAT Byte_Swapping g-bytswa ads.
                                                             (line    6)
* GNAT.Calendar (g-calend.ads):          GNAT Calendar g-calend ads.
                                                             (line    6)
* GNAT.Calendar.Time_IO (g-catiio.ads):  GNAT Calendar Time_IO g-catiio ads.
                                                             (line    5)
* GNAT.Case_Util (g-casuti.ads):         GNAT Case_Util g-casuti ads.
                                                             (line    6)
* GNAT.CGI (g-cgi.ads):                  GNAT CGI g-cgi ads. (line    6)
* GNAT.CGI.Cookie (g-cgicoo.ads):        GNAT CGI Cookie g-cgicoo ads.
                                                             (line    6)
* GNAT.CGI.Debug (g-cgideb.ads):         GNAT CGI Debug g-cgideb ads.
                                                             (line    6)
* GNAT.Command_Line (g-comlin.ads):      GNAT Command_Line g-comlin ads.
                                                             (line    6)
* GNAT.Compiler_Version (g-comver.ads):  GNAT Compiler_Version g-comver ads.
                                                             (line    6)
* GNAT.CRC32 (g-crc32.ads):              GNAT CRC32 g-crc32 ads.
                                                             (line    6)
* GNAT.Ctrl_C (g-ctrl_c.ads):            GNAT Ctrl_C g-ctrl_c ads.
                                                             (line    6)
* GNAT.Current_Exception (g-curexc.ads): GNAT Current_Exception g-curexc ads.
                                                             (line    6)
* GNAT.Debug_Pools (g-debpoo.ads):       GNAT Debug_Pools g-debpoo ads.
                                                             (line    6)
* GNAT.Debug_Utilities (g-debuti.ads):   GNAT Debug_Utilities g-debuti ads.
                                                             (line    6)
* GNAT.Decode_String (g-decstr.ads):     GNAT Decode_String g-decstr ads.
                                                             (line    6)
* GNAT.Decode_UTF8_String (g-deutst.ads): GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* GNAT.Directory_Operations (g-dirope.ads): GNAT Directory_Operations g-dirope ads.
                                                             (line    6)
* GNAT.Directory_Operations.Iteration (g-diopit.ads): GNAT Directory_Operations Iteration g-diopit ads.
                                                             (line    6)
* GNAT.Dynamic_HTables (g-dynhta.ads):   GNAT Dynamic_HTables g-dynhta ads.
                                                             (line    6)
* GNAT.Dynamic_Tables (g-dyntab.ads):    GNAT Dynamic_Tables g-dyntab ads.
                                                             (line    6)
* GNAT.Encode_String (g-encstr.ads):     GNAT Encode_String g-encstr ads.
                                                             (line    6)
* GNAT.Encode_UTF8_String (g-enutst.ads): GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* GNAT.Exceptions (g-except.ads):        GNAT Exceptions g-except ads.
                                                             (line    6)
* GNAT.Exception_Actions (g-excact.ads): GNAT Exception_Actions g-excact ads.
                                                             (line    6)
* GNAT.Exception_Traces (g-exctra.ads):  GNAT Exception_Traces g-exctra ads.
                                                             (line    6)
* GNAT.Expect (g-expect.ads):            GNAT Expect g-expect ads.
                                                             (line    6)
* GNAT.Expect.TTY (g-exptty.ads):        GNAT Expect TTY g-exptty ads.
                                                             (line    6)
* GNAT.Float_Control (g-flocon.ads):     GNAT Float_Control g-flocon ads.
                                                             (line    6)
* GNAT.Formatted_String (g-forstr.ads):  GNAT Formatted_String g-forstr ads.
                                                             (line    6)
* GNAT.Heap_Sort (g-heasor.ads):         GNAT Heap_Sort g-heasor ads.
                                                             (line    6)
* GNAT.Heap_Sort_A (g-hesora.ads):       GNAT Heap_Sort_A g-hesora ads.
                                                             (line    6)
* GNAT.Heap_Sort_G (g-hesorg.ads):       GNAT Heap_Sort_G g-hesorg ads.
                                                             (line    6)
* GNAT.HTable (g-htable.ads):            GNAT HTable g-htable ads.
                                                             (line    6)
* GNAT.IO (g-io.ads):                    GNAT IO g-io ads.   (line    6)
* GNAT.IO_Aux (g-io_aux.ads):            GNAT IO_Aux g-io_aux ads.
                                                             (line    6)
* GNAT.Lock_Files (g-locfil.ads):        GNAT Lock_Files g-locfil ads.
                                                             (line    6)
* GNAT.MBBS_Discrete_Random (g-mbdira.ads): GNAT MBBS_Discrete_Random g-mbdira ads.
                                                             (line    6)
* GNAT.MBBS_Float_Random (g-mbflra.ads): GNAT MBBS_Float_Random g-mbflra ads.
                                                             (line    6)
* GNAT.MD5 (g-md5.ads):                  GNAT MD5 g-md5 ads. (line    6)
* GNAT.Memory_Dump (g-memdum.ads):       GNAT Memory_Dump g-memdum ads.
                                                             (line    6)
* GNAT.Most_Recent_Exception (g-moreex.ads): GNAT Most_Recent_Exception g-moreex ads.
                                                             (line    6)
* GNAT.OS_Lib (g-os_lib.ads):            GNAT OS_Lib g-os_lib ads.
                                                             (line    6)
* GNAT.Perfect_Hash_Generators (g-pehage.ads): GNAT Perfect_Hash_Generators g-pehage ads.
                                                             (line    6)
* GNAT.Random_Numbers (g-rannum.ads):    GNAT Random_Numbers g-rannum ads.
                                                             (line    6)
* GNAT.Regexp (g-regexp.ads):            GNAT Regexp g-regexp ads.
                                                             (line    6)
* GNAT.Registry (g-regist.ads):          GNAT Registry g-regist ads.
                                                             (line    6)
* GNAT.Regpat (g-regpat.ads):            GNAT Regpat g-regpat ads.
                                                             (line    6)
* GNAT.Rewrite_Data (g-rewdat.ads):      GNAT Rewrite_Data g-rewdat ads.
                                                             (line    6)
* GNAT.Secondary_Stack_Info (g-sestin.ads): GNAT Secondary_Stack_Info g-sestin ads.
                                                             (line    6)
* GNAT.Semaphores (g-semaph.ads):        GNAT Semaphores g-semaph ads.
                                                             (line    6)
* GNAT.Serial_Communications (g-sercom.ads): GNAT Serial_Communications g-sercom ads.
                                                             (line    6)
* GNAT.SHA1 (g-sha1.ads):                GNAT SHA1 g-sha1 ads.
                                                             (line    6)
* GNAT.SHA224 (g-sha224.ads):            GNAT SHA224 g-sha224 ads.
                                                             (line    6)
* GNAT.SHA256 (g-sha256.ads):            GNAT SHA256 g-sha256 ads.
                                                             (line    6)
* GNAT.SHA384 (g-sha384.ads):            GNAT SHA384 g-sha384 ads.
                                                             (line    6)
* GNAT.SHA512 (g-sha512.ads):            GNAT SHA512 g-sha512 ads.
                                                             (line    6)
* GNAT.Signals (g-signal.ads):           GNAT Signals g-signal ads.
                                                             (line    6)
* GNAT.Sockets (g-socket.ads):           GNAT Sockets g-socket ads.
                                                             (line    6)
* GNAT.Source_Info (g-souinf.ads):       GNAT Source_Info g-souinf ads.
                                                             (line    6)
* GNAT.Spelling_Checker (g-speche.ads):  GNAT Spelling_Checker g-speche ads.
                                                             (line    6)
* GNAT.Spelling_Checker_Generic (g-spchge.ads): GNAT Spelling_Checker_Generic g-spchge ads.
                                                             (line    6)
* GNAT.Spitbol (g-spitbo.ads):           GNAT Spitbol g-spitbo ads.
                                                             (line    6)
* GNAT.Spitbol.Patterns (g-spipat.ads):  GNAT Spitbol Patterns g-spipat ads.
                                                             (line    6)
* GNAT.Spitbol.Table_Boolean (g-sptabo.ads): GNAT Spitbol Table_Boolean g-sptabo ads.
                                                             (line    6)
* GNAT.Spitbol.Table_Integer (g-sptain.ads): GNAT Spitbol Table_Integer g-sptain ads.
                                                             (line    6)
* GNAT.Spitbol.Table_VString (g-sptavs.ads): GNAT Spitbol Table_VString g-sptavs ads.
                                                             (line    6)
* GNAT.SSE (g-sse.ads):                  GNAT SSE g-sse ads. (line    6)
* GNAT.SSE.Vector_Types (g-ssvety.ads):  GNAT SSE Vector_Types g-ssvety ads.
                                                             (line    6)
* GNAT.Strings (g-string.ads):           GNAT Strings g-string ads.
                                                             (line    6)
* GNAT.String_Hash (g-strhas.ads):       GNAT String_Hash g-strhas ads.
                                                             (line    6)
* GNAT.String_Split (g-strspl.ads):      GNAT String_Split g-strspl ads.
                                                             (line    6)
* GNAT.Table (g-table.ads):              GNAT Table g-table ads.
                                                             (line    6)
* GNAT.Task_Lock (g-tasloc.ads):         GNAT Task_Lock g-tasloc ads.
                                                             (line    6)
* GNAT.Threads (g-thread.ads):           GNAT Threads g-thread ads.
                                                             (line    6)
* GNAT.Time_Stamp (g-timsta.ads):        GNAT Time_Stamp g-timsta ads.
                                                             (line    6)
* GNAT.Traceback (g-traceb.ads):         GNAT Traceback g-traceb ads.
                                                             (line    6)
* GNAT.Traceback.Symbolic (g-trasym.ads): GNAT Traceback Symbolic g-trasym ads.
                                                             (line    6)
* GNAT.UTF_32 (g-table.ads):             GNAT UTF_32 g-table ads.
                                                             (line    6)
* GNAT.Wide_Spelling_Checker (g-u3spch.ads): GNAT Wide_Spelling_Checker g-u3spch ads.
                                                             (line    6)
* GNAT.Wide_Spelling_Checker (g-wispch.ads): GNAT Wide_Spelling_Checker g-wispch ads.
                                                             (line    6)
* GNAT.Wide_String_Split (g-wistsp.ads): GNAT Wide_String_Split g-wistsp ads.
                                                             (line    6)
* GNAT.Wide_Wide_Spelling_Checker (g-zspche.ads): GNAT Wide_Wide_Spelling_Checker g-zspche ads.
                                                             (line    6)
* GNAT.Wide_Wide_String_Split (g-zistsp.ads): GNAT Wide_Wide_String_Split g-zistsp ads.
                                                             (line    6)
* handling long command lines:           Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Handling of Records with Holes:        Handling of Records with Holes.
                                                             (line    6)
* Hash functions:                        GNAT Perfect_Hash_Generators g-pehage ads.
                                                             (line    6)
* Hash functions <1>:                    GNAT String_Hash g-strhas ads.
                                                             (line    6)
* Hash tables:                           GNAT Dynamic_HTables g-dynhta ads.
                                                             (line    6)
* Hash tables <1>:                       GNAT HTable g-htable ads.
                                                             (line    6)
* Has_Access_Values:                     Attribute Has_Access_Values.
                                                             (line    6)
* Has_Discriminants:                     Attribute Has_Discriminants.
                                                             (line    6)
* Has_Tagged_Values:                     Attribute Has_Tagged_Values.
                                                             (line    6)
* Heap usage:                            RM 13 9 14-17 Unchecked Conversion.
                                                             (line   34)
* I/O interfacing:                       Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* IBM Packed Format:                     Interfaces Packed_Decimal i-pacdec ads.
                                                             (line    6)
* Image:                                 System Address_Image s-addima ads.
                                                             (line    6)
* Img:                                   Attribute Img.      (line    6)
* Immediate_Reclamation:                 Immediate_Reclamation.
                                                             (line    6)
* Implementation-dependent features:     About This Guide.   (line   24)
* implicit:                              RM 13 9 14-17 Unchecked Conversion.
                                                             (line   33)
* Import:                                Address Clauses.    (line  111)
* Initialization:                        Pragma Suppress_Initialization.
                                                             (line    6)
* Initialized:                           Attribute Initialized.
                                                             (line    6)
* Initializes:                           Aspect Initializes. (line    6)
* Initial_Condition:                     Aspect Initial_Condition.
                                                             (line    6)
* Inline_Always:                         Aspect Inline_Always.
                                                             (line    6)
* Input/Output facilities:               GNAT IO g-io ads.   (line    6)
* Input/Output facilities <1>:           GNAT IO_Aux g-io_aux ads.
                                                             (line    6)
* Integer maps:                          GNAT Spitbol Table_Integer g-sptain ads.
                                                             (line    6)
* Integer types:                         RM 3 5 2 5 Alternative Character Sets.
                                                             (line   23)
* Integer_Value:                         Attribute Integer_Value.
                                                             (line    6)
* Interfaces:                            RM B 1 39-41 Pragma Export.
                                                             (line   34)
* Interfaces.C.Extensions (i-cexten.ads): Interfaces C Extensions i-cexten ads.
                                                             (line    6)
* Interfaces.C.Streams (i-cstrea.ads):   Interfaces C Streams i-cstrea ads.
                                                             (line    6)
* Interfaces.Packed_Decimal (i-pacdec.ads): Interfaces Packed_Decimal i-pacdec ads.
                                                             (line    6)
* Interfaces.VxWorks (i-vxwork.ads):     Interfaces VxWorks i-vxwork ads.
                                                             (line    6)
* Interfaces.VxWorks.Int_Connection (i-vxinco.ads): Interfaces VxWorks Int_Connection i-vxinco ads.
                                                             (line    6)
* Interfaces.VxWorks.IO (i-vxwoio.ads):  Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* interfacing:                           Interfaces C Streams i-cstrea ads.
                                                             (line    6)
* interfacing <1>:                       Interfaces VxWorks i-vxwork ads.
                                                             (line    6)
* interfacing <2>:                       Interfaces VxWorks Int_Connection i-vxinco ads.
                                                             (line    6)
* Interfacing to C++:                    Pragma CPP_Virtual. (line    6)
* Interfacing to C++ <1>:                Pragma Propagate_Exceptions.
                                                             (line    6)
* Interfacing to VxWorks:                Interfaces VxWorks i-vxwork ads.
                                                             (line    6)
* Interfacing to VxWorks <1>:            Interfaces VxWorks Int_Connection i-vxinco ads.
                                                             (line    6)
* Interfacing to VxWorks’ I/O:           Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* interfacing with:                      RM B 2 12-13 Package Interfaces.
                                                             (line   21)
* interfacing with <1>:                  RM B 3 63-71 Interfacing with C.
                                                             (line   57)
* interfacing with <2>:                  RM B 4 95-98 Interfacing with COBOL.
                                                             (line   27)
* Interfacing with C++:                  Pragma CPP_Class.   (line    6)
* Interfacing with C++ <1>:              Pragma CPP_Constructor.
                                                             (line    6)
* Interfacing with C++ <2>:              Pragma CPP_Vtable.  (line    6)
* Interfacing with Direct_IO:            Ada Direct_IO C_Streams a-diocst ads.
                                                             (line    6)
* Interfacing with Sequential_IO:        Ada Sequential_IO C_Streams a-siocst ads.
                                                             (line    6)
* Interfacing with Stream_IO:            Ada Streams Stream_IO C_Streams a-ssicst ads.
                                                             (line    6)
* Interfacing with ‘‘Text_IO‘‘:          Ada Text_IO C_Streams a-tiocst ads.
                                                             (line    6)
* Interfacing with ‘‘Wide_Text_IO‘‘:     Ada Wide_Text_IO C_Streams a-wtcstr ads.
                                                             (line    6)
* Interfacing with ‘‘Wide_Wide_Text_IO‘‘: Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads.
                                                             (line    6)
* Interrupt:                             GNAT Ctrl_C g-ctrl_c ads.
                                                             (line    6)
* Interrupt support:                     RM C 1 10-16 Access to Machine Operations.
                                                             (line   39)
* Interrupts:                            RM C 3 1 20-21 Protected Procedure Handlers.
                                                             (line   16)
* Intrinsic operator:                    Intrinsic Operators.
                                                             (line    6)
* Intrinsic Subprograms:                 Intrinsic Subprograms.
                                                             (line    6)
* Invalid representations:               Pragma Assume_No_Invalid_Values.
                                                             (line    6)
* Invalid values:                        Pragma Assume_No_Invalid_Values.
                                                             (line    6)
* Invalid_Value:                         Attribute Invalid_Value.
                                                             (line    6)
* Invariant:                             Aspect Invariant.   (line    6)
* Invariant’Class:                       Aspect Invariant’Class.
                                                             (line    6)
* IO support:                            Ada Strings Unbounded Text_IO a-suteio ads.
                                                             (line    6)
* IO support <1>:                        Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
                                                             (line    6)
* IO support <2>:                        Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
                                                             (line    6)
* Iterable:                              Aspect Iterable.    (line    6)
* Iterable <1>:                          Attribute Iterable. (line    6)
* Large:                                 Attribute Large.    (line    6)
* Latin-1:                               Changed semantics.  (line   12)
* Latin_1 constants for Wide_Character:  Ada Characters Wide_Latin_1 a-cwila1 ads.
                                                             (line    6)
* Latin_1 constants for Wide_Wide_Character: Ada Characters Wide_Wide_Latin_1 a-chzla1 ads.
                                                             (line    6)
* Latin_9 constants for Character:       Ada Characters Latin_9 a-chlat9 ads.
                                                             (line    6)
* Latin_9 constants for Wide_Character:  Ada Characters Wide_Latin_9 a-cwila1 ads.
                                                             (line    6)
* Latin_9 constants for Wide_Wide_Character: Ada Characters Wide_Wide_Latin_9 a-chzla9 ads.
                                                             (line    6)
* Library_Level:                         Attribute Library_Level.
                                                             (line    6)
* License checking:                      Pragma License.     (line    6)
* Line:                                  Line.               (line    6)
* Linker_Section:                        Aspect Linker_Section.
                                                             (line    6)
* Little endian:                         Attribute Default_Bit_Order.
                                                             (line    6)
* Little endian <1>:                     Attribute Default_Scalar_Storage_Order.
                                                             (line    6)
* local:                                 System Pool_Local s-pooloc ads.
                                                             (line    6)
* Local storage pool:                    System Pool_Local s-pooloc ads.
                                                             (line    6)
* Locking:                               GNAT Task_Lock g-tasloc ads.
                                                             (line    6)
* Locking Policies:                      RM C 7 2 30 The Package Task_Attributes.
                                                             (line   17)
* Locking using files:                   GNAT Lock_Files g-locfil ads.
                                                             (line    6)
* Lock_Free:                             Aspect Lock_Free.   (line    6)
* Lock_Free <1>:                         Attribute Lock_Free.
                                                             (line    6)
* Loop_Entry:                            Attribute Loop_Entry.
                                                             (line    6)
* Machine Code insertions:               Machine Code Insertions.
                                                             (line    6)
* Machine operations:                    RM B 5 22-26 Interfacing with Fortran.
                                                             (line   34)
* Machine_Size:                          Attribute Machine_Size.
                                                             (line    6)
* Mailboxes:                             GNAT Bounded_Mailboxes g-boumai ads.
                                                             (line    6)
* Mantissa:                              Attribute Mantissa. (line    6)
* Maps:                                  GNAT Spitbol Table_Integer g-sptain ads.
                                                             (line    6)
* Maps <1>:                              GNAT Spitbol Table_VString g-sptavs ads.
                                                             (line    6)
* maximum:                               Attribute Maximum_Alignment.
                                                             (line    6)
* Maximum_Alignment:                     Attribute Maximum_Alignment.
                                                             (line    6)
* Maximum_Alignment attribute:           Alignment Clauses.  (line   21)
* Max_Asynchronous_Select_Nesting:       Max_Asynchronous_Select_Nesting.
                                                             (line    6)
* Max_Entry_Queue_Depth:                 Max_Entry_Queue_Length.
                                                             (line   13)
* Max_Entry_Queue_Length:                Max_Entry_Queue_Length.
                                                             (line    6)
* Max_Integer_Size:                      Attribute Max_Integer_Size.
                                                             (line    6)
* Max_Protected_Entries:                 Max_Protected_Entries.
                                                             (line    6)
* Max_Queue_Length:                      Aspect Max_Queue_Length.
                                                             (line    6)
* Max_Select_Alternatives:               Max_Select_Alternatives.
                                                             (line    6)
* Max_Storage_At_Blocking:               Max_Storage_At_Blocking.
                                                             (line    6)
* Max_Tasks:                             Max_Tasks.          (line    6)
* Max_Task_Entries:                      Max_Task_Entries.   (line    6)
* Mechanism_Code:                        Attribute Mechanism_Code.
                                                             (line    6)
* Memory allocation:                     System Memory s-memory ads.
                                                             (line    6)
* Memory corruption debugging:           GNAT Debug_Pools g-debpoo ads.
                                                             (line    6)
* Memory-mapped I/O:                     Use of Address Clauses for Memory-Mapped I/O.
                                                             (line    6)
* Message Digest MD5:                    GNAT MD5 g-md5 ads. (line    6)
* monotonic:                             RM D 7 21 Tasking Restrictions.
                                                             (line   13)
* multidimensional:                      RM 3 5 7 17 Float Types.
                                                             (line   23)
* Multidimensional arrays:               RM 3 5 7 17 Float Types.
                                                             (line   24)
* Multiprocessor interface:              System Multiprocessors s-multip ads.
                                                             (line    6)
* Multiprocessor interface <1>:          System Multiprocessors Dispatching_Domains s-mudido ads.
                                                             (line    6)
* Named assertions:                      Pragma Check.       (line    6)
* Named assertions <1>:                  Pragma Check_Policy.
                                                             (line    6)
* Named numbers:                         Attribute Universal_Literal_String.
                                                             (line    6)
* No_Abort_Statements:                   No_Abort_Statements.
                                                             (line    6)
* No_Access_Parameter_Allocators:        No_Access_Parameter_Allocators.
                                                             (line    6)
* No_Access_Subprograms:                 No_Access_Subprograms.
                                                             (line    6)
* No_Allocators:                         No_Allocators.      (line    6)
* No_Anonymous_Allocators:               No_Anonymous_Allocators.
                                                             (line    6)
* No_Asynchronous_Control:               No_Asynchronous_Control.
                                                             (line    6)
* No_Caching:                            Aspect No_Caching.  (line    6)
* No_Calendar:                           No_Calendar.        (line    6)
* No_Coextensions:                       No_Coextensions.    (line    6)
* No_Default_Initialization:             No_Default_Initialization.
                                                             (line    6)
* No_Delay:                              No_Delay.           (line    6)
* No_Dependence:                         No_Dependence.      (line    6)
* No_Direct_Boolean_Operators:           No_Direct_Boolean_Operators.
                                                             (line    6)
* No_Dispatch:                           No_Dispatch.        (line    6)
* No_Dispatching_Calls:                  No_Dispatching_Calls.
                                                             (line    6)
* No_Dynamic_Accessibility_Checks:       No_Dynamic_Accessibility_Checks.
                                                             (line    6)
* No_Dynamic_Attachment:                 No_Dynamic_Attachment.
                                                             (line    6)
* No_Dynamic_Interrupts:                 No_Dynamic_Attachment.
                                                             (line   11)
* No_Dynamic_Priorities:                 No_Dynamic_Priorities.
                                                             (line    6)
* No_Dynamic_Sized_Objects:              No_Dynamic_Sized_Objects.
                                                             (line    6)
* No_Elaboration_Code:                   No_Elaboration_Code.
                                                             (line    6)
* No_Elaboration_Code_All:               Aspect No_Elaboration_Code_All.
                                                             (line    6)
* No_Entry_Calls_In_Elaboration_Code:    No_Entry_Calls_In_Elaboration_Code.
                                                             (line    6)
* No_Entry_Queue:                        No_Entry_Queue.     (line    6)
* No_Enumeration_Maps:                   No_Enumeration_Maps.
                                                             (line    6)
* No_Exceptions:                         No_Exceptions.      (line    6)
* No_Exception_Handlers:                 No_Exception_Handlers.
                                                             (line    6)
* No_Exception_Propagation:              No_Exception_Propagation.
                                                             (line    6)
* No_Exception_Registration:             No_Exception_Registration.
                                                             (line    6)
* No_Finalization:                       No_Finalization.    (line    6)
* No_Fixed_Point:                        No_Fixed_Point.     (line    6)
* No_Floating_Point:                     No_Floating_Point.  (line    6)
* No_Implementation_Aspect_Specifications: No_Implementation_Aspect_Specifications.
                                                             (line    6)
* No_Implementation_Attributes:          No_Implementation_Attributes.
                                                             (line    6)
* No_Implementation_Identifiers:         No_Implementation_Identifiers.
                                                             (line    6)
* No_Implementation_Pragmas:             No_Implementation_Pragmas.
                                                             (line    6)
* No_Implementation_Restrictions:        No_Implementation_Restrictions.
                                                             (line    6)
* No_Implementation_Units:               No_Implementation_Units.
                                                             (line    6)
* No_Implicit_Aliasing:                  No_Implicit_Aliasing.
                                                             (line    6)
* No_Implicit_Conditionals:              No_Implicit_Conditionals.
                                                             (line    6)
* No_Implicit_Dynamic_Code:              No_Implicit_Dynamic_Code.
                                                             (line    6)
* No_Implicit_Heap_Allocations:          No_Implicit_Heap_Allocations.
                                                             (line    6)
* No_Implicit_Loops:                     No_Implicit_Loops.  (line    6)
* No_Implicit_Protected_Object_Allocations: No_Implicit_Protected_Object_Allocations.
                                                             (line    6)
* No_Implicit_Task_Allocations:          No_Implicit_Task_Allocations.
                                                             (line    6)
* No_Initialize_Scalars:                 No_Initialize_Scalars.
                                                             (line    6)
* No_Inline:                             Aspect No_Inline.   (line    6)
* No_IO:                                 No_IO.              (line    6)
* No_Local_Allocators:                   No_Local_Allocators.
                                                             (line    6)
* No_Local_Protected_Objects:            No_Local_Protected_Objects.
                                                             (line    6)
* No_Local_Timing_Events:                No_Local_Timing_Events.
                                                             (line    6)
* No_Long_Long_Integers:                 No_Long_Long_Integers.
                                                             (line    6)
* No_Multiple_Elaboration:               No_Multiple_Elaboration.
                                                             (line    6)
* No_Nested_Finalization:                No_Nested_Finalization.
                                                             (line    6)
* No_Obsolescent_Features:               No_Obsolescent_Features.
                                                             (line    6)
* No_Protected_Types:                    No_Protected_Types. (line    6)
* No_Protected_Type_Allocators:          No_Protected_Type_Allocators.
                                                             (line    6)
* No_Recursion:                          No_Recursion.       (line    6)
* No_Reentrancy:                         No_Reentrancy.      (line    6)
* No_Relative_Delay:                     No_Relative_Delay.  (line    6)
* No_Requeue:                            No_Requeue_Statements.
                                                             (line   10)
* No_Requeue_Statements:                 No_Requeue_Statements.
                                                             (line    6)
* No_Secondary_Stack:                    No_Secondary_Stack. (line    6)
* No_Select_Statements:                  No_Select_Statements.
                                                             (line    6)
* No_Specification_of_Aspect:            No_Specification_of_Aspect.
                                                             (line    6)
* No_Specific_Termination_Handlers:      No_Specific_Termination_Handlers.
                                                             (line    6)
* No_Standard_Allocators_After_Elaboration: No_Standard_Allocators_After_Elaboration.
                                                             (line    6)
* No_Standard_Storage_Pools:             No_Standard_Storage_Pools.
                                                             (line    6)
* No_Streams:                            No_Streams.         (line    6)
* No_Stream_Optimizations:               No_Stream_Optimizations.
                                                             (line    6)
* No_Tagged_Streams:                     Aspect No_Tagged_Streams.
                                                             (line    6)
* No_Tagged_Type_Registration:           No_Tagged_Type_Registration.
                                                             (line    6)
* No_Tasking:                            No_Tasking.         (line    6)
* No_Task_Allocators:                    No_Task_Allocators. (line    6)
* No_Task_Attributes:                    No_Task_Attributes_Package.
                                                             (line    9)
* No_Task_Attributes_Package:            No_Task_Attributes_Package.
                                                             (line    6)
* No_Task_At_Interrupt_Priority:         No_Task_At_Interrupt_Priority.
                                                             (line    6)
* No_Task_Hierarchy:                     No_Task_Hierarchy.  (line    6)
* No_Task_Parts:                         Aspect No_Task_Parts.
                                                             (line    6)
* No_Task_Termination:                   No_Task_Termination.
                                                             (line    6)
* No_Terminate_Alternatives:             No_Terminate_Alternatives.
                                                             (line    6)
* No_Unchecked_Access:                   No_Unchecked_Access.
                                                             (line    6)
* No_Unchecked_Conversion:               No_Unchecked_Conversion.
                                                             (line    6)
* No_Unchecked_Deallocation:             No_Unchecked_Deallocation.
                                                             (line    6)
* No_Use_Of_Entity:                      No_Use_Of_Entity.   (line    6)
* No_Wide_Characters:                    No_Wide_Characters. (line    6)
* Null_Occurrence:                       Ada Exceptions Is_Null_Occurrence a-einuoc ads.
                                                             (line    6)
* Null_Occurrence <1>:                   Ada Exceptions Last_Chance_Handler a-elchha ads.
                                                             (line    6)
* Null_Parameter:                        Attribute Null_Parameter.
                                                             (line    6)
* Numerics:                              RM F 1 2 Decimal Radix Support.
                                                             (line   11)
* Object_Size:                           Aspect Object_Size. (line    6)
* Object_Size <1>:                       Attribute Object_Size.
                                                             (line    6)
* Object_Size <2>:                       Value_Size and Object_Size Clauses.
                                                             (line    6)
* Obsolsecent:                           Aspect Obsolescent. (line    6)
* obtaining most recent:                 GNAT Most_Recent_Exception g-moreex ads.
                                                             (line    6)
* of an address:                         System Address_Image s-addima ads.
                                                             (line    6)
* of bits:                               Bit_Order Clauses.  (line    6)
* of bytes:                              Effect of Bit_Order on Byte Ordering.
                                                             (line    6)
* of compiler:                           GNAT Compiler_Version g-comver ads.
                                                             (line    6)
* of objects:                            Value_Size and Object_Size Clauses.
                                                             (line    6)
* Old:                                   Attribute Old.      (line    6)
* on ‘‘Address‘‘:                        RM 13 7 37 Address as Private.
                                                             (line   10)
* Operating System interface:            GNAT OS_Lib g-os_lib ads.
                                                             (line    6)
* Operations:                            RM 13 7 37 Address as Private.
                                                             (line   10)
* operations of:                         RM 13 7 37 Address as Private.
                                                             (line    9)
* ordering:                              Bit_Order Clauses.  (line    6)
* ordering <1>:                          Effect of Bit_Order on Byte Ordering.
                                                             (line    6)
* Overlaying of objects:                 Address Clauses.    (line  160)
* Package Interfaces:                    RM B 1 39-41 Pragma Export.
                                                             (line   35)
* Package Task_Attributes:               RM C 5 8 Pragma Discard_Names.
                                                             (line   12)
* Package ‘‘Interrupts‘‘:                RM C 3 1 20-21 Protected Procedure Handlers.
                                                             (line   17)
* Packed Decimal:                        Interfaces Packed_Decimal i-pacdec ads.
                                                             (line    6)
* Packed types:                          RM 13 1 21-24 Representation Clauses.
                                                             (line   38)
* Parameters:                            Attribute Mechanism_Code.
                                                             (line    6)
* Parameters <1>:                        Attribute Passed_By_Reference.
                                                             (line    6)
* Parsing:                               GNAT AWK g-awk ads. (line    6)
* Parsing <1>:                           GNAT Bounded_Buffers g-boubuf ads.
                                                             (line    6)
* Parsing <2>:                           GNAT Bounded_Mailboxes g-boumai ads.
                                                             (line    6)
* Partition communication subsystem:     RM D 8 47-49 Monotonic Time.
                                                             (line   23)
* Partition interfacing functions:       System Partition_Interface s-parint ads.
                                                             (line    6)
* Part_Of:                               Aspect Part_Of.     (line    6)
* Passed_By_Reference:                   Attribute Passed_By_Reference.
                                                             (line    6)
* passing:                               Attribute Null_Parameter.
                                                             (line    6)
* Passing by copy:                       Pragma C_Pass_By_Copy.
                                                             (line    6)
* passing mechanism:                     Attribute Mechanism_Code.
                                                             (line    6)
* passing mechanism <1>:                 Attribute Mechanism_Code.
                                                             (line    6)
* Pattern matching:                      GNAT Regexp g-regexp ads.
                                                             (line    6)
* Pattern matching <1>:                  GNAT Regpat g-regpat ads.
                                                             (line    6)
* Pattern matching <2>:                  GNAT Spitbol Patterns g-spipat ads.
                                                             (line    6)
* PCS:                                   RM D 8 47-49 Monotonic Time.
                                                             (line   22)
* Persistent_BSS:                        Aspect Persistent_BSS.
                                                             (line    6)
* Pool_Address:                          Attribute Pool_Address.
                                                             (line    6)
* Portability:                           About This Guide.   (line   24)
* Post:                                  Pragma Post.        (line    6)
* Post <1>:                              Pragma Post_Class.  (line    6)
* Postcondition:                         Pragma Postcondition.
                                                             (line    6)
* postconditions:                        Pragma Post.        (line    6)
* postconditions <1>:                    Pragma Postcondition.
                                                             (line    6)
* postconditions <2>:                    Pragma Post_Class.  (line    6)
* Pragma:                                Representation Clauses and Pragmas.
                                                             (line    6)
* pragma Ada_2012:                       Implementation of Ada 2012 Features.
                                                             (line    6)
* Pragma Component_Alignment:            Pragma Component_Alignment.
                                                             (line    6)
* Pragma Pack (for arrays):              Pragma Pack for Arrays.
                                                             (line    6)
* Pragma Pack (for records):             Pragma Pack for Records.
                                                             (line    6)
* Pragma Pack (for type Natural):        Pragma Pack for Arrays.
                                                             (line   79)
* Pragma Pack warning:                   Pragma Pack for Arrays.
                                                             (line   79)
* pragma Shared_Passive:                 GNAT Implementation of Shared Passive Packages.
                                                             (line    6)
* Pragmas:                               Pragma Rename_Pragma.
                                                             (line    6)
* Pragmas <1>:                           RM 1 1 5 12 Bounded Errors.
                                                             (line   12)
* Pre:                                   Pragma Pre.         (line    6)
* Pre-elaboration requirements:          RM C 3 2 25 Package Interrupts.
                                                             (line   14)
* preconditions:                         Pragma Pre.         (line    6)
* Preconditions:                         Pragma Precondition.
                                                             (line    6)
* preconditions <1>:                     Pragma Precondition.
                                                             (line    6)
* preconditions <2>:                     Pragma Pre_Class.   (line    6)
* Predicate:                             Aspect Predicate.   (line    6)
* Preemptive abort:                      RM D 4 16 Entry Queuing Policies.
                                                             (line   10)
* Prefix_Exception_Messages:             Pragma Prefix_Exception_Messages.
                                                             (line    6)
* Pre_Class:                             Pragma Pre_Class.   (line    6)
* Protected procedure handlers:          RM C 3 28 Interrupt Support.
                                                             (line   14)
* Pure:                                  GNAT Exceptions g-except ads.
                                                             (line    6)
* Pure packages:                         GNAT Exceptions g-except ads.
                                                             (line    6)
* Pure_Barriers:                         Pure_Barriers.      (line    6)
* Pure_Function:                         Aspect Pure_Function.
                                                             (line    6)
* Random number generation:              RM A 4 4 106 Bounded-Length String Handling.
                                                             (line   10)
* Random number generation <1>:          GNAT MBBS_Discrete_Random g-mbdira ads.
                                                             (line    6)
* Random number generation <2>:          GNAT MBBS_Float_Random g-mbflra ads.
                                                             (line    6)
* Random number generation <3>:          GNAT Random_Numbers g-rannum ads.
                                                             (line    6)
* Range_Length:                          Attribute Range_Length.
                                                             (line    6)
* Rational compatibility:                Pragma Overriding_Renamings.
                                                             (line    6)
* Rational Profile:                      Pragma Implicit_Packing.
                                                             (line    6)
* Rational profile:                      Pragma Overriding_Renamings.
                                                             (line    6)
* Rational profile <1>:                  Pragma Use_VADS_Size.
                                                             (line    6)
* Read attribute:                        RM 13 13 2 1 6 Stream Oriented Attributes.
                                                             (line   22)
* Real-Time Systems Annex compliance:    Ensuring Compliance with the Real-Time Annex.
                                                             (line    6)
* Record Representation Clause:          Record Representation Clauses.
                                                             (line    6)
* Record representation clauses:         RM 13 4 9-10 Enumeration Representation Clauses.
                                                             (line   15)
* records:                               RM 13 4 9-10 Enumeration Representation Clauses.
                                                             (line   14)
* Refined_Depends:                       Aspect Refined_Depends.
                                                             (line    6)
* Refined_Global:                        Aspect Refined_Global.
                                                             (line    6)
* Refined_Initialization:                Aspect Relaxed_Initialization.
                                                             (line    6)
* Refined_Post:                          Aspect Refined_Post.
                                                             (line    6)
* Refined_State:                         Aspect Refined_State.
                                                             (line    6)
* Regular expressions:                   GNAT Regexp g-regexp ads.
                                                             (line    6)
* Regular expressions <1>:               GNAT Regpat g-regpat ads.
                                                             (line    6)
* Remote_Access_Type:                    Aspect Remote_Access_Type.
                                                             (line    6)
* Removing command line arguments:       Ada Command_Line Remove a-colire ads.
                                                             (line    6)
* representation:                        Representation Clauses and Pragmas.
                                                             (line    6)
* Representation:                        Determining the Representations chosen by GNAT.
                                                             (line    6)
* Representation <1>:                    System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* Representation Clause:                 Representation Clauses and Pragmas.
                                                             (line    6)
* Representation clauses:                RM 11 5 28 Suppression of Checks.
                                                             (line   10)
* Representation clauses <1>:            RM 13 3 71-73 Component Size Clauses.
                                                             (line   24)
* Representation clauses <2>:            RM 13 4 9-10 Enumeration Representation Clauses.
                                                             (line   15)
* Representation Clauses:                Representation Clauses and Pragmas.
                                                             (line    6)
* representation of:                     Attribute Universal_Literal_String.
                                                             (line    6)
* Representation of enums:               Attribute Enum_Rep. (line    6)
* Representation of enums <1>:           Attribute Enum_Val. (line    6)
* Representation of wide characters:     System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* Representation Pragma:                 Representation Clauses and Pragmas.
                                                             (line    6)
* response file:                         Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Response file for command line:        Ada Command_Line Response_File a-clrefi ads.
                                                             (line    6)
* Restrictions:                          Attribute Restriction_Set.
                                                             (line    6)
* Restrictions definitions:              System Rident s-rident ads.
                                                             (line    6)
* Restriction_Set:                       Attribute Restriction_Set.
                                                             (line    6)
* Result:                                Attribute Result.   (line    6)
* Return values:                         Attribute Mechanism_Code.
                                                             (line    6)
* Rewrite data:                          GNAT Rewrite_Data g-rewdat ads.
                                                             (line    6)
* Rotate_Left:                           Shifts and Rotates. (line    6)
* Rotate_Right:                          Shifts and Rotates. (line    6)
* Run-time restrictions access:          System Restrictions s-restri ads.
                                                             (line    6)
* Safe_Emax:                             Attribute Safe_Emax.
                                                             (line    6)
* Safe_Large:                            Attribute Safe_Large.
                                                             (line    6)
* Safe_Small:                            Attribute Safe_Small.
                                                             (line    6)
* Scalar storage order:                  Attribute Scalar_Storage_Order.
                                                             (line    6)
* Scalar_Storage_Order:                  Pragma Default_Scalar_Storage_Order.
                                                             (line    6)
* Scalar_Storage_Order <1>:              Aspect Scalar_Storage_Order.
                                                             (line    6)
* Scalar_Storage_Order <2>:              Attribute Scalar_Storage_Order.
                                                             (line    6)
* Secondary Stack Info:                  GNAT Secondary_Stack_Info g-sestin ads.
                                                             (line    6)
* Secondary_Stack_Size:                  Aspect Secondary_Stack_Size.
                                                             (line    6)
* Secure Hash Algorithm SHA-1:           GNAT SHA1 g-sha1 ads.
                                                             (line    6)
* Secure Hash Algorithm SHA-224:         GNAT SHA224 g-sha224 ads.
                                                             (line    6)
* Secure Hash Algorithm SHA-256:         GNAT SHA256 g-sha256 ads.
                                                             (line    6)
* Secure Hash Algorithm SHA-384:         GNAT SHA384 g-sha384 ads.
                                                             (line    6)
* Secure Hash Algorithm SHA-512:         GNAT SHA512 g-sha512 ads.
                                                             (line    6)
* Semaphores:                            GNAT Semaphores g-semaph ads.
                                                             (line    6)
* Sequential elaboration policy:         RM G 2 6 15 Complex Arithmetic Accuracy.
                                                             (line   13)
* Serial_Communications:                 GNAT Serial_Communications g-sercom ads.
                                                             (line    6)
* Sets of strings:                       GNAT Spitbol Table_Boolean g-sptabo ads.
                                                             (line    6)
* setting for not-first subtype:         Attribute Value_Size.
                                                             (line    6)
* Shared:                                Aspect Shared.      (line    6)
* Shared passive packages:               GNAT Implementation of Shared Passive Packages.
                                                             (line    6)
* SHARED_MEMORY_DIRECTORY environment variable: GNAT Implementation of Shared Passive Packages.
                                                             (line   35)
* Shift operators:                       Pragma Provide_Shift_Operators.
                                                             (line    6)
* Shift_Left:                            Shifts and Rotates. (line    6)
* Shift_Right:                           Shifts and Rotates. (line    6)
* Shift_Right_Arithmetic:                Shifts and Rotates. (line    6)
* Signals:                               GNAT Signals g-signal ads.
                                                             (line    6)
* simple:                                Pragma Simple_Storage_Pool_Type.
                                                             (line    6)
* simple <1>:                            Attribute Simple_Storage_Pool.
                                                             (line    6)
* Simple I/O:                            GNAT IO g-io ads.   (line    6)
* Simple storage pool:                   Pragma Simple_Storage_Pool_Type.
                                                             (line    6)
* Simple storage pool <1>:               Attribute Simple_Storage_Pool.
                                                             (line    6)
* Simple_Barriers:                       Simple_Barriers.    (line    6)
* Simple_Storage_Pool:                   Aspect Simple_Storage_Pool.
                                                             (line    6)
* Simple_Storage_Pool <1>:               Attribute Simple_Storage_Pool.
                                                             (line    6)
* Simple_Storage_Pool_Type:              Aspect Simple_Storage_Pool_Type.
                                                             (line    6)
* Size:                                  Pragma Use_VADS_Size.
                                                             (line    6)
* Size <1>:                              Attribute Object_Size.
                                                             (line    6)
* Size <2>:                              Attribute VADS_Size.
                                                             (line    6)
* Size <3>:                              Attribute Value_Size.
                                                             (line    6)
* Size <4>:                              Size of Variant Record Objects.
                                                             (line    6)
* size:                                  Size of Variant Record Objects.
                                                             (line    6)
* Size <5>:                              Value_Size and Object_Size Clauses.
                                                             (line    6)
* Size Clause:                           Size Clauses.       (line    6)
* Size clauses:                          RM 13 3 29-35 Alignment Clauses.
                                                             (line   40)
* Size for biased representation:        Biased Representation.
                                                             (line    6)
* Size of ‘‘Address‘‘:                   Attribute Address_Size.
                                                             (line    6)
* Small:                                 Attribute Small.    (line    6)
* Small <1>:                             Attribute Small_Denominator.
                                                             (line    6)
* Small <2>:                             Attribute Small_Numerator.
                                                             (line    6)
* Small_Denominator:                     Attribute Small_Denominator.
                                                             (line    6)
* Small_Numerator:                       Attribute Small_Numerator.
                                                             (line    6)
* Sockets:                               GNAT Sockets g-socket ads.
                                                             (line    6)
* Sorting:                               GNAT Bubble_Sort g-bubsor ads.
                                                             (line    6)
* Sorting <1>:                           GNAT Bubble_Sort_A g-busora ads.
                                                             (line    6)
* Sorting <2>:                           GNAT Bubble_Sort_G g-busorg ads.
                                                             (line    6)
* Sorting <3>:                           GNAT Heap_Sort g-heasor ads.
                                                             (line    6)
* Sorting <4>:                           GNAT Heap_Sort_A g-hesora ads.
                                                             (line    6)
* Sorting <5>:                           GNAT Heap_Sort_G g-hesorg ads.
                                                             (line    6)
* Source Information:                    GNAT Source_Info g-souinf ads.
                                                             (line    6)
* Source_Location:                       Source_Location.    (line    6)
* SPARK_05:                              SPARK_05.           (line    6)
* SPARK_Mode:                            Aspect SPARK_Mode.  (line    6)
* Spawn capability:                      GNAT OS_Lib g-os_lib ads.
                                                             (line    6)
* Spell checking:                        GNAT Spelling_Checker g-speche ads.
                                                             (line    6)
* Spell checking <1>:                    GNAT Spelling_Checker_Generic g-spchge ads.
                                                             (line    6)
* Spell checking <2>:                    GNAT Wide_Spelling_Checker g-u3spch ads.
                                                             (line    6)
* Spell checking <3>:                    GNAT Wide_Spelling_Checker g-wispch ads.
                                                             (line    6)
* Spell checking <4>:                    GNAT Wide_Wide_Spelling_Checker g-zspche ads.
                                                             (line    6)
* SPITBOL interface:                     GNAT Spitbol g-spitbo ads.
                                                             (line    6)
* SPITBOL pattern matching:              GNAT Spitbol Patterns g-spipat ads.
                                                             (line    6)
* SPITBOL Tables:                        GNAT Spitbol Table_Boolean g-sptabo ads.
                                                             (line    6)
* SPITBOL Tables <1>:                    GNAT Spitbol Table_Integer g-sptain ads.
                                                             (line    6)
* SPITBOL Tables <2>:                    GNAT Spitbol Table_VString g-sptavs ads.
                                                             (line    6)
* Static_Dispatch_Tables:                Static_Dispatch_Tables.
                                                             (line    6)
* Static_Priorities:                     Static_Priorities.  (line    6)
* Static_Storage_Size:                   Static_Storage_Size.
                                                             (line    6)
* Storage place attributes:              RM 13 5 1 17-22 Record Representation Clauses.
                                                             (line   44)
* Storage pool:                          Pragma Simple_Storage_Pool_Type.
                                                             (line    6)
* Storage pool <1>:                      Attribute Simple_Storage_Pool.
                                                             (line    6)
* Storage pool <2>:                      System Pool_Global s-pooglo ads.
                                                             (line    6)
* Storage pool <3>:                      System Pool_Local s-pooloc ads.
                                                             (line    6)
* Storage_Size Clause:                   Storage_Size Clauses.
                                                             (line    6)
* Storage_Unit:                          Attribute Storage_Unit.
                                                             (line    6)
* Storage_Unit (in pragma Component_Alignment): Pragma Component_Alignment.
                                                             (line   37)
* Stream files:                          Treating Text_IO Files as Streams.
                                                             (line    6)
* Stream operations:                     System Strings Stream_Ops s-ststop ads.
                                                             (line    6)
* Stream oriented attributes:            RM 13 11 2 17 Unchecked Deallocation.
                                                             (line   10)
* Stream oriented attributes <1>:        RM 13 13 2 1 6 Stream Oriented Attributes.
                                                             (line   21)
* String decoding:                       GNAT Decode_String g-decstr ads.
                                                             (line    6)
* String encoding:                       GNAT Encode_String g-encstr ads.
                                                             (line    6)
* String maps:                           GNAT Spitbol Table_VString g-sptavs ads.
                                                             (line    6)
* String splitter:                       GNAT String_Split g-strspl ads.
                                                             (line    6)
* String stream operations:              System Strings Stream_Ops s-ststop ads.
                                                             (line    6)
* Stub_Type:                             Attribute Stub_Type.
                                                             (line    6)
* Subprogram address:                    Attribute Code_Address.
                                                             (line    6)
* subtypes:                              Alignment Clauses.  (line   87)
* Suppressing external name:             Pragma Export_Function.
                                                             (line   59)
* Suppressing external name <1>:         Pragma Export_Procedure.
                                                             (line   44)
* Suppressing external name <2>:         Pragma Export_Valued_Procedure.
                                                             (line   49)
* Suppressing initialization:            Pragma Suppress_Initialization.
                                                             (line    6)
* suppression of:                        Pragma Suppress_Initialization.
                                                             (line    6)
* suppression of <1>:                    RM 11 4 1 19 Exception Information.
                                                             (line   22)
* Suppression of checks:                 RM 11 4 1 19 Exception Information.
                                                             (line   23)
* Suppress_Debug_Info:                   Aspect Suppress_Debug_Info.
                                                             (line    6)
* Suppress_Initialization:               Aspect Suppress_Initialization.
                                                             (line    6)
* synonyms:                              Pragma Convention_Identifier.
                                                             (line    6)
* synonyms <1>:                          Pragma Rename_Pragma.
                                                             (line    6)
* System:                                Pragma Extend_System.
                                                             (line    6)
* System.Address_Image (s-addima.ads):   System Address_Image s-addima ads.
                                                             (line    6)
* System.Assertions (s-assert.ads):      System Assertions s-assert ads.
                                                             (line    6)
* System.Atomic_Counters (s-atocou.ads): System Atomic_Counters s-atocou ads.
                                                             (line    6)
* System.Memory (s-memory.ads):          System Memory s-memory ads.
                                                             (line    6)
* System.Multiprocessors (s-multip.ads): System Multiprocessors s-multip ads.
                                                             (line    6)
* System.Multiprocessors.Dispatching_Domains (s-mudido.ads): System Multiprocessors Dispatching_Domains s-mudido ads.
                                                             (line    6)
* System.Partition_Interface (s-parint.ads): System Partition_Interface s-parint ads.
                                                             (line    6)
* System.Pool_Global (s-pooglo.ads):     System Pool_Global s-pooglo ads.
                                                             (line    6)
* System.Pool_Local (s-pooloc.ads):      System Pool_Local s-pooloc ads.
                                                             (line    6)
* System.Restrictions (s-restri.ads):    System Restrictions s-restri ads.
                                                             (line    6)
* System.Rident (s-rident.ads):          System Rident s-rident ads.
                                                             (line    6)
* System.Strings.Stream_Ops (s-ststop.ads): System Strings Stream_Ops s-ststop ads.
                                                             (line    6)
* System.Unsigned_Types (s-unstyp.ads):  System Unsigned_Types s-unstyp ads.
                                                             (line    6)
* System.Wch_Cnv (s-wchcnv.ads):         System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* System.Wch_Con (s-wchcon.ads):         System Wch_Con s-wchcon ads.
                                                             (line    6)
* System_Allocator_Alignment:            Attribute System_Allocator_Alignment.
                                                             (line    6)
* Table implementation:                  GNAT Dynamic_Tables g-dyntab ads.
                                                             (line    6)
* Table implementation <1>:              GNAT Table g-table ads.
                                                             (line    6)
* Tagged values:                         Attribute Has_Tagged_Values.
                                                             (line    6)
* Target_Name:                           Attribute Target_Name.
                                                             (line    6)
* Task locking:                          GNAT Task_Lock g-tasloc ads.
                                                             (line    6)
* Task specific storage:                 Pragma Thread_Local_Storage.
                                                             (line    6)
* Task synchronization:                  GNAT Task_Lock g-tasloc ads.
                                                             (line    6)
* Tasking restrictions:                  RM D 6 9-10 Preemptive Abort.
                                                             (line   18)
* Task_Attributes:                       Pragma Thread_Local_Storage.
                                                             (line    6)
* Task_Attributes <1>:                   RM C 5 8 Pragma Discard_Names.
                                                             (line   11)
* Test cases:                            Pragma Test_Case.   (line    6)
* testing for:                           Attribute Has_Access_Values.
                                                             (line    6)
* testing for <1>:                       Attribute Has_Discriminants.
                                                             (line    6)
* testing for <2>:                       Attribute Has_Tagged_Values.
                                                             (line    6)
* testing for <3>:                       Ada Exceptions Is_Null_Occurrence a-einuoc ads.
                                                             (line    6)
* testing for <4>:                       Ada Exceptions Last_Chance_Handler a-elchha ads.
                                                             (line    6)
* Test_Case:                             Aspect Test_Case.   (line    6)
* Text_IO:                               Ada Strings Unbounded Text_IO a-suteio ads.
                                                             (line    6)
* Text_IO <1>:                           Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
                                                             (line    6)
* Text_IO <2>:                           Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
                                                             (line    6)
* Text_IO <3>:                           GNAT IO_Aux g-io_aux ads.
                                                             (line    6)
* Text_IO extensions:                    Text_IO Extensions. (line    6)
* Text_IO for unbounded strings:         Text_IO Facilities for Unbounded Strings.
                                                             (line    6)
* Text_IO operations:                    Text_IO Facilities for Unbounded Strings.
                                                             (line    6)
* Text_IO resetting standard files:      Ada Text_IO Reset_Standard_Files a-tirsfi ads.
                                                             (line    6)
* Threads:                               GNAT Threads g-thread ads.
                                                             (line    6)
* Thread_Local_Storage:                  Aspect Thread_Local_Storage.
                                                             (line    6)
* Time:                                  RM D 7 21 Tasking Restrictions.
                                                             (line   14)
* Time <1>:                              GNAT Calendar Time_IO g-catiio ads.
                                                             (line    6)
* Time stamp:                            GNAT Time_Stamp g-timsta ads.
                                                             (line    6)
* TLS (Thread Local Storage):            Pragma Thread_Local_Storage.
                                                             (line    6)
* To_Address:                            Attribute To_Address.
                                                             (line    6)
* To_Address <1>:                        Address Clauses.    (line   73)
* To_Any:                                Attribute To_Any.   (line    6)
* Trace back facilities:                 GNAT Traceback g-traceb ads.
                                                             (line    6)
* Trace back facilities <1>:             GNAT Traceback Symbolic g-trasym ads.
                                                             (line    5)
* Traceback for Exception Occurrence:    Ada Exceptions Traceback a-exctra ads.
                                                             (line    6)
* trampoline:                            No_Implicit_Dynamic_Code.
                                                             (line    6)
* TypeCode:                              Attribute TypeCode. (line    6)
* Type_Class:                            Attribute Type_Class.
                                                             (line    6)
* Type_Key:                              Attribute Type_Key. (line    6)
* typographical:                         Conventions.        (line    6)
* Typographical conventions:             Conventions.        (line    6)
* Unbounded_String:                      Text_IO Facilities for Unbounded Strings.
                                                             (line    6)
* Unbounded_String <1>:                  Ada Strings Unbounded Text_IO a-suteio ads.
                                                             (line    6)
* Unbounded_Wide_String:                 Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads.
                                                             (line    6)
* Unbounded_Wide_Wide_String:            Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads.
                                                             (line    6)
* Unchecked conversion:                  RM 13 7 1 16 Address Operations.
                                                             (line   14)
* Unchecked deallocation:                RM 13 11 23-25 Implicit Heap Usage.
                                                             (line   32)
* Unconstrained_Array:                   Attribute Unconstrained_Array.
                                                             (line    6)
* Unevaluated_Use_Of_Old:                Pragma Unevaluated_Use_Of_Old.
                                                             (line    6)
* Unicode:                               GNAT Decode_String g-decstr ads.
                                                             (line    6)
* Unicode <1>:                           GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* Unicode <2>:                           GNAT Encode_String g-encstr ads.
                                                             (line    6)
* Unicode <3>:                           GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* Unicode categorization:                Ada Wide_Characters Unicode a-wichun ads.
                                                             (line    6)
* Unicode categorization <1>:            Ada Wide_Wide_Characters Unicode a-zchuni ads.
                                                             (line    6)
* Unions in C:                           Pragma Unchecked_Union.
                                                             (line    6)
* Universal_Aliasing:                    Aspect Universal_Aliasing.
                                                             (line    6)
* Universal_Literal_String:              Attribute Universal_Literal_String.
                                                             (line    6)
* unmodified:                            Pragma Unmodified.  (line    6)
* Unmodified:                            Aspect Unmodified.  (line    6)
* unreferenced:                          Pragma Unreferenced.
                                                             (line    6)
* unreferenced <1>:                      Pragma Unreferenced_Objects.
                                                             (line    6)
* Unreferenced:                          Aspect Unreferenced.
                                                             (line    6)
* Unreferenced_Objects:                  Aspect Unreferenced_Objects.
                                                             (line    6)
* unrestricted:                          Attribute Unrestricted_Access.
                                                             (line    6)
* Unrestricted_Access:                   Attribute Unrestricted_Access.
                                                             (line    6)
* unused:                                Pragma Unused.      (line    6)
* Update:                                Attribute Update.   (line    6)
* used for objects:                      Attribute Object_Size.
                                                             (line    6)
* UTF-8:                                 GNAT Decode_String g-decstr ads.
                                                             (line    6)
* UTF-8 <1>:                             GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* UTF-8 <2>:                             GNAT Encode_String g-encstr ads.
                                                             (line    6)
* UTF-8 <3>:                             GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* UTF-8 representation:                  GNAT Byte_Order_Mark g-byorma ads.
                                                             (line    6)
* UTF-8 string decoding:                 GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* UTF-8 string encoding:                 GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* VADS compatibility:                    Pragma Use_VADS_Size.
                                                             (line    6)
* VADS compatibility <1>:                Attribute VADS_Size.
                                                             (line    6)
* VADS_Size:                             Attribute VADS_Size.
                                                             (line    6)
* Valid_Image:                           Attribute Valid_Image.
                                                             (line    6)
* Valid_Scalars:                         Attribute Valid_Scalars.
                                                             (line    6)
* Value_Size:                            Aspect Value_Size.  (line    6)
* Value_Size <1>:                        Attribute Value_Size.
                                                             (line    6)
* Value_Size <2>:                        Value_Size and Object_Size Clauses.
                                                             (line    6)
* variant record objects:                Size of Variant Record Objects.
                                                             (line    6)
* Variant record objects:                Size of Variant Record Objects.
                                                             (line    6)
* Version:                               GNAT Compiler_Version g-comver ads.
                                                             (line    6)
* Volatile_Full_Access:                  Aspect Volatile_Full_Access.
                                                             (line    6)
* Volatile_Function:                     Aspect Volatile_Function.
                                                             (line    6)
* VxWorks:                               Interfaces VxWorks i-vxwork ads.
                                                             (line    6)
* VxWorks <1>:                           Interfaces VxWorks Int_Connection i-vxinco ads.
                                                             (line    6)
* VxWorks <2>:                           Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* VxWorks <3>:                           Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* VxWorks <4>:                           Interfaces VxWorks IO i-vxwoio ads.
                                                             (line    6)
* Warnings:                              Pragma Unmodified.  (line    6)
* Warnings <1>:                          Pragma Unreferenced.
                                                             (line    6)
* Warnings <2>:                          Pragma Unreferenced_Objects.
                                                             (line    6)
* Warnings <3>:                          Pragma Unused.      (line    6)
* Warnings <4>:                          Aspect Warnings.    (line    6)
* Wchar_T_Size:                          Attribute Wchar_T_Size.
                                                             (line    6)
* when passed by reference:              Attribute Passed_By_Reference.
                                                             (line    6)
* Wide characte representations:         GNAT Byte_Order_Mark g-byorma ads.
                                                             (line    6)
* Wide Character:                        System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* Wide character codes:                  GNAT UTF_32 g-table ads.
                                                             (line    6)
* Wide character decoding:               GNAT Decode_UTF8_String g-deutst ads.
                                                             (line    6)
* Wide character encoding:               GNAT Decode_String g-decstr ads.
                                                             (line    6)
* Wide character encoding <1>:           GNAT Encode_String g-encstr ads.
                                                             (line    6)
* Wide character encoding <2>:           GNAT Encode_UTF8_String g-enutst ads.
                                                             (line    6)
* Wide String:                           System Wch_Cnv s-wchcnv ads.
                                                             (line    6)
* Wide_Character:                        Ada Wide_Characters Unicode a-wichun ads.
                                                             (line    6)
* Wide_String splitter:                  GNAT Wide_String_Split g-wistsp ads.
                                                             (line    6)
* Wide_Text_IO resetting standard files: Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads.
                                                             (line    6)
* Wide_Wide_Character:                   Ada Wide_Wide_Characters Unicode a-zchuni ads.
                                                             (line    6)
* Wide_Wide_String splitter:             GNAT Wide_Wide_String_Split g-zistsp ads.
                                                             (line    6)
* Wide_Wide_Text_IO resetting standard files: Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads.
                                                             (line    6)
* Windows Registry:                      GNAT Registry g-regist ads.
                                                             (line    6)
* Word_Size:                             Attribute Word_Size.
                                                             (line    6)
* Write attribute:                       RM 13 13 2 1 6 Stream Oriented Attributes.
                                                             (line   22)
* XDR representation:                    RM 13 13 2 1 6 Stream Oriented Attributes.
                                                             (line   22)
* Zero address:                          Attribute Null_Parameter.
                                                             (line    6)



Tag Table:
Node: Top326
Ref: gnat_rm doc554
Ref: 0554
Node: About This Guide33904
Ref: gnat_rm/about_this_guide doc34012
Ref: 234012
Ref: gnat_rm/about_this_guide about-this-guide34012
Ref: 334012
Ref: gnat_rm/about_this_guide gnat-reference-manual34012
Ref: 434012
Ref: gnat_rm/about_this_guide id134012
Ref: 534012
Node: What This Reference Manual Contains35402
Ref: gnat_rm/about_this_guide what-this-reference-manual-contains35511
Ref: 635511
Node: Conventions39184
Ref: gnat_rm/about_this_guide conventions39321
Ref: 1839321
Node: Related Information39888
Ref: gnat_rm/about_this_guide related-information39981
Ref: 1939981
Node: Implementation Defined Pragmas41275
Ref: gnat_rm/implementation_defined_pragmas doc41410
Ref: 1a41410
Ref: gnat_rm/implementation_defined_pragmas id141410
Ref: 1b41410
Ref: gnat_rm/implementation_defined_pragmas implementation-defined-pragmas41410
Ref: 741410
Node: Pragma Abort_Defer47582
Ref: gnat_rm/implementation_defined_pragmas pragma-abort-defer47698
Ref: 1c47698
Node: Pragma Abstract_State48569
Ref: gnat_rm/implementation_defined_pragmas id248707
Ref: 1d48707
Ref: gnat_rm/implementation_defined_pragmas pragma-abstract-state48707
Ref: 1e48707
Node: Pragma Ada_8349910
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-8350043
Ref: 1f50043
Node: Pragma Ada_9551134
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-9551259
Ref: 2051259
Node: Pragma Ada_0551777
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-0551904
Ref: 2151904
Node: Pragma Ada_200552930
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-200553057
Ref: 2253057
Node: Pragma Ada_1253224
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-1253353
Ref: 2353353
Node: Pragma Ada_201254528
Ref: gnat_rm/implementation_defined_pragmas pragma-ada-201254678
Ref: 2454678
Node: Pragma Aggregate_Individually_Assign54845
Ref: gnat_rm/implementation_defined_pragmas pragma-aggregate-individually-assign55010
Ref: 2555010
Node: Pragma Allow_Integer_Address55415
Ref: gnat_rm/implementation_defined_pragmas pragma-allow-integer-address55580
Ref: 2655580
Node: Pragma Annotate57193
Ref: gnat_rm/implementation_defined_pragmas id357335
Ref: 2757335
Ref: gnat_rm/implementation_defined_pragmas pragma-annotate57335
Ref: 2857335
Node: Pragma Assert58783
Ref: gnat_rm/implementation_defined_pragmas pragma-assert58918
Ref: 2958918
Node: Pragma Assert_And_Cut61424
Ref: gnat_rm/implementation_defined_pragmas pragma-assert-and-cut61567
Ref: 2a61567
Node: Pragma Assertion_Policy62379
Ref: gnat_rm/implementation_defined_pragmas pragma-assertion-policy62522
Ref: 2b62522
Node: Pragma Assume66253
Ref: gnat_rm/implementation_defined_pragmas pragma-assume66406
Ref: 2c66406
Node: Pragma Assume_No_Invalid_Values67385
Ref: gnat_rm/implementation_defined_pragmas pragma-assume-no-invalid-values67535
Ref: 2d67535
Node: Pragma Async_Readers69318
Ref: gnat_rm/implementation_defined_pragmas id469475
Ref: 2e69475
Ref: gnat_rm/implementation_defined_pragmas pragma-async-readers69475
Ref: 2f69475
Node: Pragma Async_Writers69721
Ref: gnat_rm/implementation_defined_pragmas id569874
Ref: 3069874
Ref: gnat_rm/implementation_defined_pragmas pragma-async-writers69874
Ref: 3169874
Node: Pragma Attribute_Definition70120
Ref: gnat_rm/implementation_defined_pragmas pragma-attribute-definition70274
Ref: 3270274
Node: Pragma C_Pass_By_Copy70901
Ref: gnat_rm/implementation_defined_pragmas pragma-c-pass-by-copy71047
Ref: 3371047
Node: Pragma Check72229
Ref: gnat_rm/implementation_defined_pragmas pragma-check72375
Ref: 3472375
Node: Pragma Check_Float_Overflow73629
Ref: gnat_rm/implementation_defined_pragmas pragma-check-float-overflow73771
Ref: 3573771
Node: Pragma Check_Name75822
Ref: gnat_rm/implementation_defined_pragmas pragma-check-name75971
Ref: 3675971
Node: Pragma Check_Policy77091
Ref: gnat_rm/implementation_defined_pragmas pragma-check-policy77227
Ref: 3777227
Node: Pragma Comment80040
Ref: gnat_rm/implementation_defined_pragmas pragma-comment80179
Ref: 3880179
Node: Pragma Common_Object80697
Ref: gnat_rm/implementation_defined_pragmas pragma-common-object80842
Ref: 3980842
Node: Pragma Compile_Time_Error81725
Ref: gnat_rm/implementation_defined_pragmas compile-time-error81883
Ref: 3a81883
Ref: gnat_rm/implementation_defined_pragmas pragma-compile-time-error81883
Ref: 3b81883
Node: Pragma Compile_Time_Warning82953
Ref: gnat_rm/implementation_defined_pragmas pragma-compile-time-warning83121
Ref: 3c83121
Node: Pragma Complete_Representation84354
Ref: gnat_rm/implementation_defined_pragmas pragma-complete-representation84526
Ref: 3d84526
Node: Pragma Complex_Representation85075
Ref: gnat_rm/implementation_defined_pragmas pragma-complex-representation85246
Ref: 3e85246
Node: Pragma Component_Alignment86002
Ref: gnat_rm/implementation_defined_pragmas pragma-component-alignment86176
Ref: 3f86176
Node: Pragma Constant_After_Elaboration88894
Ref: gnat_rm/implementation_defined_pragmas id689060
Ref: 4089060
Ref: gnat_rm/implementation_defined_pragmas pragma-constant-after-elaboration89060
Ref: 4189060
Node: Pragma Contract_Cases89358
Ref: gnat_rm/implementation_defined_pragmas id789526
Ref: 4289526
Ref: gnat_rm/implementation_defined_pragmas pragma-contract-cases89526
Ref: 4389526
Node: Pragma Convention_Identifier92362
Ref: gnat_rm/implementation_defined_pragmas pragma-convention-identifier92513
Ref: 4492513
Node: Pragma CPP_Class93697
Ref: gnat_rm/implementation_defined_pragmas pragma-cpp-class93849
Ref: 4593849
Node: Pragma CPP_Constructor94963
Ref: gnat_rm/implementation_defined_pragmas pragma-cpp-constructor95105
Ref: 4795105
Node: Pragma CPP_Virtual97033
Ref: gnat_rm/implementation_defined_pragmas pragma-cpp-virtual97176
Ref: 4897176
Node: Pragma CPP_Vtable97647
Ref: gnat_rm/implementation_defined_pragmas pragma-cpp-vtable97778
Ref: 4997778
Node: Pragma CPU98202
Ref: gnat_rm/implementation_defined_pragmas pragma-cpu98336
Ref: 4a98336
Node: Pragma Deadline_Floor98576
Ref: gnat_rm/implementation_defined_pragmas pragma-deadline-floor98725
Ref: 4b98725
Node: Pragma Default_Initial_Condition99041
Ref: gnat_rm/implementation_defined_pragmas id899192
Ref: 4c99192
Ref: gnat_rm/implementation_defined_pragmas pragma-default-initial-condition99192
Ref: 4d99192
Node: Pragma Debug99493
Ref: gnat_rm/implementation_defined_pragmas pragma-debug99642
Ref: 4e99642
Node: Pragma Debug_Policy100594
Ref: gnat_rm/implementation_defined_pragmas pragma-debug-policy100746
Ref: 4f100746
Node: Pragma Default_Scalar_Storage_Order101035
Ref: gnat_rm/implementation_defined_pragmas pragma-default-scalar-storage-order101202
Ref: 50101202
Node: Pragma Default_Storage_Pool103494
Ref: gnat_rm/implementation_defined_pragmas pragma-default-storage-pool103656
Ref: 51103656
Node: Pragma Depends103961
Ref: gnat_rm/implementation_defined_pragmas id9104110
Ref: 52104110
Ref: gnat_rm/implementation_defined_pragmas pragma-depends104110
Ref: 53104110
Node: Pragma Detect_Blocking104810
Ref: gnat_rm/implementation_defined_pragmas pragma-detect-blocking104969
Ref: 54104969
Node: Pragma Disable_Atomic_Synchronization105358
Ref: gnat_rm/implementation_defined_pragmas pragma-disable-atomic-synchronization105528
Ref: 55105528
Node: Pragma Dispatching_Domain106345
Ref: gnat_rm/implementation_defined_pragmas pragma-dispatching-domain106515
Ref: 56106515
Node: Pragma Effective_Reads106800
Ref: gnat_rm/implementation_defined_pragmas id10106956
Ref: 57106956
Ref: gnat_rm/implementation_defined_pragmas pragma-effective-reads106956
Ref: 58106956
Node: Pragma Effective_Writes107210
Ref: gnat_rm/implementation_defined_pragmas id11107366
Ref: 59107366
Ref: gnat_rm/implementation_defined_pragmas pragma-effective-writes107366
Ref: 5a107366
Node: Pragma Elaboration_Checks107624
Ref: gnat_rm/implementation_defined_pragmas pragma-elaboration-checks107774
Ref: 5b107774
Node: Pragma Eliminate108602
Ref: gnat_rm/implementation_defined_pragmas pragma-eliminate108765
Ref: 5c108765
Node: Pragma Enable_Atomic_Synchronization114487
Ref: gnat_rm/implementation_defined_pragmas pragma-enable-atomic-synchronization114647
Ref: 5d114647
Node: Pragma Export_Function115563
Ref: gnat_rm/implementation_defined_pragmas pragma-export-function115727
Ref: 5e115727
Node: Pragma Export_Object118183
Ref: gnat_rm/implementation_defined_pragmas pragma-export-object118334
Ref: 5f118334
Node: Pragma Export_Procedure119001
Ref: gnat_rm/implementation_defined_pragmas pragma-export-procedure119160
Ref: 60119160
Node: Pragma Export_Valued_Procedure120658
Ref: gnat_rm/implementation_defined_pragmas pragma-export-valued-procedure120817
Ref: 61120817
Node: Pragma Extend_System122670
Ref: gnat_rm/implementation_defined_pragmas pragma-extend-system122831
Ref: 62122831
Node: Pragma Extensions_Allowed124893
Ref: gnat_rm/implementation_defined_pragmas pragma-extensions-allowed125049
Ref: 63125049
Node: Pragma Extensions_Visible135709
Ref: gnat_rm/implementation_defined_pragmas id12135860
Ref: 64135860
Ref: gnat_rm/implementation_defined_pragmas pragma-extensions-visible135860
Ref: 65135860
Node: Pragma External136126
Ref: gnat_rm/implementation_defined_pragmas pragma-external136279
Ref: 66136279
Node: Pragma External_Name_Casing136846
Ref: gnat_rm/implementation_defined_pragmas pragma-external-name-casing136990
Ref: 67136990
Node: Pragma Fast_Math139998
Ref: gnat_rm/implementation_defined_pragmas pragma-fast-math140149
Ref: 68140149
Node: Pragma Favor_Top_Level141018
Ref: gnat_rm/implementation_defined_pragmas id13141170
Ref: 69141170
Ref: gnat_rm/implementation_defined_pragmas pragma-favor-top-level141170
Ref: 6a141170
Node: Pragma Finalize_Storage_Only141843
Ref: gnat_rm/implementation_defined_pragmas pragma-finalize-storage-only142006
Ref: 6b142006
Node: Pragma Float_Representation142768
Ref: gnat_rm/implementation_defined_pragmas pragma-float-representation142921
Ref: 6c142921
Node: Pragma Ghost143776
Ref: gnat_rm/implementation_defined_pragmas id14143914
Ref: 6d143914
Ref: gnat_rm/implementation_defined_pragmas pragma-ghost143914
Ref: 6e143914
Node: Pragma Global144126
Ref: gnat_rm/implementation_defined_pragmas id15144249
Ref: 6f144249
Ref: gnat_rm/implementation_defined_pragmas pragma-global144249
Ref: 70144249
Node: Pragma Ident144796
Ref: gnat_rm/implementation_defined_pragmas pragma-ident144927
Ref: 71144927
Node: Pragma Ignore_Pragma145163
Ref: gnat_rm/implementation_defined_pragmas pragma-ignore-pragma145310
Ref: 72145310
Node: Pragma Implementation_Defined145930
Ref: gnat_rm/implementation_defined_pragmas pragma-implementation-defined146083
Ref: 73146083
Node: Pragma Implemented146795
Ref: gnat_rm/implementation_defined_pragmas pragma-implemented146951
Ref: 74146951
Node: Pragma Implicit_Packing148570
Ref: gnat_rm/implementation_defined_pragmas pragma-implicit-packing148719
Ref: 75148719
Node: Pragma Import_Function150542
Ref: gnat_rm/implementation_defined_pragmas pragma-import-function150693
Ref: 76150693
Node: Pragma Import_Object152854
Ref: gnat_rm/implementation_defined_pragmas pragma-import-object153005
Ref: 77153005
Node: Pragma Import_Procedure153707
Ref: gnat_rm/implementation_defined_pragmas pragma-import-procedure153866
Ref: 78153866
Node: Pragma Import_Valued_Procedure154834
Ref: gnat_rm/implementation_defined_pragmas pragma-import-valued-procedure154991
Ref: 79154991
Node: Pragma Independent156804
Ref: gnat_rm/implementation_defined_pragmas pragma-independent156967
Ref: 7a156967
Node: Pragma Independent_Components157644
Ref: gnat_rm/implementation_defined_pragmas pragma-independent-components157801
Ref: 7b157801
Node: Pragma Initial_Condition158463
Ref: gnat_rm/implementation_defined_pragmas id16158627
Ref: 7c158627
Ref: gnat_rm/implementation_defined_pragmas pragma-initial-condition158627
Ref: 7d158627
Node: Pragma Initialize_Scalars158885
Ref: gnat_rm/implementation_defined_pragmas pragma-initialize-scalars159038
Ref: 7e159038
Node: Pragma Initializes162718
Ref: gnat_rm/implementation_defined_pragmas id17162867
Ref: 7f162867
Ref: gnat_rm/implementation_defined_pragmas pragma-initializes162867
Ref: 80162867
Node: Pragma Inline_Always163353
Ref: gnat_rm/implementation_defined_pragmas id18163498
Ref: 81163498
Ref: gnat_rm/implementation_defined_pragmas pragma-inline-always163498
Ref: 82163498
Node: Pragma Inline_Generic164130
Ref: gnat_rm/implementation_defined_pragmas pragma-inline-generic164273
Ref: 83164273
Node: Pragma Interface164655
Ref: gnat_rm/implementation_defined_pragmas pragma-interface164799
Ref: 84164799
Node: Pragma Interface_Name165771
Ref: gnat_rm/implementation_defined_pragmas pragma-interface-name165918
Ref: 85165918
Node: Pragma Interrupt_Handler166436
Ref: gnat_rm/implementation_defined_pragmas pragma-interrupt-handler166589
Ref: 86166589
Node: Pragma Interrupt_State166845
Ref: gnat_rm/implementation_defined_pragmas pragma-interrupt-state166993
Ref: 87166993
Node: Pragma Invariant170193
Ref: gnat_rm/implementation_defined_pragmas id19170334
Ref: 88170334
Ref: gnat_rm/implementation_defined_pragmas pragma-invariant170334
Ref: 89170334
Node: Pragma Keep_Names171990
Ref: gnat_rm/implementation_defined_pragmas pragma-keep-names172123
Ref: 8a172123
Node: Pragma License172739
Ref: gnat_rm/implementation_defined_pragmas pragma-license172872
Ref: 8b172872
Node: Pragma Link_With175970
Ref: gnat_rm/implementation_defined_pragmas pragma-link-with176105
Ref: 8c176105
Node: Pragma Linker_Alias176746
Ref: gnat_rm/implementation_defined_pragmas pragma-linker-alias176892
Ref: 8d176892
Node: Pragma Linker_Constructor178171
Ref: gnat_rm/implementation_defined_pragmas pragma-linker-constructor178325
Ref: 8e178325
Node: Pragma Linker_Destructor179554
Ref: gnat_rm/implementation_defined_pragmas pragma-linker-destructor179710
Ref: 8f179710
Node: Pragma Linker_Section180489
Ref: gnat_rm/implementation_defined_pragmas id20180636
Ref: 90180636
Ref: gnat_rm/implementation_defined_pragmas pragma-linker-section180636
Ref: 91180636
Node: Pragma Lock_Free183685
Ref: gnat_rm/implementation_defined_pragmas id21183829
Ref: 92183829
Ref: gnat_rm/implementation_defined_pragmas pragma-lock-free183829
Ref: 93183829
Node: Pragma Loop_Invariant184849
Ref: gnat_rm/implementation_defined_pragmas pragma-loop-invariant184992
Ref: 94184992
Node: Pragma Loop_Optimize186182
Ref: gnat_rm/implementation_defined_pragmas pragma-loop-optimize186328
Ref: 95186328
Node: Pragma Loop_Variant188062
Ref: gnat_rm/implementation_defined_pragmas pragma-loop-variant188211
Ref: 96188211
Node: Pragma Machine_Attribute190019
Ref: gnat_rm/implementation_defined_pragmas pragma-machine-attribute190159
Ref: 97190159
Node: Pragma Main191132
Ref: gnat_rm/implementation_defined_pragmas pragma-main191272
Ref: 98191272
Node: Pragma Main_Storage191710
Ref: gnat_rm/implementation_defined_pragmas pragma-main-storage191849
Ref: 99191849
Node: Pragma Max_Queue_Length192256
Ref: gnat_rm/implementation_defined_pragmas id22192398
Ref: 9a192398
Ref: gnat_rm/implementation_defined_pragmas pragma-max-queue-length192398
Ref: 9b192398
Node: Pragma No_Body192824
Ref: gnat_rm/implementation_defined_pragmas pragma-no-body192964
Ref: 9c192964
Node: Pragma No_Caching193747
Ref: gnat_rm/implementation_defined_pragmas id23193894
Ref: 9d193894
Ref: gnat_rm/implementation_defined_pragmas pragma-no-caching193894
Ref: 9e193894
Node: Pragma No_Component_Reordering194130
Ref: gnat_rm/implementation_defined_pragmas pragma-no-component-reordering194293
Ref: 9f194293
Node: Pragma No_Elaboration_Code_All194953
Ref: gnat_rm/implementation_defined_pragmas id24195126
Ref: a0195126
Ref: gnat_rm/implementation_defined_pragmas pragma-no-elaboration-code-all195126
Ref: a1195126
Node: Pragma No_Heap_Finalization195781
Ref: gnat_rm/implementation_defined_pragmas pragma-no-heap-finalization195940
Ref: a2195940
Node: Pragma No_Inline197092
Ref: gnat_rm/implementation_defined_pragmas id25197237
Ref: a3197237
Ref: gnat_rm/implementation_defined_pragmas pragma-no-inline197237
Ref: a4197237
Node: Pragma No_Return197743
Ref: gnat_rm/implementation_defined_pragmas pragma-no-return197886
Ref: a5197886
Node: Pragma No_Strict_Aliasing198859
Ref: gnat_rm/implementation_defined_pragmas pragma-no-strict-aliasing199010
Ref: a6199010
Node: Pragma No_Tagged_Streams199736
Ref: gnat_rm/implementation_defined_pragmas id26199895
Ref: a7199895
Ref: gnat_rm/implementation_defined_pragmas pragma-no-tagged-streams199895
Ref: a8199895
Node: Pragma Normalize_Scalars201670
Ref: gnat_rm/implementation_defined_pragmas pragma-normalize-scalars201822
Ref: a9201822
Node: Pragma Obsolescent204760
Ref: gnat_rm/implementation_defined_pragmas id27204913
Ref: aa204913
Ref: gnat_rm/implementation_defined_pragmas pragma-obsolescent204913
Ref: ab204913
Node: Pragma Optimize_Alignment208370
Ref: gnat_rm/implementation_defined_pragmas pragma-optimize-alignment208513
Ref: ac208513
Node: Pragma Ordered212024
Ref: gnat_rm/implementation_defined_pragmas pragma-ordered212169
Ref: ad212169
Node: Pragma Overflow_Mode215273
Ref: gnat_rm/implementation_defined_pragmas pragma-overflow-mode215420
Ref: ae215420
Node: Pragma Overriding_Renamings216758
Ref: gnat_rm/implementation_defined_pragmas pragma-overriding-renamings216926
Ref: af216926
Node: Pragma Partition_Elaboration_Policy217588
Ref: gnat_rm/implementation_defined_pragmas pragma-partition-elaboration-policy217750
Ref: b0217750
Node: Pragma Part_Of218126
Ref: gnat_rm/implementation_defined_pragmas id28218275
Ref: b1218275
Ref: gnat_rm/implementation_defined_pragmas pragma-part-of218275
Ref: b2218275
Node: Pragma Passive218521
Ref: gnat_rm/implementation_defined_pragmas pragma-passive218656
Ref: b3218656
Node: Pragma Persistent_BSS219514
Ref: gnat_rm/implementation_defined_pragmas id29219646
Ref: b4219646
Ref: gnat_rm/implementation_defined_pragmas pragma-persistent-bss219646
Ref: b5219646
Node: Pragma Post220842
Ref: gnat_rm/implementation_defined_pragmas pragma-post220980
Ref: b6220980
Node: Pragma Postcondition221495
Ref: gnat_rm/implementation_defined_pragmas pragma-postcondition221629
Ref: b7221629
Node: Pragma Post_Class227373
Ref: gnat_rm/implementation_defined_pragmas pragma-post-class227506
Ref: b8227506
Node: Pragma Pre228564
Ref: gnat_rm/implementation_defined_pragmas pragma-pre228696
Ref: b9228696
Node: Pragma Precondition229206
Ref: gnat_rm/implementation_defined_pragmas pragma-precondition229337
Ref: ba229337
Node: Pragma Predicate231284
Ref: gnat_rm/implementation_defined_pragmas id30231429
Ref: bb231429
Ref: gnat_rm/implementation_defined_pragmas pragma-predicate231429
Ref: bc231429
Node: Pragma Predicate_Failure233185
Ref: gnat_rm/implementation_defined_pragmas pragma-predicate-failure233346
Ref: bd233346
Node: Pragma Preelaborable_Initialization233703
Ref: gnat_rm/implementation_defined_pragmas pragma-preelaborable-initialization233880
Ref: be233880
Node: Pragma Prefix_Exception_Messages234198
Ref: gnat_rm/implementation_defined_pragmas pragma-prefix-exception-messages234367
Ref: bf234367
Node: Pragma Pre_Class235288
Ref: gnat_rm/implementation_defined_pragmas pragma-pre-class235458
Ref: c0235458
Node: Pragma Priority_Specific_Dispatching236506
Ref: gnat_rm/implementation_defined_pragmas pragma-priority-specific-dispatching236658
Ref: c1236658
Node: Pragma Profile237257
Ref: gnat_rm/implementation_defined_pragmas pragma-profile237416
Ref: c2237416
Node: Pragma Profile_Warnings244353
Ref: gnat_rm/implementation_defined_pragmas pragma-profile-warnings244503
Ref: c3244503
Node: Pragma Propagate_Exceptions244942
Ref: gnat_rm/implementation_defined_pragmas pragma-propagate-exceptions245108
Ref: c4245108
Node: Pragma Provide_Shift_Operators245506
Ref: gnat_rm/implementation_defined_pragmas pragma-provide-shift-operators245668
Ref: c5245668
Node: Pragma Psect_Object246231
Ref: gnat_rm/implementation_defined_pragmas pragma-psect-object246386
Ref: c6246386
Node: Pragma Pure_Function246739
Ref: gnat_rm/implementation_defined_pragmas id31246879
Ref: c7246879
Ref: gnat_rm/implementation_defined_pragmas pragma-pure-function246879
Ref: c8246879
Node: Pragma Rational249920
Ref: gnat_rm/implementation_defined_pragmas pragma-rational250057
Ref: c9250057
Node: Pragma Ravenscar250273
Ref: gnat_rm/implementation_defined_pragmas pragma-ravenscar250412
Ref: ca250412
Node: Pragma Refined_Depends250703
Ref: gnat_rm/implementation_defined_pragmas id32250848
Ref: cb250848
Ref: gnat_rm/implementation_defined_pragmas pragma-refined-depends250848
Ref: cc250848
Node: Pragma Refined_Global251582
Ref: gnat_rm/implementation_defined_pragmas id33251730
Ref: cd251730
Ref: gnat_rm/implementation_defined_pragmas pragma-refined-global251730
Ref: ce251730
Node: Pragma Refined_Post252311
Ref: gnat_rm/implementation_defined_pragmas id34252457
Ref: cf252457
Ref: gnat_rm/implementation_defined_pragmas pragma-refined-post252457
Ref: d0252457
Node: Pragma Refined_State252697
Ref: gnat_rm/implementation_defined_pragmas id35252846
Ref: d1252846
Ref: gnat_rm/implementation_defined_pragmas pragma-refined-state252846
Ref: d2252846
Node: Pragma Relative_Deadline253371
Ref: gnat_rm/implementation_defined_pragmas pragma-relative-deadline253526
Ref: d3253526
Node: Pragma Remote_Access_Type253820
Ref: gnat_rm/implementation_defined_pragmas id36253975
Ref: d4253975
Ref: gnat_rm/implementation_defined_pragmas pragma-remote-access-type253975
Ref: d5253975
Node: Pragma Rename_Pragma254853
Ref: gnat_rm/implementation_defined_pragmas pragma-rename-pragma255010
Ref: d6255010
Node: Pragma Restricted_Run_Time256173
Ref: gnat_rm/implementation_defined_pragmas pragma-restricted-run-time256332
Ref: d7256332
Node: Pragma Restriction_Warnings256658
Ref: gnat_rm/implementation_defined_pragmas pragma-restriction-warnings256814
Ref: d8256814
Node: Pragma Reviewable258102
Ref: gnat_rm/implementation_defined_pragmas pragma-reviewable258259
Ref: d9258259
Node: Pragma Secondary_Stack_Size260783
Ref: gnat_rm/implementation_defined_pragmas id37260933
Ref: da260933
Ref: gnat_rm/implementation_defined_pragmas pragma-secondary-stack-size260933
Ref: db260933
Node: Pragma Share_Generic262409
Ref: gnat_rm/implementation_defined_pragmas pragma-share-generic262555
Ref: dc262555
Node: Pragma Shared262947
Ref: gnat_rm/implementation_defined_pragmas id38263093
Ref: dd263093
Ref: gnat_rm/implementation_defined_pragmas pragma-shared263093
Ref: de263093
Node: Pragma Short_Circuit_And_Or263248
Ref: gnat_rm/implementation_defined_pragmas pragma-short-circuit-and-or263398
Ref: df263398
Node: Pragma Short_Descriptors264052
Ref: gnat_rm/implementation_defined_pragmas pragma-short-descriptors264220
Ref: e0264220
Node: Pragma Simple_Storage_Pool_Type264461
Ref: gnat_rm/implementation_defined_pragmas id39264625
Ref: e1264625
Ref: gnat_rm/implementation_defined_pragmas pragma-simple-storage-pool-type264625
Ref: e2264625
Node: Pragma Source_File_Name266915
Ref: gnat_rm/implementation_defined_pragmas id40267086
Ref: e4267086
Ref: gnat_rm/implementation_defined_pragmas pragma-source-file-name267086
Ref: e5267086
Node: Pragma Source_File_Name_Project270555
Ref: gnat_rm/implementation_defined_pragmas id41270718
Ref: e7270718
Ref: gnat_rm/implementation_defined_pragmas pragma-source-file-name-project270718
Ref: e6270718
Node: Pragma Source_Reference271493
Ref: gnat_rm/implementation_defined_pragmas pragma-source-reference271650
Ref: e8271650
Node: Pragma SPARK_Mode272491
Ref: gnat_rm/implementation_defined_pragmas id42272650
Ref: e9272650
Ref: gnat_rm/implementation_defined_pragmas pragma-spark-mode272650
Ref: ea272650
Node: Pragma Static_Elaboration_Desired274667
Ref: gnat_rm/implementation_defined_pragmas pragma-static-elaboration-desired274824
Ref: eb274824
Node: Pragma Stream_Convert275834
Ref: gnat_rm/implementation_defined_pragmas pragma-stream-convert275993
Ref: ec275993
Node: Pragma Style_Checks279162
Ref: gnat_rm/implementation_defined_pragmas pragma-style-checks279303
Ref: ed279303
Node: Pragma Subtitle281631
Ref: gnat_rm/implementation_defined_pragmas pragma-subtitle281766
Ref: ee281766
Node: Pragma Suppress281968
Ref: gnat_rm/implementation_defined_pragmas pragma-suppress282103
Ref: ef282103
Node: Pragma Suppress_All284974
Ref: gnat_rm/implementation_defined_pragmas pragma-suppress-all285120
Ref: f0285120
Node: Pragma Suppress_Debug_Info285662
Ref: gnat_rm/implementation_defined_pragmas id43285828
Ref: f1285828
Ref: gnat_rm/implementation_defined_pragmas pragma-suppress-debug-info285828
Ref: f2285828
Node: Pragma Suppress_Exception_Locations286160
Ref: gnat_rm/implementation_defined_pragmas pragma-suppress-exception-locations286337
Ref: f3286337
Node: Pragma Suppress_Initialization287268
Ref: gnat_rm/implementation_defined_pragmas id44287435
Ref: f4287435
Ref: gnat_rm/implementation_defined_pragmas pragma-suppress-initialization287435
Ref: f5287435
Node: Pragma Task_Name288999
Ref: gnat_rm/implementation_defined_pragmas pragma-task-name289150
Ref: f6289150
Node: Pragma Task_Storage290729
Ref: gnat_rm/implementation_defined_pragmas pragma-task-storage290866
Ref: f7290866
Node: Pragma Test_Case291401
Ref: gnat_rm/implementation_defined_pragmas id45291549
Ref: f8291549
Ref: gnat_rm/implementation_defined_pragmas pragma-test-case291549
Ref: f9291549
Node: Pragma Thread_Local_Storage293643
Ref: gnat_rm/implementation_defined_pragmas id46293789
Ref: fa293789
Ref: gnat_rm/implementation_defined_pragmas pragma-thread-local-storage293789
Ref: fb293789
Node: Pragma Time_Slice295004
Ref: gnat_rm/implementation_defined_pragmas pragma-time-slice295146
Ref: fc295146
Node: Pragma Title295530
Ref: gnat_rm/implementation_defined_pragmas pragma-title295666
Ref: fd295666
Node: Pragma Type_Invariant296383
Ref: gnat_rm/implementation_defined_pragmas pragma-type-invariant296529
Ref: fe296529
Node: Pragma Type_Invariant_Class297069
Ref: gnat_rm/implementation_defined_pragmas id47297225
Ref: ff297225
Ref: gnat_rm/implementation_defined_pragmas pragma-type-invariant-class297225
Ref: 100297225
Node: Pragma Unchecked_Union298140
Ref: gnat_rm/implementation_defined_pragmas pragma-unchecked-union298304
Ref: 101298304
Node: Pragma Unevaluated_Use_Of_Old298870
Ref: gnat_rm/implementation_defined_pragmas pragma-unevaluated-use-of-old299032
Ref: 102299032
Node: Pragma Unimplemented_Unit300959
Ref: gnat_rm/implementation_defined_pragmas pragma-unimplemented-unit301124
Ref: 103301124
Node: Pragma Universal_Aliasing301659
Ref: gnat_rm/implementation_defined_pragmas id48301812
Ref: 104301812
Ref: gnat_rm/implementation_defined_pragmas pragma-universal-aliasing301812
Ref: 105301812
Node: Pragma Unmodified302453
Ref: gnat_rm/implementation_defined_pragmas id49302600
Ref: 106302600
Ref: gnat_rm/implementation_defined_pragmas pragma-unmodified302600
Ref: 107302600
Node: Pragma Unreferenced303668
Ref: gnat_rm/implementation_defined_pragmas id50303817
Ref: 108303817
Ref: gnat_rm/implementation_defined_pragmas pragma-unreferenced303817
Ref: 109303817
Node: Pragma Unreferenced_Objects306494
Ref: gnat_rm/implementation_defined_pragmas id51306657
Ref: 10a306657
Ref: gnat_rm/implementation_defined_pragmas pragma-unreferenced-objects306657
Ref: 10b306657
Node: Pragma Unreserve_All_Interrupts307434
Ref: gnat_rm/implementation_defined_pragmas pragma-unreserve-all-interrupts307595
Ref: 10c307595
Node: Pragma Unsuppress309100
Ref: gnat_rm/implementation_defined_pragmas pragma-unsuppress309254
Ref: 10d309254
Node: Pragma Use_VADS_Size310523
Ref: gnat_rm/implementation_defined_pragmas pragma-use-vads-size310659
Ref: 10e310659
Node: Pragma Unused311220
Ref: gnat_rm/implementation_defined_pragmas id52311361
Ref: 10f311361
Ref: gnat_rm/implementation_defined_pragmas pragma-unused311361
Ref: 110311361
Node: Pragma Validity_Checks312541
Ref: gnat_rm/implementation_defined_pragmas pragma-validity-checks312677
Ref: 111312677
Node: Pragma Volatile314444
Ref: gnat_rm/implementation_defined_pragmas id53314594
Ref: 112314594
Ref: gnat_rm/implementation_defined_pragmas pragma-volatile314594
Ref: 113314594
Node: Pragma Volatile_Full_Access315064
Ref: gnat_rm/implementation_defined_pragmas id54315216
Ref: 114315216
Ref: gnat_rm/implementation_defined_pragmas pragma-volatile-full-access315216
Ref: 115315216
Node: Pragma Volatile_Function316284
Ref: gnat_rm/implementation_defined_pragmas id55316444
Ref: 116316444
Ref: gnat_rm/implementation_defined_pragmas pragma-volatile-function316444
Ref: 117316444
Node: Pragma Warning_As_Error316708
Ref: gnat_rm/implementation_defined_pragmas pragma-warning-as-error316856
Ref: 118316856
Node: Pragma Warnings320212
Ref: gnat_rm/implementation_defined_pragmas id56320356
Ref: 11a320356
Ref: gnat_rm/implementation_defined_pragmas pragma-warnings320356
Ref: 119320356
Node: Pragma Weak_External327810
Ref: gnat_rm/implementation_defined_pragmas pragma-weak-external327961
Ref: 11b327961
Node: Pragma Wide_Character_Encoding329642
Ref: gnat_rm/implementation_defined_pragmas pragma-wide-character-encoding329769
Ref: 11c329769
Node: Implementation Defined Aspects330901
Ref: gnat_rm/implementation_defined_aspects doc331053
Ref: 11d331053
Ref: gnat_rm/implementation_defined_aspects id1331053
Ref: 11e331053
Ref: gnat_rm/implementation_defined_aspects implementation-defined-aspects331053
Ref: 11f331053
Node: Aspect Abstract_State334269
Ref: gnat_rm/implementation_defined_aspects aspect-abstract-state334382
Ref: 120334382
Node: Aspect Annotate334498
Ref: gnat_rm/implementation_defined_aspects aspect-annotate334640
Ref: 121334640
Node: Aspect Async_Readers335099
Ref: gnat_rm/implementation_defined_aspects aspect-async-readers335240
Ref: 122335240
Node: Aspect Async_Writers335361
Ref: gnat_rm/implementation_defined_aspects aspect-async-writers335520
Ref: 123335520
Node: Aspect Constant_After_Elaboration335641
Ref: gnat_rm/implementation_defined_aspects aspect-constant-after-elaboration335801
Ref: 124335801
Node: Aspect Contract_Cases335953
Ref: gnat_rm/implementation_defined_aspects aspect-contract-cases336107
Ref: 125336107
Node: Aspect Depends336319
Ref: gnat_rm/implementation_defined_aspects aspect-depends336472
Ref: 126336472
Node: Aspect Default_Initial_Condition336567
Ref: gnat_rm/implementation_defined_aspects aspect-default-initial-condition336715
Ref: 127336715
Node: Aspect Dimension336864
Ref: gnat_rm/implementation_defined_aspects aspect-dimension337021
Ref: 128337021
Node: Aspect Dimension_System338241
Ref: gnat_rm/implementation_defined_aspects aspect-dimension-system338391
Ref: 129338391
Node: Aspect Disable_Controlled340941
Ref: gnat_rm/implementation_defined_aspects aspect-disable-controlled341097
Ref: 12a341097
Node: Aspect Effective_Reads341538
Ref: gnat_rm/implementation_defined_aspects aspect-effective-reads341694
Ref: 12b341694
Node: Aspect Effective_Writes341815
Ref: gnat_rm/implementation_defined_aspects aspect-effective-writes341971
Ref: 12c341971
Node: Aspect Extensions_Visible342095
Ref: gnat_rm/implementation_defined_aspects aspect-extensions-visible342251
Ref: 12d342251
Node: Aspect Favor_Top_Level342381
Ref: gnat_rm/implementation_defined_aspects aspect-favor-top-level342526
Ref: 12e342526
Node: Aspect Ghost342655
Ref: gnat_rm/implementation_defined_aspects aspect-ghost342788
Ref: 12f342788
Node: Aspect Global342879
Ref: gnat_rm/implementation_defined_aspects aspect-global343014
Ref: 130343014
Node: Aspect Initial_Condition343108
Ref: gnat_rm/implementation_defined_aspects aspect-initial-condition343249
Ref: 131343249
Node: Aspect Initializes343376
Ref: gnat_rm/implementation_defined_aspects aspect-initializes343524
Ref: 132343524
Node: Aspect Inline_Always343633
Ref: gnat_rm/implementation_defined_aspects aspect-inline-always343773
Ref: 133343773
Node: Aspect Invariant343896
Ref: gnat_rm/implementation_defined_aspects aspect-invariant344042
Ref: 134344042
Node: Aspect Invariant’Class344294
Ref: gnat_rm/implementation_defined_aspects aspect-invariant-class344435
Ref: 135344435
Node: Aspect Iterable344719
Ref: gnat_rm/implementation_defined_aspects aspect-iterable344865
Ref: 136344865
Node: Aspect Linker_Section347231
Ref: gnat_rm/implementation_defined_aspects aspect-linker-section347369
Ref: 137347369
Node: Aspect Lock_Free347487
Ref: gnat_rm/implementation_defined_aspects aspect-lock-free347633
Ref: 138347633
Node: Aspect Max_Queue_Length347744
Ref: gnat_rm/implementation_defined_aspects aspect-max-queue-length347886
Ref: 139347886
Node: Aspect No_Caching348010
Ref: gnat_rm/implementation_defined_aspects aspect-no-caching348166
Ref: 13a348166
Node: Aspect No_Elaboration_Code_All348280
Ref: gnat_rm/implementation_defined_aspects aspect-no-elaboration-code-all348429
Ref: 13b348429
Node: Aspect No_Inline348594
Ref: gnat_rm/implementation_defined_aspects aspect-no-inline348750
Ref: 13c348750
Node: Aspect No_Tagged_Streams348861
Ref: gnat_rm/implementation_defined_aspects aspect-no-tagged-streams349007
Ref: 13d349007
Node: Aspect No_Task_Parts349236
Ref: gnat_rm/implementation_defined_aspects aspect-no-task-parts349384
Ref: 13e349384
Node: Aspect Object_Size349890
Ref: gnat_rm/implementation_defined_aspects aspect-object-size350032
Ref: 13f350032
Node: Aspect Obsolescent350145
Ref: gnat_rm/implementation_defined_aspects aspect-obsolescent350281
Ref: 141350281
Node: Aspect Part_Of350509
Ref: gnat_rm/implementation_defined_aspects aspect-part-of350648
Ref: 142350648
Node: Aspect Persistent_BSS350745
Ref: gnat_rm/implementation_defined_aspects aspect-persistent-bss350882
Ref: 143350882
Node: Aspect Predicate351008
Ref: gnat_rm/implementation_defined_aspects aspect-predicate351151
Ref: 144351151
Node: Aspect Pure_Function351540
Ref: gnat_rm/implementation_defined_aspects aspect-pure-function351684
Ref: 145351684
Node: Aspect Refined_Depends351807
Ref: gnat_rm/implementation_defined_aspects aspect-refined-depends351956
Ref: 146351956
Node: Aspect Refined_Global352077
Ref: gnat_rm/implementation_defined_aspects aspect-refined-global352225
Ref: 147352225
Node: Aspect Refined_Post352343
Ref: gnat_rm/implementation_defined_aspects aspect-refined-post352489
Ref: 148352489
Node: Aspect Refined_State352601
Ref: gnat_rm/implementation_defined_aspects aspect-refined-state352755
Ref: 149352755
Node: Aspect Relaxed_Initialization352870
Ref: gnat_rm/implementation_defined_aspects aspect-relaxed-initialization353030
Ref: 14a353030
Node: Aspect Remote_Access_Type353198
Ref: gnat_rm/implementation_defined_aspects aspect-remote-access-type353365
Ref: 14b353365
Node: Aspect Secondary_Stack_Size353495
Ref: gnat_rm/implementation_defined_aspects aspect-secondary-stack-size353660
Ref: 14c353660
Node: Aspect Scalar_Storage_Order353796
Ref: gnat_rm/implementation_defined_aspects aspect-scalar-storage-order353949
Ref: 14d353949
Node: Aspect Shared354091
Ref: gnat_rm/implementation_defined_aspects aspect-shared354243
Ref: 14f354243
Node: Aspect Simple_Storage_Pool354392
Ref: gnat_rm/implementation_defined_aspects aspect-simple-storage-pool354548
Ref: 150354548
Node: Aspect Simple_Storage_Pool_Type354684
Ref: gnat_rm/implementation_defined_aspects aspect-simple-storage-pool-type354844
Ref: 151354844
Node: Aspect SPARK_Mode355000
Ref: gnat_rm/implementation_defined_aspects aspect-spark-mode355160
Ref: 152355160
Node: Aspect Suppress_Debug_Info355364
Ref: gnat_rm/implementation_defined_aspects aspect-suppress-debug-info355523
Ref: 153355523
Node: Aspect Suppress_Initialization355664
Ref: gnat_rm/implementation_defined_aspects aspect-suppress-initialization355822
Ref: 154355822
Node: Aspect Test_Case355975
Ref: gnat_rm/implementation_defined_aspects aspect-test-case356134
Ref: 155356134
Node: Aspect Thread_Local_Storage356237
Ref: gnat_rm/implementation_defined_aspects aspect-thread-local-storage356391
Ref: 156356391
Node: Aspect Universal_Aliasing356535
Ref: gnat_rm/implementation_defined_aspects aspect-universal-aliasing356690
Ref: 157356690
Node: Aspect Unmodified356829
Ref: gnat_rm/implementation_defined_aspects aspect-unmodified356976
Ref: 158356976
Node: Aspect Unreferenced357091
Ref: gnat_rm/implementation_defined_aspects aspect-unreferenced357240
Ref: 159357240
Node: Aspect Unreferenced_Objects357525
Ref: gnat_rm/implementation_defined_aspects aspect-unreferenced-objects357674
Ref: 15a357674
Node: Aspect Value_Size357819
Ref: gnat_rm/implementation_defined_aspects aspect-value-size357976
Ref: 15b357976
Node: Aspect Volatile_Full_Access358086
Ref: gnat_rm/implementation_defined_aspects aspect-volatile-full-access358240
Ref: 15d358240
Node: Aspect Volatile_Function358385
Ref: gnat_rm/implementation_defined_aspects aspect-volatile-function358537
Ref: 15e358537
Node: Aspect Warnings358673
Ref: gnat_rm/implementation_defined_aspects aspect-warnings358789
Ref: 15f358789
Node: Implementation Defined Attributes359004
Ref: gnat_rm/implementation_defined_attributes doc359174
Ref: 160359174
Ref: gnat_rm/implementation_defined_attributes id1359174
Ref: 161359174
Ref: gnat_rm/implementation_defined_attributes implementation-defined-attributes359174
Ref: 8359174
Node: Attribute Abort_Signal362390
Ref: gnat_rm/implementation_defined_attributes attribute-abort-signal362514
Ref: 162362514
Node: Attribute Address_Size362949
Ref: gnat_rm/implementation_defined_attributes attribute-address-size363101
Ref: 163363101
Node: Attribute Asm_Input363482
Ref: gnat_rm/implementation_defined_attributes attribute-asm-input363632
Ref: 164363632
Node: Attribute Asm_Output364257
Ref: gnat_rm/implementation_defined_attributes attribute-asm-output364418
Ref: 166364418
Node: Attribute Atomic_Always_Lock_Free365194
Ref: gnat_rm/implementation_defined_attributes attribute-atomic-always-lock-free365349
Ref: 167365349
Node: Attribute Bit365688
Ref: gnat_rm/implementation_defined_attributes attribute-bit365845
Ref: 168365845
Node: Attribute Bit_Position366926
Ref: gnat_rm/implementation_defined_attributes attribute-bit-position367072
Ref: 169367072
Node: Attribute Code_Address367518
Ref: gnat_rm/implementation_defined_attributes attribute-code-address367677
Ref: 16a367677
Node: Attribute Compiler_Version369011
Ref: gnat_rm/implementation_defined_attributes attribute-compiler-version369169
Ref: 16b369169
Node: Attribute Constrained369439
Ref: gnat_rm/implementation_defined_attributes attribute-constrained369602
Ref: 16c369602
Node: Attribute Default_Bit_Order370076
Ref: gnat_rm/implementation_defined_attributes attribute-default-bit-order370251
Ref: 16d370251
Node: Attribute Default_Scalar_Storage_Order370623
Ref: gnat_rm/implementation_defined_attributes attribute-default-scalar-storage-order370792
Ref: 16e370792
Node: Attribute Deref371213
Ref: gnat_rm/implementation_defined_attributes attribute-deref371380
Ref: 16f371380
Node: Attribute Descriptor_Size371810
Ref: gnat_rm/implementation_defined_attributes attribute-descriptor-size371959
Ref: 170371959
Node: Attribute Elaborated372961
Ref: gnat_rm/implementation_defined_attributes attribute-elaborated373114
Ref: 171373114
Node: Attribute Elab_Body373656
Ref: gnat_rm/implementation_defined_attributes attribute-elab-body373803
Ref: 172373803
Node: Attribute Elab_Spec374353
Ref: gnat_rm/implementation_defined_attributes attribute-elab-spec374504
Ref: 173374504
Node: Attribute Elab_Subp_Body375054
Ref: gnat_rm/implementation_defined_attributes attribute-elab-subp-body375200
Ref: 174375200
Node: Attribute Emax375622
Ref: gnat_rm/implementation_defined_attributes attribute-emax375766
Ref: 175375766
Node: Attribute Enabled375970
Ref: gnat_rm/implementation_defined_attributes attribute-enabled376108
Ref: 176376108
Node: Attribute Enum_Rep377230
Ref: gnat_rm/implementation_defined_attributes attribute-enum-rep377372
Ref: 177377372
Node: Attribute Enum_Val378865
Ref: gnat_rm/implementation_defined_attributes attribute-enum-val379007
Ref: 178379007
Node: Attribute Epsilon379733
Ref: gnat_rm/implementation_defined_attributes attribute-epsilon379876
Ref: 179379876
Node: Attribute Fast_Math380089
Ref: gnat_rm/implementation_defined_attributes attribute-fast-math380241
Ref: 17a380241
Node: Attribute Finalization_Size380463
Ref: gnat_rm/implementation_defined_attributes attribute-finalization-size380619
Ref: 17b380619
Node: Attribute Fixed_Value381229
Ref: gnat_rm/implementation_defined_attributes attribute-fixed-value381384
Ref: 17c381384
Node: Attribute From_Any382086
Ref: gnat_rm/implementation_defined_attributes attribute-from-any382241
Ref: 17d382241
Node: Attribute Has_Access_Values382418
Ref: gnat_rm/implementation_defined_attributes attribute-has-access-values382579
Ref: 17e382579
Node: Attribute Has_Discriminants383105
Ref: gnat_rm/implementation_defined_attributes attribute-has-discriminants383275
Ref: 17f383275
Node: Attribute Has_Tagged_Values383716
Ref: gnat_rm/implementation_defined_attributes attribute-has-tagged-values383872
Ref: 180383872
Node: Attribute Img384402
Ref: gnat_rm/implementation_defined_attributes attribute-img384552
Ref: 181384552
Node: Attribute Initialized385219
Ref: gnat_rm/implementation_defined_attributes attribute-initialized385365
Ref: 182385365
Node: Attribute Integer_Value385520
Ref: gnat_rm/implementation_defined_attributes attribute-integer-value385676
Ref: 183385676
Node: Attribute Invalid_Value386440
Ref: gnat_rm/implementation_defined_attributes attribute-invalid-value386593
Ref: 184386593
Node: Attribute Iterable387067
Ref: gnat_rm/implementation_defined_attributes attribute-iterable387212
Ref: 185387212
Node: Attribute Large387293
Ref: gnat_rm/implementation_defined_attributes attribute-large387438
Ref: 186387438
Node: Attribute Library_Level387645
Ref: gnat_rm/implementation_defined_attributes attribute-library-level387791
Ref: 187387791
Node: Attribute Lock_Free388426
Ref: gnat_rm/implementation_defined_attributes attribute-lock-free388577
Ref: 188388577
Node: Attribute Loop_Entry388734
Ref: gnat_rm/implementation_defined_attributes attribute-loop-entry388884
Ref: 189388884
Node: Attribute Machine_Size389889
Ref: gnat_rm/implementation_defined_attributes attribute-machine-size390038
Ref: 18a390038
Node: Attribute Mantissa390238
Ref: gnat_rm/implementation_defined_attributes attribute-mantissa390394
Ref: 18b390394
Node: Attribute Maximum_Alignment390610
Ref: gnat_rm/implementation_defined_attributes attribute-maximum-alignment390770
Ref: 18c390770
Ref: gnat_rm/implementation_defined_attributes id2390770
Ref: 18d390770
Node: Attribute Max_Integer_Size391111
Ref: gnat_rm/implementation_defined_attributes attribute-max-integer-size391277
Ref: 18e391277
Node: Attribute Mechanism_Code391524
Ref: gnat_rm/implementation_defined_attributes attribute-mechanism-code391687
Ref: 18f391687
Node: Attribute Null_Parameter392119
Ref: gnat_rm/implementation_defined_attributes attribute-null-parameter392277
Ref: 190392277
Node: Attribute Object_Size393002
Ref: gnat_rm/implementation_defined_attributes attribute-object-size393149
Ref: 140393149
Ref: gnat_rm/implementation_defined_attributes id3393149
Ref: 191393149
Node: Attribute Old395381
Ref: gnat_rm/implementation_defined_attributes attribute-old395533
Ref: 192395533
Node: Attribute Passed_By_Reference395991
Ref: gnat_rm/implementation_defined_attributes attribute-passed-by-reference396144
Ref: 193396144
Node: Attribute Pool_Address396558
Ref: gnat_rm/implementation_defined_attributes attribute-pool-address396720
Ref: 194396720
Node: Attribute Range_Length397476
Ref: gnat_rm/implementation_defined_attributes attribute-range-length397634
Ref: 195397634
Node: Attribute Restriction_Set398020
Ref: gnat_rm/implementation_defined_attributes attribute-restriction-set398172
Ref: 196398172
Node: Attribute Result400646
Ref: gnat_rm/implementation_defined_attributes attribute-result400795
Ref: 197400795
Node: Attribute Safe_Emax401197
Ref: gnat_rm/implementation_defined_attributes attribute-safe-emax401341
Ref: 198401341
Node: Attribute Safe_Large401559
Ref: gnat_rm/implementation_defined_attributes attribute-safe-large401707
Ref: 199401707
Node: Attribute Safe_Small401928
Ref: gnat_rm/implementation_defined_attributes attribute-safe-small402087
Ref: 19a402087
Node: Attribute Scalar_Storage_Order402308
Ref: gnat_rm/implementation_defined_attributes attribute-scalar-storage-order402476
Ref: 14e402476
Ref: gnat_rm/implementation_defined_attributes id4402476
Ref: 19b402476
Node: Attribute Simple_Storage_Pool408297
Ref: gnat_rm/implementation_defined_attributes attribute-simple-storage-pool408460
Ref: e3408460
Ref: gnat_rm/implementation_defined_attributes id5408460
Ref: 19c408460
Node: Attribute Small411077
Ref: gnat_rm/implementation_defined_attributes attribute-small411237
Ref: 19d411237
Node: Attribute Small_Denominator411604
Ref: gnat_rm/implementation_defined_attributes attribute-small-denominator411760
Ref: 19e411760
Node: Attribute Small_Numerator412036
Ref: gnat_rm/implementation_defined_attributes attribute-small-numerator412199
Ref: 19f412199
Node: Attribute Storage_Unit412467
Ref: gnat_rm/implementation_defined_attributes attribute-storage-unit412622
Ref: 1a0412622
Node: Attribute Stub_Type412806
Ref: gnat_rm/implementation_defined_attributes attribute-stub-type412972
Ref: 1a1412972
Node: Attribute System_Allocator_Alignment413927
Ref: gnat_rm/implementation_defined_attributes attribute-system-allocator-alignment414092
Ref: 1a2414092
Node: Attribute Target_Name414567
Ref: gnat_rm/implementation_defined_attributes attribute-target-name414733
Ref: 1a3414733
Node: Attribute To_Address415108
Ref: gnat_rm/implementation_defined_attributes attribute-to-address415254
Ref: 1a4415254
Node: Attribute To_Any416077
Ref: gnat_rm/implementation_defined_attributes attribute-to-any416222
Ref: 1a5416222
Node: Attribute Type_Class416395
Ref: gnat_rm/implementation_defined_attributes attribute-type-class416538
Ref: 1a6416538
Node: Attribute Type_Key417403
Ref: gnat_rm/implementation_defined_attributes attribute-type-key417548
Ref: 1a7417548
Node: Attribute TypeCode417857
Ref: gnat_rm/implementation_defined_attributes attribute-typecode418011
Ref: 1a8418011
Node: Attribute Unconstrained_Array418188
Ref: gnat_rm/implementation_defined_attributes attribute-unconstrained-array418358
Ref: 1a9418358
Node: Attribute Universal_Literal_String418774
Ref: gnat_rm/implementation_defined_attributes attribute-universal-literal-string418955
Ref: 1aa418955
Node: Attribute Unrestricted_Access419647
Ref: gnat_rm/implementation_defined_attributes attribute-unrestricted-access419815
Ref: 1ab419815
Node: Attribute Update426135
Ref: gnat_rm/implementation_defined_attributes attribute-update426290
Ref: 1ac426290
Node: Attribute Valid_Image429121
Ref: gnat_rm/implementation_defined_attributes attribute-valid-image429270
Ref: 1ad429270
Node: Attribute Valid_Scalars429607
Ref: gnat_rm/implementation_defined_attributes attribute-valid-scalars429759
Ref: 1ae429759
Node: Attribute VADS_Size431417
Ref: gnat_rm/implementation_defined_attributes attribute-vads-size431568
Ref: 1af431568
Node: Attribute Value_Size432209
Ref: gnat_rm/implementation_defined_attributes attribute-value-size432359
Ref: 15c432359
Ref: gnat_rm/implementation_defined_attributes id6432359
Ref: 1b0432359
Node: Attribute Wchar_T_Size432604
Ref: gnat_rm/implementation_defined_attributes attribute-wchar-t-size432754
Ref: 1b1432754
Node: Attribute Word_Size433058
Ref: gnat_rm/implementation_defined_attributes attribute-word-size433179
Ref: 1b2433179
Node: Standard and Implementation Defined Restrictions433377
Ref: gnat_rm/standard_and_implementation_defined_restrictions doc433538
Ref: 1b3433538
Ref: gnat_rm/standard_and_implementation_defined_restrictions id1433538
Ref: 1b4433538
Ref: gnat_rm/standard_and_implementation_defined_restrictions standard-and-implementation-defined-restrictions433538
Ref: 9433538
Node: Partition-Wide Restrictions434069
Ref: gnat_rm/standard_and_implementation_defined_restrictions id2434222
Ref: 1b5434222
Ref: gnat_rm/standard_and_implementation_defined_restrictions partition-wide-restrictions434222
Ref: 1b6434222
Node: Immediate_Reclamation436537
Ref: gnat_rm/standard_and_implementation_defined_restrictions immediate-reclamation436663
Ref: 1b7436663
Node: Max_Asynchronous_Select_Nesting436976
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-asynchronous-select-nesting437133
Ref: 1b8437133
Node: Max_Entry_Queue_Length437466
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-entry-queue-length437623
Ref: 1b9437623
Node: Max_Protected_Entries438319
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-protected-entries438468
Ref: 1ba438468
Node: Max_Select_Alternatives438753
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-select-alternatives438903
Ref: 1bb438903
Node: Max_Storage_At_Blocking439042
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-storage-at-blocking439187
Ref: 1bc439187
Node: Max_Task_Entries439445
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-task-entries439576
Ref: 1bd439576
Node: Max_Tasks439837
Ref: gnat_rm/standard_and_implementation_defined_restrictions max-tasks439964
Ref: 1be439964
Node: No_Abort_Statements440292
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-abort-statements440433
Ref: 1bf440433
Node: No_Access_Parameter_Allocators440585
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-access-parameter-allocators440738
Ref: 1c0440738
Node: No_Access_Subprograms440960
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-access-subprograms441107
Ref: 1c1441107
Node: No_Allocators441279
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-allocators441419
Ref: 1c2441419
Node: No_Anonymous_Allocators441560
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-anonymous-allocators441702
Ref: 1c3441702
Node: No_Asynchronous_Control441888
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-asynchronous-control442028
Ref: 1c4442028
Node: No_Calendar442235
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-calendar442367
Ref: 1c5442367
Node: No_Coextensions442515
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-coextensions442649
Ref: 1c6442649
Node: No_Default_Initialization442792
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-default-initialization442923
Ref: 1c7442923
Node: No_Delay443623
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-delay443752
Ref: 1c8443752
Node: No_Dependence443920
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dependence444051
Ref: 1c9444051
Node: No_Direct_Boolean_Operators444198
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-direct-boolean-operators444332
Ref: 1ca444332
Node: No_Dispatch444732
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dispatch444873
Ref: 1cb444873
Node: No_Dispatching_Calls445045
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dispatching-calls445180
Ref: 1cc445180
Node: No_Dynamic_Attachment447276
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dynamic-attachment447421
Ref: 1cd447421
Node: No_Dynamic_Priorities447964
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dynamic-priorities448123
Ref: 1ce448123
Node: No_Entry_Calls_In_Elaboration_Code448262
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-entry-calls-in-elaboration-code448419
Ref: 1cf448419
Node: No_Enumeration_Maps448779
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-enumeration-maps448936
Ref: 1d0448936
Node: No_Exception_Handlers449162
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-exception-handlers449309
Ref: 1d1449309
Node: No_Exception_Propagation450182
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-exception-propagation450335
Ref: 1d2450335
Node: No_Exception_Registration451008
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-exception-registration451153
Ref: 1d3451153
Node: No_Exceptions451634
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-exceptions451770
Ref: 1d4451770
Node: No_Finalization451997
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-finalization452122
Ref: 1d5452122
Node: No_Fixed_Point452954
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-fixed-point453083
Ref: 1d6453083
Node: No_Floating_Point453246
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-floating-point453384
Ref: 1d7453384
Node: No_Implicit_Conditionals453556
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-conditionals453704
Ref: 1d8453704
Node: No_Implicit_Dynamic_Code454339
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-dynamic-code454498
Ref: 1d9454498
Node: No_Implicit_Heap_Allocations455719
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-heap-allocations455894
Ref: 1da455894
Node: No_Implicit_Protected_Object_Allocations456038
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-protected-object-allocations456217
Ref: 1db456217
Node: No_Implicit_Task_Allocations456405
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-task-allocations456577
Ref: 1dc456577
Node: No_Initialize_Scalars456729
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-initialize-scalars456866
Ref: 1dd456866
Node: No_IO457210
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-io457338
Ref: 1de457338
Node: No_Local_Allocators457556
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-local-allocators457689
Ref: 1df457689
Node: No_Local_Protected_Objects457903
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-local-protected-objects458053
Ref: 1e0458053
Node: No_Local_Timing_Events458236
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-local-timing-events458388
Ref: 1e1458388
Node: No_Long_Long_Integers458555
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-long-long-integers458704
Ref: 1e2458704
Node: No_Multiple_Elaboration459014
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-multiple-elaboration459163
Ref: 1e3459163
Node: No_Nested_Finalization459806
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-nested-finalization459962
Ref: 1e4459962
Node: No_Protected_Type_Allocators460103
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-protected-type-allocators460254
Ref: 1e5460254
Node: No_Protected_Types460462
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-protected-types460603
Ref: 1e6460603
Node: No_Recursion460779
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-recursion460905
Ref: 1e7460905
Node: No_Reentrancy461042
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-reentrancy461167
Ref: 1e8461167
Node: No_Relative_Delay461312
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-relative-delay461446
Ref: 1e9461446
Node: No_Requeue_Statements461674
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-requeue-statements461813
Ref: 1ea461813
Node: No_Secondary_Stack462280
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-secondary-stack462422
Ref: 1eb462422
Node: No_Select_Statements462827
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-select-statements462980
Ref: 1ec462980
Node: No_Specific_Termination_Handlers463185
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-specific-termination-handlers463346
Ref: 1ed463346
Node: No_Specification_of_Aspect463546
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-specification-of-aspect463727
Ref: 1ee463727
Node: No_Standard_Allocators_After_Elaboration463948
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-standard-allocators-after-elaboration464122
Ref: 1ef464122
Node: No_Standard_Storage_Pools464437
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-standard-storage-pools464608
Ref: 1f0464608
Node: No_Stream_Optimizations464903
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-stream-optimizations465044
Ref: 1f1465044
Node: No_Streams465477
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-streams465620
Ref: 1f2465620
Node: No_Tagged_Type_Registration466341
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-tagged-type-registration466479
Ref: 1f3466479
Node: No_Task_Allocators466961
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-task-allocators467118
Ref: 1f4467118
Node: No_Task_At_Interrupt_Priority467260
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-task-at-interrupt-priority467416
Ref: 1f5467416
Node: No_Task_Attributes_Package467718
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-task-attributes-package467873
Ref: 1f6467873
Node: No_Task_Hierarchy468345
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-task-hierarchy468490
Ref: 1f7468490
Node: No_Task_Termination468637
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-task-termination468766
Ref: 1f8468766
Node: No_Tasking468867
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-tasking469004
Ref: 1f9469004
Node: No_Terminate_Alternatives469324
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-terminate-alternatives469461
Ref: 1fa469461
Node: No_Unchecked_Access469598
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-unchecked-access469748
Ref: 1fb469748
Node: No_Unchecked_Conversion469919
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-unchecked-conversion470069
Ref: 1fc470069
Node: No_Unchecked_Deallocation470280
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-unchecked-deallocation470427
Ref: 1fd470427
Node: No_Use_Of_Entity470645
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-use-of-entity470782
Ref: 1fe470782
Node: Pure_Barriers471080
Ref: gnat_rm/standard_and_implementation_defined_restrictions pure-barriers471207
Ref: 1ff471207
Node: Simple_Barriers471912
Ref: gnat_rm/standard_and_implementation_defined_restrictions simple-barriers472040
Ref: 200472040
Node: Static_Priorities472639
Ref: gnat_rm/standard_and_implementation_defined_restrictions static-priorities472773
Ref: 201472773
Node: Static_Storage_Size472994
Ref: gnat_rm/standard_and_implementation_defined_restrictions static-storage-size473104
Ref: 202473104
Node: Program Unit Level Restrictions473305
Ref: gnat_rm/standard_and_implementation_defined_restrictions id3473458
Ref: 203473458
Ref: gnat_rm/standard_and_implementation_defined_restrictions program-unit-level-restrictions473458
Ref: 204473458
Node: No_Elaboration_Code474217
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-elaboration-code474345
Ref: 205474345
Node: No_Dynamic_Accessibility_Checks476944
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dynamic-accessibility-checks477105
Ref: 206477105
Node: No_Dynamic_Sized_Objects478915
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-dynamic-sized-objects479071
Ref: 207479071
Node: No_Entry_Queue479793
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-entry-queue479957
Ref: 208479957
Node: No_Implementation_Aspect_Specifications480343
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-aspect-specifications480511
Ref: 209480511
Node: No_Implementation_Attributes480805
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-attributes480988
Ref: 20a480988
Node: No_Implementation_Identifiers481266
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-identifiers481435
Ref: 20b481435
Node: No_Implementation_Pragmas481689
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-pragmas481860
Ref: 20c481860
Node: No_Implementation_Restrictions482126
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-restrictions482291
Ref: 20d482291
Node: No_Implementation_Units482656
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implementation-units482816
Ref: 20e482816
Node: No_Implicit_Aliasing483062
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-aliasing483209
Ref: 20f483209
Node: No_Implicit_Loops483763
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-implicit-loops483910
Ref: 210483910
Node: No_Obsolescent_Features484646
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-obsolescent-features484791
Ref: 211484791
Node: No_Wide_Characters484998
Ref: gnat_rm/standard_and_implementation_defined_restrictions no-wide-characters485148
Ref: 212485148
Node: Static_Dispatch_Tables485512
Ref: gnat_rm/standard_and_implementation_defined_restrictions static-dispatch-tables485647
Ref: 213485647
Node: SPARK_05485846
Ref: gnat_rm/standard_and_implementation_defined_restrictions spark-05485954
Ref: 214485954
Node: Implementation Advice486413
Ref: gnat_rm/implementation_advice doc486579
Ref: 215486579
Ref: gnat_rm/implementation_advice id1486579
Ref: 216486579
Ref: gnat_rm/implementation_advice implementation-advice486579
Ref: a486579
Node: RM 1 1 3 20 Error Detection492484
Ref: gnat_rm/implementation_advice rm-1-1-3-20-error-detection492602
Ref: 217492602
Node: RM 1 1 3 31 Child Units492947
Ref: gnat_rm/implementation_advice rm-1-1-3-31-child-units493100
Ref: 218493100
Node: RM 1 1 5 12 Bounded Errors493389
Ref: gnat_rm/implementation_advice rm-1-1-5-12-bounded-errors493532
Ref: 219493532
Node: RM 2 8 16 Pragmas493871
Ref: gnat_rm/implementation_advice id2494011
Ref: 21a494011
Ref: gnat_rm/implementation_advice rm-2-8-16-pragmas494011
Ref: 21b494011
Node: RM 2 8 17-19 Pragmas495652
Ref: gnat_rm/implementation_advice rm-2-8-17-19-pragmas495803
Ref: 21c495803
Node: RM 3 5 2 5 Alternative Character Sets496237
Ref: gnat_rm/implementation_advice rm-3-5-2-5-alternative-character-sets496396
Ref: 21d496396
Node: RM 3 5 4 28 Integer Types497553
Ref: gnat_rm/implementation_advice rm-3-5-4-28-integer-types497717
Ref: 21e497717
Node: RM 3 5 4 29 Integer Types498391
Ref: gnat_rm/implementation_advice rm-3-5-4-29-integer-types498547
Ref: 21f498547
Node: RM 3 5 5 8 Enumeration Values498865
Ref: gnat_rm/implementation_advice rm-3-5-5-8-enumeration-values499019
Ref: 220499019
Node: RM 3 5 7 17 Float Types499568
Ref: gnat_rm/implementation_advice rm-3-5-7-17-float-types499732
Ref: 221499732
Node: RM 3 6 2 11 Multidimensional Arrays500841
Ref: gnat_rm/implementation_advice rm-3-6-2-11-multidimensional-arrays501005
Ref: 222501005
Node: RM 9 6 30-31 Duration’Small501501
Ref: gnat_rm/implementation_advice rm-9-6-30-31-duration-small501680
Ref: 223501680
Node: RM 10 2 1 12 Consistent Representation502102
Ref: gnat_rm/implementation_advice rm-10-2-1-12-consistent-representation502280
Ref: 224502280
Node: RM 11 4 1 19 Exception Information503070
Ref: gnat_rm/implementation_advice rm-11-4-1-19-exception-information503251
Ref: 225503251
Node: RM 11 5 28 Suppression of Checks504393
Ref: gnat_rm/implementation_advice rm-11-5-28-suppression-of-checks504572
Ref: 226504572
Node: RM 13 1 21-24 Representation Clauses504772
Ref: gnat_rm/implementation_advice rm-13-1-21-24-representation-clauses504941
Ref: 227504941
Node: RM 13 2 6-8 Packed Types506355
Ref: gnat_rm/implementation_advice rm-13-2-6-8-packed-types506521
Ref: 228506521
Node: RM 13 3 14-19 Address Clauses507853
Ref: gnat_rm/implementation_advice rm-13-3-14-19-address-clauses508014
Ref: 229508014
Node: RM 13 3 29-35 Alignment Clauses509149
Ref: gnat_rm/implementation_advice rm-13-3-29-35-alignment-clauses509312
Ref: 22a509312
Node: RM 13 3 42-43 Size Clauses510513
Ref: gnat_rm/implementation_advice rm-13-3-42-43-size-clauses510673
Ref: 22b510673
Node: RM 13 3 50-56 Size Clauses511138
Ref: gnat_rm/implementation_advice rm-13-3-50-56-size-clauses511303
Ref: 22c511303
Node: RM 13 3 71-73 Component Size Clauses512677
Ref: gnat_rm/implementation_advice rm-13-3-71-73-component-size-clauses512863
Ref: 22d512863
Node: RM 13 4 9-10 Enumeration Representation Clauses513671
Ref: gnat_rm/implementation_advice rm-13-4-9-10-enumeration-representation-clauses513876
Ref: 22e513876
Node: RM 13 5 1 17-22 Record Representation Clauses514298
Ref: gnat_rm/implementation_advice rm-13-5-1-17-22-record-representation-clauses514503
Ref: 22f514503
Node: RM 13 5 2 5 Storage Place Attributes516198
Ref: gnat_rm/implementation_advice rm-13-5-2-5-storage-place-attributes516382
Ref: 230516382
Node: RM 13 5 3 7-8 Bit Ordering516994
Ref: gnat_rm/implementation_advice rm-13-5-3-7-8-bit-ordering517162
Ref: 231517162
Node: RM 13 7 37 Address as Private517606
Ref: gnat_rm/implementation_advice rm-13-7-37-address-as-private517769
Ref: 232517769
Node: RM 13 7 1 16 Address Operations517910
Ref: gnat_rm/implementation_advice rm-13-7-1-16-address-operations518081
Ref: 233518081
Node: RM 13 9 14-17 Unchecked Conversion518620
Ref: gnat_rm/implementation_advice rm-13-9-14-17-unchecked-conversion518796
Ref: 234518796
Node: RM 13 11 23-25 Implicit Heap Usage520188
Ref: gnat_rm/implementation_advice rm-13-11-23-25-implicit-heap-usage520369
Ref: 235520369
Node: RM 13 11 2 17 Unchecked Deallocation521388
Ref: gnat_rm/implementation_advice rm-13-11-2-17-unchecked-deallocation521576
Ref: 236521576
Node: RM 13 13 2 1 6 Stream Oriented Attributes521770
Ref: gnat_rm/implementation_advice rm-13-13-2-1-6-stream-oriented-attributes521967
Ref: 237521967
Node: RM A 1 52 Names of Predefined Numeric Types522931
Ref: gnat_rm/implementation_advice rm-a-1-52-names-of-predefined-numeric-types523127
Ref: 238523127
Node: RM A 3 2 49 Ada Characters Handling523565
Ref: gnat_rm/implementation_advice rm-a-3-2-49-ada-characters-handling523763
Ref: 239523763
Node: RM A 4 4 106 Bounded-Length String Handling524155
Ref: gnat_rm/implementation_advice rm-a-4-4-106-bounded-length-string-handling524349
Ref: 23a524349
Node: RM A 5 2 46-47 Random Number Generation524628
Ref: gnat_rm/implementation_advice rm-a-5-2-46-47-random-number-generation524813
Ref: 23b524813
Node: RM A 10 7 23 Get_Immediate525645
Ref: gnat_rm/implementation_advice rm-a-10-7-23-get-immediate525805
Ref: 23c525805
Node: RM A 18 Containers526657
Ref: gnat_rm/implementation_advice rm-a-18-containers526804
Ref: 23d526804
Node: RM B 1 39-41 Pragma Export527435
Ref: gnat_rm/implementation_advice rm-b-1-39-41-pragma-export527587
Ref: 23e527587
Node: RM B 2 12-13 Package Interfaces529115
Ref: gnat_rm/implementation_advice rm-b-2-12-13-package-interfaces529280
Ref: 23f529280
Node: RM B 3 63-71 Interfacing with C530093
Ref: gnat_rm/implementation_advice rm-b-3-63-71-interfacing-with-c530267
Ref: 240530267
Node: RM B 4 95-98 Interfacing with COBOL532202
Ref: gnat_rm/implementation_advice rm-b-4-95-98-interfacing-with-cobol532382
Ref: 241532382
Node: RM B 5 22-26 Interfacing with Fortran533116
Ref: gnat_rm/implementation_advice rm-b-5-22-26-interfacing-with-fortran533304
Ref: 242533304
Node: RM C 1 3-5 Access to Machine Operations534392
Ref: gnat_rm/implementation_advice rm-c-1-3-5-access-to-machine-operations534586
Ref: 243534586
Node: RM C 1 10-16 Access to Machine Operations535562
Ref: gnat_rm/implementation_advice rm-c-1-10-16-access-to-machine-operations535746
Ref: 244535746
Node: RM C 3 28 Interrupt Support537016
Ref: gnat_rm/implementation_advice rm-c-3-28-interrupt-support537204
Ref: 245537204
Node: RM C 3 1 20-21 Protected Procedure Handlers537670
Ref: gnat_rm/implementation_advice rm-c-3-1-20-21-protected-procedure-handlers537847
Ref: 246537847
Node: RM C 3 2 25 Package Interrupts538351
Ref: gnat_rm/implementation_advice rm-c-3-2-25-package-interrupts538539
Ref: 247538539
Node: RM C 4 14 Pre-elaboration Requirements539009
Ref: gnat_rm/implementation_advice rm-c-4-14-pre-elaboration-requirements539183
Ref: 248539183
Node: RM C 5 8 Pragma Discard_Names539623
Ref: gnat_rm/implementation_advice rm-c-5-8-pragma-discard-names539806
Ref: 249539806
Node: RM C 7 2 30 The Package Task_Attributes540070
Ref: gnat_rm/implementation_advice rm-c-7-2-30-the-package-task-attributes540241
Ref: 24a540241
Node: RM D 3 17 Locking Policies540977
Ref: gnat_rm/implementation_advice rm-d-3-17-locking-policies541151
Ref: 24b541151
Node: RM D 4 16 Entry Queuing Policies541524
Ref: gnat_rm/implementation_advice rm-d-4-16-entry-queuing-policies541687
Ref: 24c541687
Node: RM D 6 9-10 Preemptive Abort541951
Ref: gnat_rm/implementation_advice rm-d-6-9-10-preemptive-abort542118
Ref: 24d542118
Node: RM D 7 21 Tasking Restrictions542684
Ref: gnat_rm/implementation_advice rm-d-7-21-tasking-restrictions542846
Ref: 24e542846
Node: RM D 8 47-49 Monotonic Time543348
Ref: gnat_rm/implementation_advice rm-d-8-47-49-monotonic-time543528
Ref: 24f543528
Node: RM E 5 28-29 Partition Communication Subsystem544203
Ref: gnat_rm/implementation_advice rm-e-5-28-29-partition-communication-subsystem544373
Ref: 250544373
Node: RM F 7 COBOL Support545067
Ref: gnat_rm/implementation_advice rm-f-7-cobol-support545240
Ref: 251545240
Node: RM F 1 2 Decimal Radix Support545791
Ref: gnat_rm/implementation_advice rm-f-1-2-decimal-radix-support545931
Ref: 252545931
Node: RM G Numerics546245
Ref: gnat_rm/implementation_advice rm-g-numerics546393
Ref: 253546393
Node: RM G 1 1 56-58 Complex Types546923
Ref: gnat_rm/implementation_advice rm-g-1-1-56-58-complex-types547081
Ref: 254547081
Node: RM G 1 2 49 Complex Elementary Functions549910
Ref: gnat_rm/implementation_advice rm-g-1-2-49-complex-elementary-functions550088
Ref: 255550088
Node: RM G 2 4 19 Accuracy Requirements550821
Ref: gnat_rm/implementation_advice rm-g-2-4-19-accuracy-requirements551010
Ref: 256551010
Node: RM G 2 6 15 Complex Arithmetic Accuracy551625
Ref: gnat_rm/implementation_advice rm-g-2-6-15-complex-arithmetic-accuracy551821
Ref: 257551821
Node: RM H 6 15/2 Pragma Partition_Elaboration_Policy552244
Ref: gnat_rm/implementation_advice rm-h-6-15-2-pragma-partition-elaboration-policy552398
Ref: 258552398
Node: Implementation Defined Characteristics552780
Ref: gnat_rm/implementation_defined_characteristics doc552919
Ref: 259552919
Ref: gnat_rm/implementation_defined_characteristics id1552919
Ref: 25a552919
Ref: gnat_rm/implementation_defined_characteristics implementation-defined-characteristics552919
Ref: b552919
Node: Intrinsic Subprograms604750
Ref: gnat_rm/intrinsic_subprograms doc604902
Ref: 25c604902
Ref: gnat_rm/intrinsic_subprograms id1604902
Ref: 25d604902
Ref: gnat_rm/intrinsic_subprograms intrinsic-subprograms604902
Ref: c604902
Node: Intrinsic Operators605882
Ref: gnat_rm/intrinsic_subprograms id2605989
Ref: 25e605989
Ref: gnat_rm/intrinsic_subprograms intrinsic-operators605989
Ref: 25f605989
Node: Compilation_ISO_Date606988
Ref: gnat_rm/intrinsic_subprograms compilation-iso-date607120
Ref: 260607120
Ref: gnat_rm/intrinsic_subprograms id3607120
Ref: 261607120
Node: Compilation_Date607541
Ref: gnat_rm/intrinsic_subprograms compilation-date607670
Ref: 262607670
Ref: gnat_rm/intrinsic_subprograms id4607670
Ref: 263607670
Node: Compilation_Time607790
Ref: gnat_rm/intrinsic_subprograms compilation-time607915
Ref: 264607915
Ref: gnat_rm/intrinsic_subprograms id5607915
Ref: 265607915
Node: Enclosing_Entity608322
Ref: gnat_rm/intrinsic_subprograms enclosing-entity608452
Ref: 266608452
Ref: gnat_rm/intrinsic_subprograms id6608452
Ref: 267608452
Node: Exception_Information608873
Ref: gnat_rm/intrinsic_subprograms exception-information609004
Ref: 268609004
Ref: gnat_rm/intrinsic_subprograms id7609004
Ref: 269609004
Node: Exception_Message609434
Ref: gnat_rm/intrinsic_subprograms exception-message609563
Ref: 26a609563
Ref: gnat_rm/intrinsic_subprograms id8609563
Ref: 26b609563
Node: Exception_Name609967
Ref: gnat_rm/intrinsic_subprograms exception-name610079
Ref: 26c610079
Ref: gnat_rm/intrinsic_subprograms id9610079
Ref: 26d610079
Node: File610458
Ref: gnat_rm/intrinsic_subprograms file610557
Ref: 26e610557
Ref: gnat_rm/intrinsic_subprograms id10610557
Ref: 26f610557
Node: Line610889
Ref: gnat_rm/intrinsic_subprograms id11610992
Ref: 270610992
Ref: gnat_rm/intrinsic_subprograms line610992
Ref: 271610992
Node: Shifts and Rotates611335
Ref: gnat_rm/intrinsic_subprograms id12611449
Ref: 272611449
Ref: gnat_rm/intrinsic_subprograms shifts-and-rotates611449
Ref: 273611449
Node: Source_Location612687
Ref: gnat_rm/intrinsic_subprograms id13612788
Ref: 274612788
Ref: gnat_rm/intrinsic_subprograms source-location612788
Ref: 275612788
Node: Representation Clauses and Pragmas613159
Ref: gnat_rm/representation_clauses_and_pragmas doc613298
Ref: 276613298
Ref: gnat_rm/representation_clauses_and_pragmas id1613298
Ref: 277613298
Ref: gnat_rm/representation_clauses_and_pragmas representation-clauses-and-pragmas613298
Ref: d613298
Node: Alignment Clauses614484
Ref: gnat_rm/representation_clauses_and_pragmas alignment-clauses614594
Ref: 278614594
Ref: gnat_rm/representation_clauses_and_pragmas id2614594
Ref: 279614594
Node: Size Clauses619028
Ref: gnat_rm/representation_clauses_and_pragmas id3619167
Ref: 27a619167
Ref: gnat_rm/representation_clauses_and_pragmas size-clauses619167
Ref: 27b619167
Node: Storage_Size Clauses621951
Ref: gnat_rm/representation_clauses_and_pragmas id4622103
Ref: 27c622103
Ref: gnat_rm/representation_clauses_and_pragmas storage-size-clauses622103
Ref: 27d622103
Node: Size of Variant Record Objects624631
Ref: gnat_rm/representation_clauses_and_pragmas id5624792
Ref: 27e624792
Ref: gnat_rm/representation_clauses_and_pragmas size-of-variant-record-objects624792
Ref: 27f624792
Node: Biased Representation627904
Ref: gnat_rm/representation_clauses_and_pragmas biased-representation628079
Ref: 280628079
Ref: gnat_rm/representation_clauses_and_pragmas id6628079
Ref: 281628079
Node: Value_Size and Object_Size Clauses629123
Ref: gnat_rm/representation_clauses_and_pragmas id7629290
Ref: 282629290
Ref: gnat_rm/representation_clauses_and_pragmas value-size-and-object-size-clauses629290
Ref: 283629290
Node: Component_Size Clauses638942
Ref: gnat_rm/representation_clauses_and_pragmas component-size-clauses639105
Ref: 284639105
Ref: gnat_rm/representation_clauses_and_pragmas id8639105
Ref: 285639105
Node: Bit_Order Clauses640739
Ref: gnat_rm/representation_clauses_and_pragmas bit-order-clauses640904
Ref: 286640904
Ref: gnat_rm/representation_clauses_and_pragmas id9640904
Ref: 287640904
Node: Effect of Bit_Order on Byte Ordering644349
Ref: gnat_rm/representation_clauses_and_pragmas effect-of-bit-order-on-byte-ordering644514
Ref: 288644514
Ref: gnat_rm/representation_clauses_and_pragmas id10644514
Ref: 289644514
Node: Pragma Pack for Arrays653968
Ref: gnat_rm/representation_clauses_and_pragmas id11654139
Ref: 28a654139
Ref: gnat_rm/representation_clauses_and_pragmas pragma-pack-for-arrays654139
Ref: 28b654139
Node: Pragma Pack for Records658636
Ref: gnat_rm/representation_clauses_and_pragmas id12658800
Ref: 28c658800
Ref: gnat_rm/representation_clauses_and_pragmas pragma-pack-for-records658800
Ref: 28d658800
Node: Record Representation Clauses661352
Ref: gnat_rm/representation_clauses_and_pragmas id13661524
Ref: 28e661524
Ref: gnat_rm/representation_clauses_and_pragmas record-representation-clauses661524
Ref: 28f661524
Node: Handling of Records with Holes664412
Ref: gnat_rm/representation_clauses_and_pragmas handling-of-records-with-holes664580
Ref: 290664580
Ref: gnat_rm/representation_clauses_and_pragmas id14664580
Ref: 291664580
Node: Enumeration Clauses666842
Ref: gnat_rm/representation_clauses_and_pragmas enumeration-clauses666996
Ref: 292666996
Ref: gnat_rm/representation_clauses_and_pragmas id15666996
Ref: 293666996
Node: Address Clauses668428
Ref: gnat_rm/representation_clauses_and_pragmas address-clauses668596
Ref: 294668596
Ref: gnat_rm/representation_clauses_and_pragmas id16668596
Ref: 295668596
Node: Use of Address Clauses for Memory-Mapped I/O679623
Ref: gnat_rm/representation_clauses_and_pragmas id17679810
Ref: 296679810
Ref: gnat_rm/representation_clauses_and_pragmas use-of-address-clauses-for-memory-mapped-i-o679810
Ref: 297679810
Node: Effect of Convention on Representation681678
Ref: gnat_rm/representation_clauses_and_pragmas effect-of-convention-on-representation681888
Ref: 298681888
Ref: gnat_rm/representation_clauses_and_pragmas id18681888
Ref: 299681888
Node: Conventions and Anonymous Access Types685001
Ref: gnat_rm/representation_clauses_and_pragmas conventions-and-anonymous-access-types685213
Ref: 29a685213
Ref: gnat_rm/representation_clauses_and_pragmas id19685213
Ref: 29b685213
Node: Determining the Representations chosen by GNAT687704
Ref: gnat_rm/representation_clauses_and_pragmas determining-the-representations-chosen-by-gnat687869
Ref: 29c687869
Ref: gnat_rm/representation_clauses_and_pragmas id20687869
Ref: 29d687869
Node: Standard Library Routines692459
Ref: gnat_rm/standard_library_routines doc692611
Ref: 29e692611
Ref: gnat_rm/standard_library_routines id1692611
Ref: 29f692611
Ref: gnat_rm/standard_library_routines standard-library-routines692611
Ref: e692611
Node: The Implementation of Standard I/O719257
Ref: gnat_rm/the_implementation_of_standard_i_o doc719391
Ref: 2a0719391
Ref: gnat_rm/the_implementation_of_standard_i_o id1719391
Ref: 2a1719391
Ref: gnat_rm/the_implementation_of_standard_i_o the-implementation-of-standard-i-o719391
Ref: f719391
Node: Standard I/O Packages721441
Ref: gnat_rm/the_implementation_of_standard_i_o id2721555
Ref: 2a2721555
Ref: gnat_rm/the_implementation_of_standard_i_o standard-i-o-packages721555
Ref: 2a3721555
Node: FORM Strings722894
Ref: gnat_rm/the_implementation_of_standard_i_o form-strings723026
Ref: 2a4723026
Ref: gnat_rm/the_implementation_of_standard_i_o id3723026
Ref: 2a5723026
Node: Direct_IO723640
Ref: gnat_rm/the_implementation_of_standard_i_o direct-io723764
Ref: 2a6723764
Ref: gnat_rm/the_implementation_of_standard_i_o id4723764
Ref: 2a7723764
Node: Sequential_IO724541
Ref: gnat_rm/the_implementation_of_standard_i_o id5724660
Ref: 2a8724660
Ref: gnat_rm/the_implementation_of_standard_i_o sequential-io724660
Ref: 2a9724660
Node: Text_IO726497
Ref: gnat_rm/the_implementation_of_standard_i_o id6726619
Ref: 2aa726619
Ref: gnat_rm/the_implementation_of_standard_i_o text-io726619
Ref: 2ab726619
Node: Stream Pointer Positioning729107
Ref: gnat_rm/the_implementation_of_standard_i_o id7729224
Ref: 2ac729224
Ref: gnat_rm/the_implementation_of_standard_i_o stream-pointer-positioning729224
Ref: 2ad729224
Node: Reading and Writing Non-Regular Files730671
Ref: gnat_rm/the_implementation_of_standard_i_o id8730810
Ref: 2ae730810
Ref: gnat_rm/the_implementation_of_standard_i_o reading-and-writing-non-regular-files730810
Ref: 2af730810
Node: Get_Immediate732584
Ref: gnat_rm/the_implementation_of_standard_i_o get-immediate732730
Ref: 2b0732730
Ref: gnat_rm/the_implementation_of_standard_i_o id9732730
Ref: 2b1732730
Node: Treating Text_IO Files as Streams733423
Ref: gnat_rm/the_implementation_of_standard_i_o id10733550
Ref: 2b2733550
Ref: gnat_rm/the_implementation_of_standard_i_o treating-text-io-files-as-streams733550
Ref: 2b3733550
Node: Text_IO Extensions734138
Ref: gnat_rm/the_implementation_of_standard_i_o id11734292
Ref: 2b4734292
Ref: gnat_rm/the_implementation_of_standard_i_o text-io-extensions734292
Ref: 2b5734292
Node: Text_IO Facilities for Unbounded Strings734909
Ref: gnat_rm/the_implementation_of_standard_i_o id12735021
Ref: 2b6735021
Ref: gnat_rm/the_implementation_of_standard_i_o text-io-facilities-for-unbounded-strings735021
Ref: 2b7735021
Node: Wide_Text_IO736595
Ref: gnat_rm/the_implementation_of_standard_i_o id13736721
Ref: 2b8736721
Ref: gnat_rm/the_implementation_of_standard_i_o wide-text-io736721
Ref: 2b9736721
Node: Stream Pointer Positioning<2>743650
Ref: gnat_rm/the_implementation_of_standard_i_o id14743778
Ref: 2ba743778
Ref: gnat_rm/the_implementation_of_standard_i_o stream-pointer-positioning-1743778
Ref: 2bb743778
Node: Reading and Writing Non-Regular Files<2>744696
Ref: gnat_rm/the_implementation_of_standard_i_o id15744824
Ref: 2bc744824
Ref: gnat_rm/the_implementation_of_standard_i_o reading-and-writing-non-regular-files-1744824
Ref: 2bd744824
Node: Wide_Wide_Text_IO745233
Ref: gnat_rm/the_implementation_of_standard_i_o id16745361
Ref: 2be745361
Ref: gnat_rm/the_implementation_of_standard_i_o wide-wide-text-io745361
Ref: 2bf745361
Node: Stream Pointer Positioning<3>749010
Ref: gnat_rm/the_implementation_of_standard_i_o id17749143
Ref: 2c0749143
Ref: gnat_rm/the_implementation_of_standard_i_o stream-pointer-positioning-2749143
Ref: 2c1749143
Node: Reading and Writing Non-Regular Files<3>750093
Ref: gnat_rm/the_implementation_of_standard_i_o id18750226
Ref: 2c2750226
Ref: gnat_rm/the_implementation_of_standard_i_o reading-and-writing-non-regular-files-2750226
Ref: 2c3750226
Node: Stream_IO750635
Ref: gnat_rm/the_implementation_of_standard_i_o id19750767
Ref: 2c4750767
Ref: gnat_rm/the_implementation_of_standard_i_o stream-io750767
Ref: 2c5750767
Node: Text Translation751284
Ref: gnat_rm/the_implementation_of_standard_i_o id20751411
Ref: 2c6751411
Ref: gnat_rm/the_implementation_of_standard_i_o text-translation751411
Ref: 2c7751411
Node: Shared Files752211
Ref: gnat_rm/the_implementation_of_standard_i_o id21752347
Ref: 2c8752347
Ref: gnat_rm/the_implementation_of_standard_i_o shared-files752347
Ref: 2c9752347
Node: Filenames encoding755093
Ref: gnat_rm/the_implementation_of_standard_i_o filenames-encoding755234
Ref: 2ca755234
Ref: gnat_rm/the_implementation_of_standard_i_o id22755234
Ref: 2cb755234
Node: File content encoding756036
Ref: gnat_rm/the_implementation_of_standard_i_o file-content-encoding756175
Ref: 2cc756175
Ref: gnat_rm/the_implementation_of_standard_i_o id23756175
Ref: 2cd756175
Node: Open Modes756683
Ref: gnat_rm/the_implementation_of_standard_i_o id24756827
Ref: 2ce756827
Ref: gnat_rm/the_implementation_of_standard_i_o open-modes756827
Ref: 2cf756827
Node: Operations on C Streams758813
Ref: gnat_rm/the_implementation_of_standard_i_o id25758960
Ref: 2d0758960
Ref: gnat_rm/the_implementation_of_standard_i_o operations-on-c-streams758960
Ref: 2d1758960
Node: Interfacing to C Streams765764
Ref: gnat_rm/the_implementation_of_standard_i_o id26765892
Ref: 2d2765892
Ref: gnat_rm/the_implementation_of_standard_i_o interfacing-to-c-streams765892
Ref: 2d3765892
Node: The GNAT Library769204
Ref: gnat_rm/the_gnat_library doc769343
Ref: 2d4769343
Ref: gnat_rm/the_gnat_library id1769343
Ref: 2d5769343
Ref: gnat_rm/the_gnat_library the-gnat-library769343
Ref: 10769343
Node: Ada Characters Latin_9 a-chlat9 ads783063
Ref: gnat_rm/the_gnat_library ada-characters-latin-9-a-chlat9-ads783201
Ref: 2d6783201
Ref: gnat_rm/the_gnat_library id2783201
Ref: 2d7783201
Node: Ada Characters Wide_Latin_1 a-cwila1 ads783609
Ref: gnat_rm/the_gnat_library ada-characters-wide-latin-1-a-cwila1-ads783796
Ref: 2d8783796
Ref: gnat_rm/the_gnat_library id3783796
Ref: 2d9783796
Node: Ada Characters Wide_Latin_9 a-cwila1 ads784248
Ref: gnat_rm/the_gnat_library ada-characters-wide-latin-9-a-cwila1-ads784445
Ref: 2da784445
Ref: gnat_rm/the_gnat_library id4784445
Ref: 2db784445
Node: Ada Characters Wide_Wide_Latin_1 a-chzla1 ads784899
Ref: gnat_rm/the_gnat_library ada-characters-wide-wide-latin-1-a-chzla1-ads785101
Ref: 2dc785101
Ref: gnat_rm/the_gnat_library id5785101
Ref: 2dd785101
Node: Ada Characters Wide_Wide_Latin_9 a-chzla9 ads785568
Ref: gnat_rm/the_gnat_library ada-characters-wide-wide-latin-9-a-chzla9-ads785784
Ref: 2de785784
Ref: gnat_rm/the_gnat_library id6785784
Ref: 2df785784
Node: Ada Containers Formal_Doubly_Linked_Lists a-cfdlli ads786253
Ref: gnat_rm/the_gnat_library ada-containers-formal-doubly-linked-lists-a-cfdlli-ads786470
Ref: 2e0786470
Ref: gnat_rm/the_gnat_library id7786470
Ref: 2e1786470
Node: Ada Containers Formal_Hashed_Maps a-cfhama ads787151
Ref: gnat_rm/the_gnat_library ada-containers-formal-hashed-maps-a-cfhama-ads787369
Ref: 2e2787369
Ref: gnat_rm/the_gnat_library id8787369
Ref: 2e3787369
Node: Ada Containers Formal_Hashed_Sets a-cfhase ads788026
Ref: gnat_rm/the_gnat_library ada-containers-formal-hashed-sets-a-cfhase-ads788237
Ref: 2e4788237
Ref: gnat_rm/the_gnat_library id9788237
Ref: 2e5788237
Node: Ada Containers Formal_Ordered_Maps a-cforma ads788894
Ref: gnat_rm/the_gnat_library ada-containers-formal-ordered-maps-a-cforma-ads789106
Ref: 2e6789106
Ref: gnat_rm/the_gnat_library id10789106
Ref: 2e7789106
Node: Ada Containers Formal_Ordered_Sets a-cforse ads789766
Ref: gnat_rm/the_gnat_library ada-containers-formal-ordered-sets-a-cforse-ads789974
Ref: 2e8789974
Ref: gnat_rm/the_gnat_library id11789974
Ref: 2e9789974
Node: Ada Containers Formal_Vectors a-cofove ads790636
Ref: gnat_rm/the_gnat_library ada-containers-formal-vectors-a-cofove-ads790850
Ref: 2ea790850
Ref: gnat_rm/the_gnat_library id12790850
Ref: 2eb790850
Node: Ada Containers Formal_Indefinite_Vectors a-cfinve ads791497
Ref: gnat_rm/the_gnat_library ada-containers-formal-indefinite-vectors-a-cfinve-ads791710
Ref: 2ec791710
Ref: gnat_rm/the_gnat_library id13791710
Ref: 2ed791710
Node: Ada Containers Functional_Vectors a-cofuve ads792402
Ref: gnat_rm/the_gnat_library ada-containers-functional-vectors-a-cofuve-ads792616
Ref: 2ee792616
Ref: gnat_rm/the_gnat_library id14792616
Ref: 2ef792616
Node: Ada Containers Functional_Sets a-cofuse ads793553
Ref: gnat_rm/the_gnat_library ada-containers-functional-sets-a-cofuse-ads793757
Ref: 2f0793757
Ref: gnat_rm/the_gnat_library id15793757
Ref: 2f1793757
Node: Ada Containers Functional_Maps a-cofuma ads794686
Ref: gnat_rm/the_gnat_library ada-containers-functional-maps-a-cofuma-ads794887
Ref: 2f2794887
Ref: gnat_rm/the_gnat_library id16794887
Ref: 2f3794887
Node: Ada Containers Bounded_Holders a-coboho ads795816
Ref: gnat_rm/the_gnat_library ada-containers-bounded-holders-a-coboho-ads796015
Ref: 2f4796015
Ref: gnat_rm/the_gnat_library id17796015
Ref: 2f5796015
Node: Ada Command_Line Environment a-colien ads796250
Ref: gnat_rm/the_gnat_library ada-command-line-environment-a-colien-ads796442
Ref: 2f6796442
Ref: gnat_rm/the_gnat_library id18796442
Ref: 2f7796442
Node: Ada Command_Line Remove a-colire ads796694
Ref: gnat_rm/the_gnat_library ada-command-line-remove-a-colire-ads796886
Ref: 2f8796886
Ref: gnat_rm/the_gnat_library id19796886
Ref: 2f9796886
Node: Ada Command_Line Response_File a-clrefi ads797248
Ref: gnat_rm/the_gnat_library ada-command-line-response-file-a-clrefi-ads797435
Ref: 2fa797435
Ref: gnat_rm/the_gnat_library id20797435
Ref: 2fb797435
Node: Ada Direct_IO C_Streams a-diocst ads797849
Ref: gnat_rm/the_gnat_library ada-direct-io-c-streams-a-diocst-ads798046
Ref: 2fc798046
Ref: gnat_rm/the_gnat_library id21798046
Ref: 2fd798046
Node: Ada Exceptions Is_Null_Occurrence a-einuoc ads798397
Ref: gnat_rm/the_gnat_library ada-exceptions-is-null-occurrence-a-einuoc-ads798598
Ref: 2fe798598
Ref: gnat_rm/the_gnat_library id22798598
Ref: 2ff798598
Node: Ada Exceptions Last_Chance_Handler a-elchha ads798862
Ref: gnat_rm/the_gnat_library ada-exceptions-last-chance-handler-a-elchha-ads799064
Ref: 300799064
Ref: gnat_rm/the_gnat_library id23799064
Ref: 301799064
Node: Ada Exceptions Traceback a-exctra ads799394
Ref: gnat_rm/the_gnat_library ada-exceptions-traceback-a-exctra-ads799590
Ref: 302799590
Ref: gnat_rm/the_gnat_library id24799590
Ref: 303799590
Node: Ada Sequential_IO C_Streams a-siocst ads799835
Ref: gnat_rm/the_gnat_library ada-sequential-io-c-streams-a-siocst-ads800028
Ref: 304800028
Ref: gnat_rm/the_gnat_library id25800028
Ref: 305800028
Node: Ada Streams Stream_IO C_Streams a-ssicst ads800391
Ref: gnat_rm/the_gnat_library ada-streams-stream-io-c-streams-a-ssicst-ads800589
Ref: 306800589
Ref: gnat_rm/the_gnat_library id26800589
Ref: 307800589
Node: Ada Strings Unbounded Text_IO a-suteio ads800956
Ref: gnat_rm/the_gnat_library ada-strings-unbounded-text-io-a-suteio-ads801166
Ref: 308801166
Ref: gnat_rm/the_gnat_library id27801166
Ref: 309801166
Node: Ada Strings Wide_Unbounded Wide_Text_IO a-swuwti ads801431
Ref: gnat_rm/the_gnat_library ada-strings-wide-unbounded-wide-text-io-a-swuwti-ads801659
Ref: 30a801659
Ref: gnat_rm/the_gnat_library id28801659
Ref: 30b801659
Node: Ada Strings Wide_Wide_Unbounded Wide_Wide_Text_IO a-szuzti ads801954
Ref: gnat_rm/the_gnat_library ada-strings-wide-wide-unbounded-wide-wide-text-io-a-szuzti-ads802176
Ref: 30c802176
Ref: gnat_rm/the_gnat_library id29802176
Ref: 30d802176
Node: Ada Task_Initialization a-tasini ads802501
Ref: gnat_rm/the_gnat_library ada-task-initialization-a-tasini-ads802705
Ref: 30e802705
Ref: gnat_rm/the_gnat_library id30802705
Ref: 30f802705
Node: Ada Text_IO C_Streams a-tiocst ads803074
Ref: gnat_rm/the_gnat_library ada-text-io-c-streams-a-tiocst-ads803261
Ref: 310803261
Ref: gnat_rm/the_gnat_library id31803261
Ref: 311803261
Node: Ada Text_IO Reset_Standard_Files a-tirsfi ads803606
Ref: gnat_rm/the_gnat_library ada-text-io-reset-standard-files-a-tirsfi-ads803797
Ref: 312803797
Ref: gnat_rm/the_gnat_library id32803797
Ref: 313803797
Node: Ada Wide_Characters Unicode a-wichun ads804216
Ref: gnat_rm/the_gnat_library ada-wide-characters-unicode-a-wichun-ads804412
Ref: 314804412
Ref: gnat_rm/the_gnat_library id33804412
Ref: 315804412
Node: Ada Wide_Text_IO C_Streams a-wtcstr ads804646
Ref: gnat_rm/the_gnat_library ada-wide-text-io-c-streams-a-wtcstr-ads804847
Ref: 316804847
Ref: gnat_rm/the_gnat_library id34804847
Ref: 317804847
Node: Ada Wide_Text_IO Reset_Standard_Files a-wrstfi ads805207
Ref: gnat_rm/the_gnat_library ada-wide-text-io-reset-standard-files-a-wrstfi-ads805413
Ref: 318805413
Ref: gnat_rm/the_gnat_library id35805413
Ref: 319805413
Node: Ada Wide_Wide_Characters Unicode a-zchuni ads805847
Ref: gnat_rm/the_gnat_library ada-wide-wide-characters-unicode-a-zchuni-ads806058
Ref: 31a806058
Ref: gnat_rm/the_gnat_library id36806058
Ref: 31b806058
Node: Ada Wide_Wide_Text_IO C_Streams a-ztcstr ads806307
Ref: gnat_rm/the_gnat_library ada-wide-wide-text-io-c-streams-a-ztcstr-ads806523
Ref: 31c806523
Ref: gnat_rm/the_gnat_library id37806523
Ref: 31d806523
Node: Ada Wide_Wide_Text_IO Reset_Standard_Files a-zrstfi ads806898
Ref: gnat_rm/the_gnat_library ada-wide-wide-text-io-reset-standard-files-a-zrstfi-ads807094
Ref: 31e807094
Ref: gnat_rm/the_gnat_library id38807094
Ref: 31f807094
Node: GNAT Altivec g-altive ads807543
Ref: gnat_rm/the_gnat_library gnat-altivec-g-altive-ads807732
Ref: 320807732
Ref: gnat_rm/the_gnat_library id39807732
Ref: 321807732
Node: GNAT Altivec Conversions g-altcon ads807963
Ref: gnat_rm/the_gnat_library gnat-altivec-conversions-g-altcon-ads808140
Ref: 322808140
Ref: gnat_rm/the_gnat_library id40808140
Ref: 323808140
Node: GNAT Altivec Vector_Operations g-alveop ads808309
Ref: gnat_rm/the_gnat_library gnat-altivec-vector-operations-g-alveop-ads808499
Ref: 324808499
Ref: gnat_rm/the_gnat_library id41808499
Ref: 325808499
Node: GNAT Altivec Vector_Types g-alvety ads808859
Ref: gnat_rm/the_gnat_library gnat-altivec-vector-types-g-alvety-ads809050
Ref: 326809050
Ref: gnat_rm/the_gnat_library id42809050
Ref: 327809050
Node: GNAT Altivec Vector_Views g-alvevi ads809255
Ref: gnat_rm/the_gnat_library gnat-altivec-vector-views-g-alvevi-ads809432
Ref: 328809432
Ref: gnat_rm/the_gnat_library id43809432
Ref: 329809432
Node: GNAT Array_Split g-arrspl ads809803
Ref: gnat_rm/the_gnat_library gnat-array-split-g-arrspl-ads809960
Ref: 32a809960
Ref: gnat_rm/the_gnat_library id44809960
Ref: 32b809960
Node: GNAT AWK g-awk ads810215
Ref: gnat_rm/the_gnat_library gnat-awk-g-awk-ads810368
Ref: 32c810368
Ref: gnat_rm/the_gnat_library id45810368
Ref: 32d810368
Node: GNAT Bind_Environment g-binenv ads810663
Ref: gnat_rm/the_gnat_library gnat-bind-environment-g-binenv-ads810822
Ref: 32e810822
Ref: gnat_rm/the_gnat_library id46810822
Ref: 32f810822
Node: GNAT Branch_Prediction g-brapre ads811075
Ref: gnat_rm/the_gnat_library gnat-branch-prediction-g-brapre-ads811249
Ref: 330811249
Ref: gnat_rm/the_gnat_library id47811249
Ref: 331811249
Node: GNAT Bounded_Buffers g-boubuf ads811433
Ref: gnat_rm/the_gnat_library gnat-bounded-buffers-g-boubuf-ads811608
Ref: 332811608
Ref: gnat_rm/the_gnat_library id48811608
Ref: 333811608
Node: GNAT Bounded_Mailboxes g-boumai ads811876
Ref: gnat_rm/the_gnat_library gnat-bounded-mailboxes-g-boumai-ads812045
Ref: 334812045
Ref: gnat_rm/the_gnat_library id49812045
Ref: 335812045
Node: GNAT Bubble_Sort g-bubsor ads812229
Ref: gnat_rm/the_gnat_library gnat-bubble-sort-g-bubsor-ads812396
Ref: 336812396
Ref: gnat_rm/the_gnat_library id50812396
Ref: 337812396
Node: GNAT Bubble_Sort_A g-busora ads812668
Ref: gnat_rm/the_gnat_library gnat-bubble-sort-a-g-busora-ads812831
Ref: 338812831
Ref: gnat_rm/the_gnat_library id51812831
Ref: 339812831
Node: GNAT Bubble_Sort_G g-busorg ads813210
Ref: gnat_rm/the_gnat_library gnat-bubble-sort-g-g-busorg-ads813377
Ref: 33a813377
Ref: gnat_rm/the_gnat_library id52813377
Ref: 33b813377
Node: GNAT Byte_Order_Mark g-byorma ads813721
Ref: gnat_rm/the_gnat_library gnat-byte-order-mark-g-byorma-ads813888
Ref: 33c813888
Ref: gnat_rm/the_gnat_library id53813888
Ref: 33d813888
Node: GNAT Byte_Swapping g-bytswa ads814258
Ref: gnat_rm/the_gnat_library gnat-byte-swapping-g-bytswa-ads814420
Ref: 33e814420
Ref: gnat_rm/the_gnat_library id54814420
Ref: 33f814420
Node: GNAT Calendar g-calend ads814655
Ref: gnat_rm/the_gnat_library gnat-calendar-g-calend-ads814818
Ref: 340814818
Ref: gnat_rm/the_gnat_library id55814818
Ref: 341814818
Node: GNAT Calendar Time_IO g-catiio ads815155
Ref: gnat_rm/the_gnat_library gnat-calendar-time-io-g-catiio-ads815309
Ref: 342815309
Ref: gnat_rm/the_gnat_library id56815309
Ref: 343815309
Node: GNAT CRC32 g-crc32 ads815412
Ref: gnat_rm/the_gnat_library gnat-crc32-g-crc32-ads815567
Ref: 344815567
Ref: gnat_rm/the_gnat_library id57815567
Ref: 345815567
Node: GNAT Case_Util g-casuti ads815893
Ref: gnat_rm/the_gnat_library gnat-case-util-g-casuti-ads816032
Ref: 346816032
Ref: gnat_rm/the_gnat_library id58816032
Ref: 347816032
Node: GNAT CGI g-cgi ads816275
Ref: gnat_rm/the_gnat_library gnat-cgi-g-cgi-ads816420
Ref: 348816420
Ref: gnat_rm/the_gnat_library id59816420
Ref: 349816420
Node: GNAT CGI Cookie g-cgicoo ads816802
Ref: gnat_rm/the_gnat_library gnat-cgi-cookie-g-cgicoo-ads816947
Ref: 34a816947
Ref: gnat_rm/the_gnat_library id60816947
Ref: 34b816947
Node: GNAT CGI Debug g-cgideb ads817244
Ref: gnat_rm/the_gnat_library gnat-cgi-debug-g-cgideb-ads817401
Ref: 34c817401
Ref: gnat_rm/the_gnat_library id61817401
Ref: 34d817401
Node: GNAT Command_Line g-comlin ads817583
Ref: gnat_rm/the_gnat_library gnat-command-line-g-comlin-ads817746
Ref: 34e817746
Ref: gnat_rm/the_gnat_library id62817746
Ref: 34f817746
Node: GNAT Compiler_Version g-comver ads818034
Ref: gnat_rm/the_gnat_library gnat-compiler-version-g-comver-ads818194
Ref: 350818194
Ref: gnat_rm/the_gnat_library id63818194
Ref: 351818194
Node: GNAT Ctrl_C g-ctrl_c ads818598
Ref: gnat_rm/the_gnat_library gnat-ctrl-c-g-ctrl-c-ads818763
Ref: 352818763
Ref: gnat_rm/the_gnat_library id64818763
Ref: 353818763
Node: GNAT Current_Exception g-curexc ads818909
Ref: gnat_rm/the_gnat_library gnat-current-exception-g-curexc-ads819069
Ref: 354819069
Ref: gnat_rm/the_gnat_library id65819069
Ref: 355819069
Node: GNAT Debug_Pools g-debpoo ads819485
Ref: gnat_rm/the_gnat_library gnat-debug-pools-g-debpoo-ads819654
Ref: 356819654
Ref: gnat_rm/the_gnat_library id66819654
Ref: 357819654
Node: GNAT Debug_Utilities g-debuti ads819912
Ref: gnat_rm/the_gnat_library gnat-debug-utilities-g-debuti-ads820077
Ref: 358820077
Ref: gnat_rm/the_gnat_library id67820077
Ref: 359820077
Node: GNAT Decode_String g-decstr ads820360
Ref: gnat_rm/the_gnat_library gnat-decode-string-g-decstr-ads820532
Ref: 35a820532
Ref: gnat_rm/the_gnat_library id68820532
Ref: 35b820532
Node: GNAT Decode_UTF8_String g-deutst ads821040
Ref: gnat_rm/the_gnat_library gnat-decode-utf8-string-g-deutst-ads821217
Ref: 35c821217
Ref: gnat_rm/the_gnat_library id69821217
Ref: 35d821217
Node: GNAT Directory_Operations g-dirope ads821387
Ref: gnat_rm/the_gnat_library gnat-directory-operations-g-dirope-ads821581
Ref: 35e821581
Ref: gnat_rm/the_gnat_library id70821581
Ref: 35f821581
Node: GNAT Directory_Operations Iteration g-diopit ads821855
Ref: gnat_rm/the_gnat_library gnat-directory-operations-iteration-g-diopit-ads822046
Ref: 360822046
Ref: gnat_rm/the_gnat_library id71822046
Ref: 361822046
Node: GNAT Dynamic_HTables g-dynhta ads822287
Ref: gnat_rm/the_gnat_library gnat-dynamic-htables-g-dynhta-ads822472
Ref: 362822472
Ref: gnat_rm/the_gnat_library id72822472
Ref: 363822472
Node: GNAT Dynamic_Tables g-dyntab ads823053
Ref: gnat_rm/the_gnat_library gnat-dynamic-tables-g-dyntab-ads823221
Ref: 364823221
Ref: gnat_rm/the_gnat_library id73823221
Ref: 365823221
Node: GNAT Encode_String g-encstr ads823704
Ref: gnat_rm/the_gnat_library gnat-encode-string-g-encstr-ads823875
Ref: 366823875
Ref: gnat_rm/the_gnat_library id74823875
Ref: 367823875
Node: GNAT Encode_UTF8_String g-enutst ads824254
Ref: gnat_rm/the_gnat_library gnat-encode-utf8-string-g-enutst-ads824428
Ref: 368824428
Ref: gnat_rm/the_gnat_library id75824428
Ref: 369824428
Node: GNAT Exception_Actions g-excact ads824598
Ref: gnat_rm/the_gnat_library gnat-exception-actions-g-excact-ads824775
Ref: 36a824775
Ref: gnat_rm/the_gnat_library id76824775
Ref: 36b824775
Node: GNAT Exception_Traces g-exctra ads825086
Ref: gnat_rm/the_gnat_library gnat-exception-traces-g-exctra-ads825255
Ref: 36c825255
Ref: gnat_rm/the_gnat_library id77825255
Ref: 36d825255
Node: GNAT Exceptions g-except ads825446
Ref: gnat_rm/the_gnat_library gnat-exceptions-g-except-ads825604
Ref: 36e825604
Ref: gnat_rm/the_gnat_library id78825604
Ref: 36f825604
Node: GNAT Expect g-expect ads826097
Ref: gnat_rm/the_gnat_library gnat-expect-g-expect-ads826249
Ref: 370826249
Ref: gnat_rm/the_gnat_library id79826249
Ref: 371826249
Node: GNAT Expect TTY g-exptty ads826780
Ref: gnat_rm/the_gnat_library gnat-expect-tty-g-exptty-ads826935
Ref: 372826935
Ref: gnat_rm/the_gnat_library id80826935
Ref: 373826935
Node: GNAT Float_Control g-flocon ads827243
Ref: gnat_rm/the_gnat_library gnat-float-control-g-flocon-ads827408
Ref: 374827408
Ref: gnat_rm/the_gnat_library id81827408
Ref: 375827408
Node: GNAT Formatted_String g-forstr ads827787
Ref: gnat_rm/the_gnat_library gnat-formatted-string-g-forstr-ads827951
Ref: 376827951
Ref: gnat_rm/the_gnat_library id82827951
Ref: 377827951
Node: GNAT Heap_Sort g-heasor ads828343
Ref: gnat_rm/the_gnat_library gnat-heap-sort-g-heasor-ads828505
Ref: 378828505
Ref: gnat_rm/the_gnat_library id83828505
Ref: 379828505
Node: GNAT Heap_Sort_A g-hesora ads828883
Ref: gnat_rm/the_gnat_library gnat-heap-sort-a-g-hesora-ads829040
Ref: 37a829040
Ref: gnat_rm/the_gnat_library id84829040
Ref: 37b829040
Node: GNAT Heap_Sort_G g-hesorg ads829533
Ref: gnat_rm/the_gnat_library gnat-heap-sort-g-g-hesorg-ads829687
Ref: 37c829687
Ref: gnat_rm/the_gnat_library id85829687
Ref: 37d829687
Node: GNAT HTable g-htable ads830025
Ref: gnat_rm/the_gnat_library gnat-htable-g-htable-ads830166
Ref: 37e830166
Ref: gnat_rm/the_gnat_library id86830166
Ref: 37f830166
Node: GNAT IO g-io ads830441
Ref: gnat_rm/the_gnat_library gnat-io-g-io-ads830577
Ref: 380830577
Ref: gnat_rm/the_gnat_library id87830577
Ref: 381830577
Node: GNAT IO_Aux g-io_aux ads830886
Ref: gnat_rm/the_gnat_library gnat-io-aux-g-io-aux-ads831026
Ref: 382831026
Ref: gnat_rm/the_gnat_library id88831026
Ref: 383831026
Node: GNAT Lock_Files g-locfil ads831252
Ref: gnat_rm/the_gnat_library gnat-lock-files-g-locfil-ads831414
Ref: 384831414
Ref: gnat_rm/the_gnat_library id89831414
Ref: 385831414
Node: GNAT MBBS_Discrete_Random g-mbdira ads831619
Ref: gnat_rm/the_gnat_library gnat-mbbs-discrete-random-g-mbdira-ads831792
Ref: 386831792
Ref: gnat_rm/the_gnat_library id90831792
Ref: 387831792
Node: GNAT MBBS_Float_Random g-mbflra ads832029
Ref: gnat_rm/the_gnat_library gnat-mbbs-float-random-g-mbflra-ads832192
Ref: 388832192
Ref: gnat_rm/the_gnat_library id91832192
Ref: 389832192
Node: GNAT MD5 g-md5 ads832420
Ref: gnat_rm/the_gnat_library gnat-md5-g-md5-ads832574
Ref: 38a832574
Ref: gnat_rm/the_gnat_library id92832574
Ref: 38b832574
Node: GNAT Memory_Dump g-memdum ads832808
Ref: gnat_rm/the_gnat_library gnat-memory-dump-g-memdum-ads832966
Ref: 38c832966
Ref: gnat_rm/the_gnat_library id93832966
Ref: 38d832966
Node: GNAT Most_Recent_Exception g-moreex ads833201
Ref: gnat_rm/the_gnat_library gnat-most-recent-exception-g-moreex-ads833365
Ref: 38e833365
Ref: gnat_rm/the_gnat_library id94833365
Ref: 38f833365
Node: GNAT OS_Lib g-os_lib ads833665
Ref: gnat_rm/the_gnat_library gnat-os-lib-g-os-lib-ads833841
Ref: 390833841
Ref: gnat_rm/the_gnat_library id95833841
Ref: 391833841
Node: GNAT Perfect_Hash_Generators g-pehage ads834172
Ref: gnat_rm/the_gnat_library gnat-perfect-hash-generators-g-pehage-ads834341
Ref: 392834341
Ref: gnat_rm/the_gnat_library id96834341
Ref: 393834341
Node: GNAT Random_Numbers g-rannum ads834992
Ref: gnat_rm/the_gnat_library gnat-random-numbers-g-rannum-ads835161
Ref: 394835161
Ref: gnat_rm/the_gnat_library id97835161
Ref: 395835161
Node: GNAT Regexp g-regexp ads835386
Ref: gnat_rm/the_gnat_library gnat-regexp-g-regexp-ads835540
Ref: 25b835540
Ref: gnat_rm/the_gnat_library id98835540
Ref: 396835540
Node: GNAT Registry g-regist ads835896
Ref: gnat_rm/the_gnat_library gnat-registry-g-regist-ads836042
Ref: 397836042
Ref: gnat_rm/the_gnat_library id99836042
Ref: 398836042
Node: GNAT Regpat g-regpat ads836396
Ref: gnat_rm/the_gnat_library gnat-regpat-g-regpat-ads836548
Ref: 399836548
Ref: gnat_rm/the_gnat_library id100836548
Ref: 39a836548
Node: GNAT Rewrite_Data g-rewdat ads836837
Ref: gnat_rm/the_gnat_library gnat-rewrite-data-g-rewdat-ads837001
Ref: 39b837001
Ref: gnat_rm/the_gnat_library id101837001
Ref: 39c837001
Node: GNAT Secondary_Stack_Info g-sestin ads837367
Ref: gnat_rm/the_gnat_library gnat-secondary-stack-info-g-sestin-ads837535
Ref: 39d837535
Ref: gnat_rm/the_gnat_library id102837535
Ref: 39e837535
Node: GNAT Semaphores g-semaph ads837742
Ref: gnat_rm/the_gnat_library gnat-semaphores-g-semaph-ads837919
Ref: 39f837919
Ref: gnat_rm/the_gnat_library id103837919
Ref: 3a0837919
Node: GNAT Serial_Communications g-sercom ads838084
Ref: gnat_rm/the_gnat_library gnat-serial-communications-g-sercom-ads838243
Ref: 3a1838243
Ref: gnat_rm/the_gnat_library id104838243
Ref: 3a2838243
Node: GNAT SHA1 g-sha1 ads838481
Ref: gnat_rm/the_gnat_library gnat-sha1-g-sha1-ads838636
Ref: 3a3838636
Ref: gnat_rm/the_gnat_library id105838636
Ref: 3a4838636
Node: GNAT SHA224 g-sha224 ads838895
Ref: gnat_rm/the_gnat_library gnat-sha224-g-sha224-ads839035
Ref: 3a5839035
Ref: gnat_rm/the_gnat_library id106839035
Ref: 3a6839035
Node: GNAT SHA256 g-sha256 ads839293
Ref: gnat_rm/the_gnat_library gnat-sha256-g-sha256-ads839437
Ref: 3a7839437
Ref: gnat_rm/the_gnat_library id107839437
Ref: 3a8839437
Node: GNAT SHA384 g-sha384 ads839695
Ref: gnat_rm/the_gnat_library gnat-sha384-g-sha384-ads839839
Ref: 3a9839839
Ref: gnat_rm/the_gnat_library id108839839
Ref: 3aa839839
Node: GNAT SHA512 g-sha512 ads840097
Ref: gnat_rm/the_gnat_library gnat-sha512-g-sha512-ads840242
Ref: 3ab840242
Ref: gnat_rm/the_gnat_library id109840242
Ref: 3ac840242
Node: GNAT Signals g-signal ads840500
Ref: gnat_rm/the_gnat_library gnat-signals-g-signal-ads840646
Ref: 3ad840646
Ref: gnat_rm/the_gnat_library id110840646
Ref: 3ae840646
Node: GNAT Sockets g-socket ads840821
Ref: gnat_rm/the_gnat_library gnat-sockets-g-socket-ads840972
Ref: 3af840972
Ref: gnat_rm/the_gnat_library id111840972
Ref: 3b0840972
Node: GNAT Source_Info g-souinf ads841368
Ref: gnat_rm/the_gnat_library gnat-source-info-g-souinf-ads841528
Ref: 3b1841528
Ref: gnat_rm/the_gnat_library id112841528
Ref: 3b2841528
Node: GNAT Spelling_Checker g-speche ads841894
Ref: gnat_rm/the_gnat_library gnat-spelling-checker-g-speche-ads842071
Ref: 3b3842071
Ref: gnat_rm/the_gnat_library id113842071
Ref: 3b4842071
Node: GNAT Spelling_Checker_Generic g-spchge ads842283
Ref: gnat_rm/the_gnat_library gnat-spelling-checker-generic-g-spchge-ads842465
Ref: 3b5842465
Ref: gnat_rm/the_gnat_library id114842465
Ref: 3b6842465
Node: GNAT Spitbol Patterns g-spipat ads842745
Ref: gnat_rm/the_gnat_library gnat-spitbol-patterns-g-spipat-ads842918
Ref: 3b7842918
Ref: gnat_rm/the_gnat_library id115842918
Ref: 3b8842918
Node: GNAT Spitbol g-spitbo ads843325
Ref: gnat_rm/the_gnat_library gnat-spitbol-g-spitbo-ads843495
Ref: 3b9843495
Ref: gnat_rm/the_gnat_library id116843495
Ref: 3ba843495
Node: GNAT Spitbol Table_Boolean g-sptabo ads843905
Ref: gnat_rm/the_gnat_library gnat-spitbol-table-boolean-g-sptabo-ads844080
Ref: 3bb844080
Ref: gnat_rm/the_gnat_library id117844080
Ref: 3bc844080
Node: GNAT Spitbol Table_Integer g-sptain ads844350
Ref: gnat_rm/the_gnat_library gnat-spitbol-table-integer-g-sptain-ads844539
Ref: 3bd844539
Ref: gnat_rm/the_gnat_library id118844539
Ref: 3be844539
Node: GNAT Spitbol Table_VString g-sptavs ads844822
Ref: gnat_rm/the_gnat_library gnat-spitbol-table-vstring-g-sptavs-ads844990
Ref: 3bf844990
Ref: gnat_rm/the_gnat_library id119844990
Ref: 3c0844990
Node: GNAT SSE g-sse ads845277
Ref: gnat_rm/the_gnat_library gnat-sse-g-sse-ads845440
Ref: 3c1845440
Ref: gnat_rm/the_gnat_library id120845440
Ref: 3c2845440
Node: GNAT SSE Vector_Types g-ssvety ads845767
Ref: gnat_rm/the_gnat_library gnat-sse-vector-types-g-ssvety-ads845920
Ref: 3c3845920
Ref: gnat_rm/the_gnat_library id121845920
Ref: 3c4845920
Node: GNAT String_Hash g-strhas ads846080
Ref: gnat_rm/the_gnat_library gnat-string-hash-g-strhas-ads846240
Ref: 3c5846240
Ref: gnat_rm/the_gnat_library id122846240
Ref: 3c6846240
Node: GNAT Strings g-string ads846462
Ref: gnat_rm/the_gnat_library gnat-strings-g-string-ads846618
Ref: 3c7846618
Ref: gnat_rm/the_gnat_library id123846618
Ref: 3c8846618
Node: GNAT String_Split g-strspl ads846833
Ref: gnat_rm/the_gnat_library gnat-string-split-g-strspl-ads846982
Ref: 3c9846982
Ref: gnat_rm/the_gnat_library id124846982
Ref: 3ca846982
Node: GNAT Table g-table ads847301
Ref: gnat_rm/the_gnat_library gnat-table-g-table-ads847452
Ref: 3cb847452
Ref: gnat_rm/the_gnat_library id125847452
Ref: 3cc847452
Node: GNAT Task_Lock g-tasloc ads847935
Ref: gnat_rm/the_gnat_library gnat-task-lock-g-tasloc-ads848084
Ref: 3cd848084
Ref: gnat_rm/the_gnat_library id126848084
Ref: 3ce848084
Node: GNAT Time_Stamp g-timsta ads848366
Ref: gnat_rm/the_gnat_library gnat-time-stamp-g-timsta-ads848518
Ref: 3cf848518
Ref: gnat_rm/the_gnat_library id127848518
Ref: 3d0848518
Node: GNAT Threads g-thread ads848844
Ref: gnat_rm/the_gnat_library gnat-threads-g-thread-ads848996
Ref: 3d1848996
Ref: gnat_rm/the_gnat_library id128848996
Ref: 3d2848996
Node: GNAT Traceback g-traceb ads849352
Ref: gnat_rm/the_gnat_library gnat-traceback-g-traceb-ads849512
Ref: 3d3849512
Ref: gnat_rm/the_gnat_library id129849512
Ref: 3d4849512
Node: GNAT Traceback Symbolic g-trasym ads849714
Ref: gnat_rm/the_gnat_library gnat-traceback-symbolic-g-trasym-ads849872
Ref: 3d5849872
Ref: gnat_rm/the_gnat_library id130849872
Ref: 3d6849872
Node: GNAT UTF_32 g-table ads849981
Ref: gnat_rm/the_gnat_library gnat-utf-32-g-table-ads850151
Ref: 3d7850151
Ref: gnat_rm/the_gnat_library id131850151
Ref: 3d8850151
Node: GNAT Wide_Spelling_Checker g-u3spch ads850713
Ref: gnat_rm/the_gnat_library gnat-wide-spelling-checker-g-u3spch-ads850886
Ref: 3d9850886
Ref: gnat_rm/the_gnat_library id132850886
Ref: 3da850886
Node: GNAT Wide_Spelling_Checker g-wispch ads851218
Ref: gnat_rm/the_gnat_library gnat-wide-spelling-checker-g-wispch-ads851403
Ref: 3db851403
Ref: gnat_rm/the_gnat_library id133851403
Ref: 3dc851403
Node: GNAT Wide_String_Split g-wistsp ads851635
Ref: gnat_rm/the_gnat_library gnat-wide-string-split-g-wistsp-ads851825
Ref: 3dd851825
Ref: gnat_rm/the_gnat_library id134851825
Ref: 3de851825
Node: GNAT Wide_Wide_Spelling_Checker g-zspche ads852164
Ref: gnat_rm/the_gnat_library gnat-wide-wide-spelling-checker-g-zspche-ads852355
Ref: 3df852355
Ref: gnat_rm/the_gnat_library id135852355
Ref: 3e0852355
Node: GNAT Wide_Wide_String_Split g-zistsp ads852607
Ref: gnat_rm/the_gnat_library gnat-wide-wide-string-split-g-zistsp-ads852799
Ref: 3e1852799
Ref: gnat_rm/the_gnat_library id136852799
Ref: 3e2852799
Node: Interfaces C Extensions i-cexten ads853158
Ref: gnat_rm/the_gnat_library id137853339
Ref: 3e3853339
Ref: gnat_rm/the_gnat_library interfaces-c-extensions-i-cexten-ads853339
Ref: 3e4853339
Node: Interfaces C Streams i-cstrea ads853595
Ref: gnat_rm/the_gnat_library id138853774
Ref: 3e5853774
Ref: gnat_rm/the_gnat_library interfaces-c-streams-i-cstrea-ads853774
Ref: 3e6853774
Node: Interfaces Packed_Decimal i-pacdec ads853956
Ref: gnat_rm/the_gnat_library id139854130
Ref: 3e7854130
Ref: gnat_rm/the_gnat_library interfaces-packed-decimal-i-pacdec-ads854130
Ref: 3e8854130
Node: Interfaces VxWorks i-vxwork ads854381
Ref: gnat_rm/the_gnat_library id140854568
Ref: 3e9854568
Ref: gnat_rm/the_gnat_library interfaces-vxworks-i-vxwork-ads854568
Ref: 3ea854568
Node: Interfaces VxWorks Int_Connection i-vxinco ads854805
Ref: gnat_rm/the_gnat_library id141854988
Ref: 3eb854988
Ref: gnat_rm/the_gnat_library interfaces-vxworks-int-connection-i-vxinco-ads854988
Ref: 3ec854988
Node: Interfaces VxWorks IO i-vxwoio ads855248
Ref: gnat_rm/the_gnat_library id142855433
Ref: 3ed855433
Ref: gnat_rm/the_gnat_library interfaces-vxworks-io-i-vxwoio-ads855433
Ref: 3ee855433
Node: System Address_Image s-addima ads855757
Ref: gnat_rm/the_gnat_library id143855926
Ref: 3ef855926
Ref: gnat_rm/the_gnat_library system-address-image-s-addima-ads855926
Ref: 3f0855926
Node: System Assertions s-assert ads856158
Ref: gnat_rm/the_gnat_library id144856328
Ref: 3f1856328
Ref: gnat_rm/the_gnat_library system-assertions-s-assert-ads856328
Ref: 3f2856328
Node: System Atomic_Counters s-atocou ads856594
Ref: gnat_rm/the_gnat_library id145856757
Ref: 3f3856757
Ref: gnat_rm/the_gnat_library system-atomic-counters-s-atocou-ads856757
Ref: 3f4856757
Node: System Memory s-memory ads857203
Ref: gnat_rm/the_gnat_library id146857371
Ref: 3f5857371
Ref: gnat_rm/the_gnat_library system-memory-s-memory-ads857371
Ref: 3f6857371
Node: System Multiprocessors s-multip ads857978
Ref: gnat_rm/the_gnat_library id147858166
Ref: 3f7858166
Ref: gnat_rm/the_gnat_library system-multiprocessors-s-multip-ads858166
Ref: 3f8858166
Node: System Multiprocessors Dispatching_Domains s-mudido ads858464
Ref: gnat_rm/the_gnat_library id148858665
Ref: 3f9858665
Ref: gnat_rm/the_gnat_library system-multiprocessors-dispatching-domains-s-mudido-ads858665
Ref: 3fa858665
Node: System Partition_Interface s-parint ads859003
Ref: gnat_rm/the_gnat_library id149859200
Ref: 3fb859200
Ref: gnat_rm/the_gnat_library system-partition-interface-s-parint-ads859200
Ref: 3fc859200
Node: System Pool_Global s-pooglo ads859461
Ref: gnat_rm/the_gnat_library id150859633
Ref: 3fd859633
Ref: gnat_rm/the_gnat_library system-pool-global-s-pooglo-ads859633
Ref: 3fe859633
Node: System Pool_Local s-pooloc ads859975
Ref: gnat_rm/the_gnat_library id151860140
Ref: 3ff860140
Ref: gnat_rm/the_gnat_library system-pool-local-s-pooloc-ads860140
Ref: 400860140
Node: System Restrictions s-restri ads860515
Ref: gnat_rm/the_gnat_library id152860675
Ref: 401860675
Ref: gnat_rm/the_gnat_library system-restrictions-s-restri-ads860675
Ref: 402860675
Node: System Rident s-rident ads861113
Ref: gnat_rm/the_gnat_library id153861281
Ref: 403861281
Ref: gnat_rm/the_gnat_library system-rident-s-rident-ads861281
Ref: 404861281
Node: System Strings Stream_Ops s-ststop ads861680
Ref: gnat_rm/the_gnat_library id154861850
Ref: 405861850
Ref: gnat_rm/the_gnat_library system-strings-stream-ops-s-ststop-ads861850
Ref: 406861850
Node: System Unsigned_Types s-unstyp ads862245
Ref: gnat_rm/the_gnat_library id155862416
Ref: 407862416
Ref: gnat_rm/the_gnat_library system-unsigned-types-s-unstyp-ads862416
Ref: 408862416
Node: System Wch_Cnv s-wchcnv ads862852
Ref: gnat_rm/the_gnat_library id156863012
Ref: 409863012
Ref: gnat_rm/the_gnat_library system-wch-cnv-s-wchcnv-ads863012
Ref: 40a863012
Node: System Wch_Con s-wchcon ads863355
Ref: gnat_rm/the_gnat_library id157863472
Ref: 40b863472
Ref: gnat_rm/the_gnat_library system-wch-con-s-wchcon-ads863472
Ref: 40c863472
Node: Interfacing to Other Languages863758
Ref: gnat_rm/interfacing_to_other_languages doc863888
Ref: 40d863888
Ref: gnat_rm/interfacing_to_other_languages id1863888
Ref: 40e863888
Ref: gnat_rm/interfacing_to_other_languages interfacing-to-other-languages863888
Ref: 11863888
Node: Interfacing to C864240
Ref: gnat_rm/interfacing_to_other_languages id2864351
Ref: 40f864351
Ref: gnat_rm/interfacing_to_other_languages interfacing-to-c864351
Ref: 410864351
Node: Interfacing to C++867154
Ref: gnat_rm/interfacing_to_other_languages id3867294
Ref: 46867294
Ref: gnat_rm/interfacing_to_other_languages id4867294
Ref: 411867294
Node: Interfacing to COBOL869506
Ref: gnat_rm/interfacing_to_other_languages id5869652
Ref: 412869652
Ref: gnat_rm/interfacing_to_other_languages interfacing-to-cobol869652
Ref: 413869652
Node: Interfacing to Fortran869796
Ref: gnat_rm/interfacing_to_other_languages id6869956
Ref: 414869956
Ref: gnat_rm/interfacing_to_other_languages interfacing-to-fortran869956
Ref: 415869956
Node: Interfacing to non-GNAT Ada code870282
Ref: gnat_rm/interfacing_to_other_languages id7870413
Ref: 416870413
Ref: gnat_rm/interfacing_to_other_languages interfacing-to-non-gnat-ada-code870413
Ref: 417870413
Node: Specialized Needs Annexes871440
Ref: gnat_rm/specialized_needs_annexes doc871593
Ref: 418871593
Ref: gnat_rm/specialized_needs_annexes id1871593
Ref: 419871593
Ref: gnat_rm/specialized_needs_annexes specialized-needs-annexes871593
Ref: 12871593
Node: Implementation of Specific Ada Features872664
Ref: gnat_rm/implementation_of_specific_ada_features doc872822
Ref: 41a872822
Ref: gnat_rm/implementation_of_specific_ada_features id1872822
Ref: 41b872822
Ref: gnat_rm/implementation_of_specific_ada_features implementation-of-specific-ada-features872822
Ref: 13872822
Node: Machine Code Insertions873311
Ref: gnat_rm/implementation_of_specific_ada_features id2873450
Ref: 41c873450
Ref: gnat_rm/implementation_of_specific_ada_features machine-code-insertions873450
Ref: 165873450
Node: GNAT Implementation of Tasking880868
Ref: gnat_rm/implementation_of_specific_ada_features gnat-implementation-of-tasking881062
Ref: 41d881062
Ref: gnat_rm/implementation_of_specific_ada_features id3881062
Ref: 41e881062
Node: Mapping Ada Tasks onto the Underlying Kernel Threads881476
Ref: gnat_rm/implementation_of_specific_ada_features id4881649
Ref: 41f881649
Ref: gnat_rm/implementation_of_specific_ada_features mapping-ada-tasks-onto-the-underlying-kernel-threads881649
Ref: 420881649
Node: Ensuring Compliance with the Real-Time Annex883805
Ref: gnat_rm/implementation_of_specific_ada_features ensuring-compliance-with-the-real-time-annex884015
Ref: 421884015
Ref: gnat_rm/implementation_of_specific_ada_features id5884015
Ref: 422884015
Node: Support for Locking Policies885927
Ref: gnat_rm/implementation_of_specific_ada_features support-for-locking-policies886076
Ref: 423886076
Node: GNAT Implementation of Shared Passive Packages887235
Ref: gnat_rm/implementation_of_specific_ada_features gnat-implementation-of-shared-passive-packages887442
Ref: 424887442
Ref: gnat_rm/implementation_of_specific_ada_features id6887442
Ref: 425887442
Node: Code Generation for Array Aggregates890555
Ref: gnat_rm/implementation_of_specific_ada_features code-generation-for-array-aggregates890792
Ref: 426890792
Ref: gnat_rm/implementation_of_specific_ada_features id7890792
Ref: 427890792
Node: Static constant aggregates with static bounds892215
Ref: gnat_rm/implementation_of_specific_ada_features id8892395
Ref: 428892395
Ref: gnat_rm/implementation_of_specific_ada_features static-constant-aggregates-with-static-bounds892395
Ref: 429892395
Node: Constant aggregates with unconstrained nominal types893798
Ref: gnat_rm/implementation_of_specific_ada_features constant-aggregates-with-unconstrained-nominal-types894016
Ref: 42a894016
Ref: gnat_rm/implementation_of_specific_ada_features id9894016
Ref: 42b894016
Node: Aggregates with static bounds894516
Ref: gnat_rm/implementation_of_specific_ada_features aggregates-with-static-bounds894721
Ref: 42c894721
Ref: gnat_rm/implementation_of_specific_ada_features id10894721
Ref: 42d894721
Node: Aggregates with nonstatic bounds895355
Ref: gnat_rm/implementation_of_specific_ada_features aggregates-with-nonstatic-bounds895543
Ref: 42e895543
Ref: gnat_rm/implementation_of_specific_ada_features id11895543
Ref: 42f895543
Node: Aggregates in assignment statements895951
Ref: gnat_rm/implementation_of_specific_ada_features aggregates-in-assignment-statements896101
Ref: 430896101
Ref: gnat_rm/implementation_of_specific_ada_features id12896101
Ref: 431896101
Node: The Size of Discriminated Records with Default Discriminants897359
Ref: gnat_rm/implementation_of_specific_ada_features id13897582
Ref: 432897582
Ref: gnat_rm/implementation_of_specific_ada_features the-size-of-discriminated-records-with-default-discriminants897582
Ref: 433897582
Node: Image Values For Nonscalar Types900526
Ref: gnat_rm/implementation_of_specific_ada_features id14900759
Ref: 434900759
Ref: gnat_rm/implementation_of_specific_ada_features image-values-for-nonscalar-types900759
Ref: 435900759
Node: Strict Conformance to the Ada Reference Manual901822
Ref: gnat_rm/implementation_of_specific_ada_features id15901986
Ref: 436901986
Ref: gnat_rm/implementation_of_specific_ada_features strict-conformance-to-the-ada-reference-manual901986
Ref: 437901986
Node: Implementation of Ada 2012 Features903417
Ref: gnat_rm/implementation_of_ada_2012_features doc903577
Ref: 438903577
Ref: gnat_rm/implementation_of_ada_2012_features id1903577
Ref: 439903577
Ref: gnat_rm/implementation_of_ada_2012_features implementation-of-ada-2012-features903577
Ref: 14903577
Node: Security Hardening Features952025
Ref: gnat_rm/security_hardening_features doc952166
Ref: 43a952166
Ref: gnat_rm/security_hardening_features id1952166
Ref: 43b952166
Ref: gnat_rm/security_hardening_features security-hardening-features952166
Ref: 15952166
Node: Register Scrubbing952402
Ref: gnat_rm/security_hardening_features register-scrubbing952509
Ref: 43c952509
Node: Stack Scrubbing953358
Ref: gnat_rm/security_hardening_features stack-scrubbing953495
Ref: 43d953495
Node: Hardened Conditionals956567
Ref: gnat_rm/security_hardening_features hardened-conditionals956677
Ref: 43e956677
Node: Obsolescent Features958456
Ref: gnat_rm/obsolescent_features doc958593
Ref: 43f958593
Ref: gnat_rm/obsolescent_features id1958593
Ref: 440958593
Ref: gnat_rm/obsolescent_features obsolescent-features958593
Ref: 16958593
Node: pragma No_Run_Time959057
Ref: gnat_rm/obsolescent_features id2959158
Ref: 441959158
Ref: gnat_rm/obsolescent_features pragma-no-run-time959158
Ref: 442959158
Node: pragma Ravenscar959690
Ref: gnat_rm/obsolescent_features id3959826
Ref: 443959826
Ref: gnat_rm/obsolescent_features pragma-ravenscar959826
Ref: 444959826
Node: pragma Restricted_Run_Time960042
Ref: gnat_rm/obsolescent_features id4960176
Ref: 445960176
Ref: gnat_rm/obsolescent_features pragma-restricted-run-time960176
Ref: 446960176
Node: pragma Task_Info960480
Ref: gnat_rm/obsolescent_features id5960635
Ref: 447960635
Ref: gnat_rm/obsolescent_features pragma-task-info960635
Ref: 448960635
Node: package System Task_Info s-tasinf ads961500
Ref: gnat_rm/obsolescent_features package-system-task-info961620
Ref: 449961620
Ref: gnat_rm/obsolescent_features package-system-task-info-s-tasinf-ads961620
Ref: 44a961620
Node: Compatibility and Porting Guide961986
Ref: gnat_rm/compatibility_and_porting_guide doc962126
Ref: 44b962126
Ref: gnat_rm/compatibility_and_porting_guide compatibility-and-porting-guide962126
Ref: 17962126
Ref: gnat_rm/compatibility_and_porting_guide id1962126
Ref: 44c962126
Node: Writing Portable Fixed-Point Declarations962765
Ref: gnat_rm/compatibility_and_porting_guide id2962909
Ref: 44d962909
Ref: gnat_rm/compatibility_and_porting_guide writing-portable-fixed-point-declarations962909
Ref: 44e962909
Node: Compatibility with Ada 83966807
Ref: gnat_rm/compatibility_and_porting_guide compatibility-with-ada-83967001
Ref: 44f967001
Ref: gnat_rm/compatibility_and_porting_guide id3967001
Ref: 450967001
Node: Legal Ada 83 programs that are illegal in Ada 95967875
Ref: gnat_rm/compatibility_and_porting_guide id4968023
Ref: 451968023
Ref: gnat_rm/compatibility_and_porting_guide legal-ada-83-programs-that-are-illegal-in-ada-95968023
Ref: 452968023
Node: More deterministic semantics972581
Ref: gnat_rm/compatibility_and_porting_guide id5972755
Ref: 453972755
Ref: gnat_rm/compatibility_and_porting_guide more-deterministic-semantics972755
Ref: 454972755
Node: Changed semantics973683
Ref: gnat_rm/compatibility_and_porting_guide changed-semantics973844
Ref: 455973844
Ref: gnat_rm/compatibility_and_porting_guide id6973844
Ref: 456973844
Node: Other language compatibility issues975427
Ref: gnat_rm/compatibility_and_porting_guide id7975551
Ref: 457975551
Ref: gnat_rm/compatibility_and_porting_guide other-language-compatibility-issues975551
Ref: 458975551
Node: Compatibility between Ada 95 and Ada 2005976844
Ref: gnat_rm/compatibility_and_porting_guide compatibility-between-ada-95-and-ada-2005977037
Ref: 459977037
Ref: gnat_rm/compatibility_and_porting_guide id8977037
Ref: 45a977037
Node: Implementation-dependent characteristics979466
Ref: gnat_rm/compatibility_and_porting_guide id9979670
Ref: 45b979670
Ref: gnat_rm/compatibility_and_porting_guide implementation-dependent-characteristics979670
Ref: 45c979670
Node: Implementation-defined pragmas980457
Ref: gnat_rm/compatibility_and_porting_guide id10980607
Ref: 45d980607
Ref: gnat_rm/compatibility_and_porting_guide implementation-defined-pragmas980607
Ref: 45e980607
Node: Implementation-defined attributes981591
Ref: gnat_rm/compatibility_and_porting_guide id11981759
Ref: 45f981759
Ref: gnat_rm/compatibility_and_porting_guide implementation-defined-attributes981759
Ref: 460981759
Node: Libraries982311
Ref: gnat_rm/compatibility_and_porting_guide id12982466
Ref: 461982466
Ref: gnat_rm/compatibility_and_porting_guide libraries982466
Ref: 462982466
Node: Elaboration order983370
Ref: gnat_rm/compatibility_and_porting_guide elaboration-order983515
Ref: 463983515
Ref: gnat_rm/compatibility_and_porting_guide id13983515
Ref: 464983515
Node: Target-specific aspects984967
Ref: gnat_rm/compatibility_and_porting_guide id14985094
Ref: 465985094
Ref: gnat_rm/compatibility_and_porting_guide target-specific-aspects985094
Ref: 466985094
Node: Compatibility with Other Ada Systems985857
Ref: gnat_rm/compatibility_and_porting_guide compatibility-with-other-ada-systems986042
Ref: 468986042
Ref: gnat_rm/compatibility_and_porting_guide id15986042
Ref: 469986042
Node: Representation Clauses987586
Ref: gnat_rm/compatibility_and_porting_guide id16987759
Ref: 46a987759
Ref: gnat_rm/compatibility_and_porting_guide representation-clauses987759
Ref: 467987759
Node: Compatibility with HP Ada 83992398
Ref: gnat_rm/compatibility_and_porting_guide compatibility-with-hp-ada-83992526
Ref: 46b992526
Ref: gnat_rm/compatibility_and_porting_guide id17992526
Ref: 46c992526
Node: GNU Free Documentation License993404
Ref: share/gnu_free_documentation_license doc993529
Ref: 46d993529
Ref: share/gnu_free_documentation_license gnu-fdl993529
Ref: 1993529
Ref: share/gnu_free_documentation_license gnu-free-documentation-license993529
Ref: 46e993529
Node: Index1016871

End Tag Table


Local Variables:
coding: utf-8
End:
