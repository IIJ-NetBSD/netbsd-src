# Copyright 2024 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Check GDB can handle reading the full executable name and argument
# list from a core file.
#
# Currently, only Linux supports reading full executable and arguments
# from a core file.
require {is_any_target "*-*-linux*" "*-*-freebsd*"}

standard_testfile

if {[build_executable $testfile.exp $testfile $srcfile] == -1} {
    untested "failed to compile"
    return -1
}

# Linux core files can encore upto 80 characters for the command and
# arguments in the psinfo.  If BINFILE is less than 80 characters in
# length then lets try to make it longer.
set binfile_len [string length $binfile]
if { $binfile_len <= 80 } {
    set extra_len [expr 80 - $binfile_len + 1]
    set extra_str [string repeat "x" $extra_len]
    set new_binfile $binfile$extra_str
    remote_exec build "mv $binfile $new_binfile"
    set binfile $new_binfile
}

# Generate a core file, this time the inferior has no additional
# arguments.
set corefile [core_find $binfile {}]
if {$corefile == ""} {
    untested "unable to create corefile"
    return 0
}
set corefile_1 "$binfile.1.core"
remote_exec build "mv $corefile $corefile_1"

# Load the core file and confirm that the full executable name is
# seen.
clean_restart $binfile
set saw_generated_line false
gdb_test_multiple "core-file $corefile_1" "load core file no args" {
    -re "^Core was generated by `[string_to_regexp $binfile]'\\.\r\n" {
	set saw_generated_line true
	exp_continue
    }

    -re "^$gdb_prompt $" {
	gdb_assert { $saw_generated_line } $gdb_test_name
    }

    -re "^\[^\r\n\]*\r\n" {
	exp_continue
    }
}

# Generate a core file, this time pass some arguments to the inferior.
set args "aaaaa bbbbb ccccc ddddd e\\\\ e\\\\ e\\\\ e\\\\ e"
set corefile [core_find $binfile {} $args]
if {$corefile == ""} {
    untested "unable to create corefile"
    return 0
}
set corefile_2 "$binfile.2.core"
remote_exec build "mv $corefile $corefile_2"

# Load the core file and confirm that the full executable name and
# argument list are seen.
clean_restart $binfile
set saw_generated_line false
gdb_test_multiple "core-file $corefile_2" "load core file with args" {
    -re "^Core was generated by `[string_to_regexp $binfile] $args'\\.\r\n" {
	set saw_generated_line true
	exp_continue
    }

    -re "^$gdb_prompt $" {
	gdb_assert { $saw_generated_line } $gdb_test_name
    }

    -re "^\[^\r\n\]*\r\n" {
	exp_continue
    }
}

# Also, the argument list should be available through 'show args'.
gdb_test "show args" \
    "Argument list to give program being debugged when it is started is \"$args\"\\."

# Move up to 'main'.  Do it this way because we cannot know how many
# frames up 'main' actually is.
gdb_test_multiple "up" "move up to main" {
    -re -wrap "#$decimal\\s+\[^\r\n\]+ in main .*" {
	pass $gdb_test_name
    }

    -re -wrap "#$decimal\\s+\[^\r\n\]+ in .*" {
	send_gdb "up\n"
	exp_continue
    }
}

# Check that the inferior was started with the expected arguments.
gdb_test "print argc" " = 6"
gdb_test "print argv\[1\]" " = $hex \"aaaaa\""
gdb_test "print argv\[2\]" " = $hex \"bbbbb\""
gdb_test "print argv\[3\]" " = $hex \"ccccc\""
gdb_test "print argv\[4\]" " = $hex \"ddddd\""
gdb_test "print argv\[5\]" " = $hex \"e e e e e\""

# Find the name of an environment variable that is not set.
set env_var_base "GDB_TEST_ENV_VAR_"
set env_var_name ""

for { set i 0 } { $i < 10 } { incr i } {
    set tmp_name ${env_var_base}${i}
    if { ! [info exists ::env($tmp_name)] } {
	set env_var_name $tmp_name
	break
    }
}

if { $env_var_name eq "" } {
    unsupported "couldn't find suitable environment variable name"
    return -1
}

# Generate a core file with this environment variable set.
set env_var_value "TEST VALUE"
save_vars { ::env($env_var_name) } {
    setenv $env_var_name $env_var_value

    set corefile [core_find $binfile {} $args]
    if {$corefile == ""} {
	untested "unable to create corefile"
	return 0
    }
}
set corefile_3 "$binfile.2.core"
remote_exec build "mv $corefile $corefile_3"

# Restart, load the core file, and check the environment variable
# shows up.
clean_restart $binfile

# Check for environment variable VAR_NAME in the environment, its
# value should be VAR_VALUE.
proc check_for_env_var { var_name var_value } {
    set saw_var false
    gdb_test_multiple "show environment" "" {
	-re "^$var_name=$var_value\r\n" {
	    set saw_var true
	    exp_continue
	}
	-re "^\[^\r\n\]*\r\n" {
	    exp_continue
	}
	-re "^$::gdb_prompt $" {
	}
    }
    return $saw_var
}

gdb_assert { ![check_for_env_var $env_var_name $env_var_value] } \
    "environment variable is not set before core file load"

gdb_test "core-file $corefile_3" \
    "Core was generated by `[string_to_regexp $binfile] $args'\\.\r\n.*" \
    "load core file for environment test"

gdb_assert { [check_for_env_var $env_var_name $env_var_value] } \
    "environment variable is set after core file load"
